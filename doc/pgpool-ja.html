<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html;charset=iso-2022-jp">
<link rel="stylesheet" href="./pgpool-ja.css" type="text/css">
<title>pgpool-II ユーザマニュアル</title>
</head>
<body>

<!-- hhmts start -->
Last modified: Wed May  2 15:24:17 JST 2012
<!-- hhmts end -->

<body bgcolor="#ffffff">
<div id="top" class="header_text">Welcome to pgpool -II page</div>

<div id="menu">
    <div id="navcontainer">
      <ul id="navlist">
        <li id="active"><a href="#Whatis" id="current">pgpool-IIとは</a></li>
        <li><a href="#platform">pgpool-IIの稼働環境</a></li>
        <li><a href="#install">pgpool-IIのインストール</a></li>
        <li><a href="#config">pgpool-IIの設定</a></li>
        <li><a href="#common">共通設定項目</a></li>
        <li><a href="#connection_pool_mode">コネクションプールモード</a></li>
        <li><a href="#replication_mode">レプリケーションモード</a></li>
        <li><a href="#master_slave_mode">マスタースレーブモード</a></li>
        <li><a href="#stream">Streaming Replicationへの対応</a></li>
        <li><a href="#parallel">パラレルモード</a></li>
        <li><a href="#hba">クライアント認証(HBA)のための pool_hba.conf 設定方法</a></li>
        <li><a href="#query_cache">クエリキャッシュの設定方法</a></li>
        <li><a href="#memqcache">オンメモリクエリキャッシュの設定方法</a></li>
        <li><a href="#start">pgpool-IIの起動と停止</a></li>
        <li><a href="#reload">pgpool-IIの設定ファイルの再読み込み</a></li>
        <li><a href="#show-commands">SHOWコマンド</a></li>
        <li><a href="#online-recovery">オンラインリカバリ</a></li>
        <li><a href="#backup">バックアップ</a></li>
        <li><a href="#deploy">pgpool-IIの配置について</a></li>
        <li><a href="#troubleshooting">トラブルシューティング</a></li>
        <li><a href="#restriction">制限事項</a></li>
        <li><a href="#reference">リファレンス</a></li>
        <li><a href="#internal">内部情報</a></li>
        <li><a href="#release">リリースノート</a></li>
      </ul>
    </div>

    <div class="header_small" align="center">
    [<a href="pgpool-en.html">English page</a>]
    </div>
</div>

<div id="manual">

<!-- ================================================================================ -->

<h1>pgpool-IIとは<a name="whatis"></a></h1>
<p>
pgpool-IIはPostgreSQL専用のミドルウェアで、PostgreSQLのデータベースクライアントと
PostgreSQLサーバの間に割り込む形で動作し、PostgrSQLに以下のような機能を追加します。
</p>

<ul>
    <li>コネクションプーリング
    <p>
    PostgreSQLへの接続を保存しておき、同じ属性(ユーザ名、データベース、プロトコルバージョン)を持つ接続を
    受け付けたときに再利用することによって
    PostgreSQLへの接続オーバヘッドを低減し、システム全体のスループットを向上することができます。
    </p>
    </li>

    <li>レプリケーション
    <p>
    pgpool-IIは複数のPostgreSQLサーバを管理することができます。レプリケーション機能を使用することにより、
    物理的に2台以上のDBサーバにリアルタイムでデータを保存することができ、
    万が一どれかのDBサーバに障害が発生しても運用を継続することができます。
    </p>
    </li>

    <li>負荷分散
    <p>
    レプリケーションまたマスタースレーブモードで運用している場合、どのサーバに問い合わせても同じ結果が返ってきます。
    多数の検索リクエストをそれぞれのサーバで分担して負荷を軽減させ、システム全体の性能を向上させることができます。
    最良の場合にはサーバ台数に比例した性能向上が見込めます。
    </p>
    <p>
    特に多数のユーザが大量の問い合わせを投げるような環境で威力を発揮します。
    </p>
    </li>

    <li>接続数の制限
    <p>
    PostgreSQLに接続可能なセッション数には上限があり、それを超えて接続することはできません。
    かと言って、同時セッション数をむやみに多くすると、メモリーなどのリソースが多く消費されて
    パフォーマンスに影響があります。
    </p>
    <p>
    pgpool-IIでもクライアントからの接続数には上限がありますが、それを超えてもただちにエラーになることはなく、
    一定の間待たされるようになっています。
    したがって、pgpool-IIはPostgreSQLへの接続要求を実質的にキューイングし、
    PostgreSQLへの過大な接続数を制限することが可能です。
    </p>
    </li>

    <li>パラレルクエリ
    <p>
    複数のサーバにデータを分割して受け持たせ、それぞれのサーバに同時に検索問い合わせを投げて、
    問い合わせの処理時間を短縮するパラレルクエリが利用できます。
    特に大規模なデータベースに対して検索を実行するときに威力を発揮します。
    </p>
    </li>

</ul>

<p>
pgpool-IIはPostgreSQLバックエンドとフロントエンドの通信プロトコルを理解してその間を中継します。
すなわち、PostgreSQLのデータベースアプリケーションからはPostgreSQLサーバに、
PostgreSQLからはデータベースアプリケーションに見えるように設計されています。
</p>
<p>
そのため、PostgreSQLそのものはもちろん、アプリケーションの開発言語によらず、
PostgreSQLのデータベースアプリケーションにほとんど手を加えることなく、
pgpool-IIの機能が利用できます。
</p>
<p><strong>一部のSQLには<a href="#restriction">制限事項</a>があります。</strong></p>

<!-- ================================================================================ -->

<h1>pgpool-IIの稼働環境<a name="platform"></a></h1>
<p>
pgpool-IIは、Linuxをはじめ、SolarisやFreeBSDなどのほとんどのUNIX環境で動作します。Windowsでは動きません。
</p>
<p>
対応するPostgreSQLのバージョンは、PostgreSQLの6.4以降です。
ただしパラレルクエリモードを使用するときはPostgreSQL 7.4以降をお使いください。
また、PostgreSQL 7.4より前のバージョンでは、使用できる機能に制限事項があります。
もっとも、そのような古いバージョンのPostgreSQLはそもそも使うべきではありません。
</p>
<p>
pgpool-II配下で利用するPostgreSQLサーバのメジャーバージョンは一致していなければなりません。
また、オンラインリカバリ機能を利用するときは、OSやハードウェアアーキテクチャを同じものにしなければなりません。
</p>

<!-- ================================================================================ -->

<h1>pgpool-IIのインストール<a name="install"></a></h1>

<p>
Linux用のRPMパッケージは、CentOS、RedHat Enterprise Linux、Fedora、Debian用などが提供されています。
該当リポジトリをチェックしてみてください。
</p>

<p>
pgpool-II のソースコードは<a href="http://pgpool.net/mediawiki/index.php/Downloads">pgpool開発ページ</a> から
ダウンロードできます。
</p>

<p>
pgpool-IIのソースコードからのインストールには、gcc 2.9以上、およびGNU makeが必要です。
また、pgpool-IIはlibpq(PostgreSQL付属のクライアントライブラリ)を使用するので、
ビルドを行うマシン上にlibpqがインストールされていることが必要です。
また、OpenSSLサポートを有効にする場合は、OpenSSLライブラリと開発用のヘッダーファイルが必要です。
</p>

<dl>
<dt>configureの実行</dt>
    <dd>
    ソースコードのtar ballを展開したら、configureを実行します。
<pre>
./configure
</pre>
    configureに指定できるオプションは以下です。
    <ul>
        <li><code>--prefix=path</code><br/>
        pgpool-II本体や関連ファイルをインストールするトップディレクトリを指定します。
        デフォルトは/usr/localです。
        </li>
        <li><code>--with-pgsql=path</code><br/>
        PostgreSQLのクライアントライブラリなどがインストールされているトップディレクトリを指定します。
        デフォルトは<code>pg_config</code>コマンドで取得できるパスです。
        </li>
        <li><code>--with-openssl</code><br/>
        pgpool-IIをOpenSSLサポート付で作成します。
        デフォルトではOpenSSLサポートは無効です。
        </li>
        <li><code>--enable-sequence-lock</code><br/>
        pgpool-II 3.0シリーズ(3.0.4まで)互換のinsert_lockを使用します。
        pgpool-IIは、シーケンステーブルの行に対してロックを行います。
        これは、2011年06月より後にリリースされたPostgreSQL 8.2以降では使用できません。
        </li>
        <li><code>--enable-table-lock</code><br/>
        pgpool-II 2.2と2.3シリーズ互換のinsert_lockを使用します。
        pgpool-IIは、挿入対象のテーブルに対してロックを行います。
        これは、ロックがVACUUMと競合するため非推奨です。
        </li>
    </ul>
    </dd>

<dt>makeの実行</dt>
    <dd>
<pre>
make
make install
</pre>
    </dd>

<dt>pgpool_regclassのインストール</dt>
    <dd>
    <p>
    PostgreSQL 8.0以降を使用している場合は、pgpool-IIが内部で使用するC関数pgpool_regclassをインストールします。
    この関数がインストールされていなくてもpgpool-IIは動作しますが、違うスキーマで同じテーブル名を定義していて、
    SQL文の中でスキーマ名を省略している場合に、不具合が生じることがあります(一時テーブルを除く)。
    したがって、可能ならばpgpool_regclassをインストールすることをお勧めします。
    </p>
    <p>
    このインストールは、pgpool-IIがアクセスする予定のすべてのPostgreSQLサーバで実施してください。
    </p>
<pre>
cd pgpool-II-x.x.x/sql/pgpool-regclass
make
make install
psql -f pgpool-regclass.sql template1
</pre>

    <p>
    pgpool-regclass.sqlの実行は、pgpool-II経由で利用するデータベース毎に必要になります。
    ただし、"psql -f pgpool-regclass.sql template1"を実行後に作成されたデータベースでは
    自動的にpgpool-regclass.sqlの内容が反映されているので、新たにpgpool-regclass.sqlを実行する必要はありません。
    </p>
    </dd>

<dt>insert_lockテーブルの作成</dt>
<dd>
    <p>
    レプリケーションモードでinsert_lockを利用したい場合は、排他制御用のテーブル
    pgpool_catalog.insert_lockを作成します。
    insert_lockテーブルが存在しなくても今のところinsert_lockは動作しますが、
    その場合は、挿入対象のテーブルに対してロックが行われます。
    これはpgpool-II 2.2と2.3シリーズの動作と同じです。挿入対象のテーブルに対するロックは、
    VACUUMと競合してINSERT処理が長時間が待たされる可能性があります。
    <p>
    </p>
    したがって、insert_lockテーブルを作成することをお勧めします。
    テーブルの作成は、pgpool-IIがアクセスする予定のすべてのPostgreSQLサーバで実施してください。
    </p>

<pre>
cd pgpool-II-x.x.x/sql
psql -f insert_lock.sql template1
</pre>

    <p>
    insert_lock.sqlの実行は、pgpool-II経由で利用するデータベース毎に必要になります。
    ただし、&quot;psql -f insert_lock.sql template1&quot;を実行後に作成されたデータベースでは
    自動的にinsert_lock.sqlの内容が反映されているので、
    新たにinsert_lock.sqlを実行する必要はありません。
    </p>
    </dd>
</dl>

<p>
以上でインストールが完了します(GNU makeが必要なので、SolarisやFreeBSDなどでは
makeをgmakeに読み替えてください)。
</p>

<!-- ================================================================================ -->

<h1>pgpool-IIの設定<a name="config"></a></h1>
<p>
pgpool-IIの設定ファイルはデフォルトでは/usr/local/etc/pgpool.confおよび
/usr/local/etc/pcp.confです。pgpool-IIは動作モードによって使用できる機能と、
必要な設定項目が異なります。
</p>
<table border width="800">

<tr>
<th>使用できる機能/モード</th><th>rawモード(*3)</th><th>レプリケーションモード</th>
<th>マスタスレーブモード</th><th>パラレルクエリモード</th>
</tr>

<tr>
<td>コネクションプーリング</td><td align="center">×</td><td align="center">○</td>
<td align="center">○</td><td align="center">○</td>
</tr>

<tr>
<td>レプリケーション</td><td align="center">×</td><td align="center">○</td>
<td align="center">×</td><td align="center">△(*1)</td>
</tr>

<tr>
<td>負荷分散</td><td align="center">×</td><td align="center">○</td>
<td align="center">○</td><td align="center">△(*1)</td>
</tr>

<tr>
<td>フェイルオーバ</td><td align="center">○</td><td align="center">○</td>
<td align="center">○</td><td align="center">×</td>
</tr>

<tr>
<td>オンラインリカバリ</td><td align="center">×</td><td align="center">○</td>
<td align="center">△(*2)</td><td align="center">×</td>
</tr>

<tr>
<td>パラレルクエリ</td><td align="center">×</td><td align="center">×</td>
<td align="center">×</td><td align="center">○</td>
</tr>

<tr>
<td>サーバ台数</td><td align="center">1以上</td><td align="center">2以上</td>
<td align="center">2以上</td><td align="center">2以上</td>
</tr>

<tr>
<td>システムDB</td><td align="center">不要</td><td align="center">不要</td>
<td align="center">不要</td><td align="center">必要</td>
</tr>

</table>

<ul>
    <li>(*1)パラレルクエリモードでは、レプリケーションまたは負荷分散を有効にする必要があります。
        ただし、分割して保存しているテーブルに対しては、レプリケーションならびに負荷分散の機能は使用されません。
    </li>
    <li>(*2)マスタースレーブモードでは、Streaming Replicationと併用するときにのみ
        オンラインリカバリが可能です。
    </li>
    <li>(*3)単にpgpool-IIを経由して接続するだけのモードです。
        レプリケーションモードもマスタースレーブモードも有効にしていないときの動作です。
        PostgreSQLサーバへの接続セッション数を制限したり、2台以上のPostgreSQLサーバを用意して
        フェイルオーバ動作をさせたいときに利用します。
    </li>
</ul>

<!-- ================================================================================ -->

<h1 id="pcp_conf">pcp.confの設定</h1>
<p>
どの動作モードでも、pcp.confの設定は必要です。pgpool-IIには管理者がpgpool-IIの
停止や情報取得などの管理操作を行うためのインターフェイスが用意されています。
そのインターフェイスを利用するためにはユーザ認証が必要になるので、
そのユーザ名とパスワードをpcp.confに登録します。
pgpool-IIをインストールすると、$prefix/etc/pcp.conf.sampleができるので、それを
$prefix/etc/pcp.confという名前でコピーします。
</p>
<pre>
cp $prefix/etc/pcp.conf.sample $prefix/etc/pcp.conf
</pre>

<p>
pcp.confでは空白行や#で始まる行はコメントと見なされます。
ユーザとパスワードは、
</p>
<pre>
ユーザ名:[md5暗号化したパスワード]
</pre>

<p>
のように指定します。
[md5暗号化したパスワード]は、$prefix/bin/pg_md5コマンドで作成できます。
</p>
<pre>
./pg_md5 foo
acbd18db4cc2f85cedef654fccc4a4d8
</pre>

<p>
パスワードを引数に渡したくない場合は pg_md5 -p を実行してください。
</p>
<pre>
./pg_md5 -p
password: &lt;パスワードを入力&gt;
</pre>
<p>
pcp.confは、pgpool-IIを動作させるユーザIDで読み取り可能になっていなければ
なりません。
</p>

<!-- ================================================================================ -->

<h1 id="pgpool_conf">pgpool.confの設定</h1>
<h2 id="pgpool_conf_sample">サンプルファイル</h2>
<p>
pgpool-IIをインストールすると、インストール先ディレクトリ(デフォルトでは/usr/local)
/etc/pgpool.conf.sampleができるので、それを
インストール先ディレクトリ/etc/pgpool.confという名前でコピーします。
</p>
<pre>
cp インストール先ディレクトリ/etc/pgpool.conf.sample $prefix/etc/pgpool.conf
</pre>
<p>
また、各動作モード用のサンプルpgpool.confが用意されています。
こちらもご利用下さい。
</p>

<p>
<table border>
<tr><th>動作モード</th><th>サンプルファイル名</th></tr>
<tr><td>レプリケーションモード</td><td>pgpool.conf.sample-replication</td></tr>
<tr><td>マスタースレーブモード(Slony-I)</td><td>pgpool.conf.sample-master-slave</td></tr>
<tr><td>マスタースレーブモード(Streaming replication)</td><td>pgpool.conf.sample-stream</td></tr>
</table>

</p>

<h2>コメントの扱い</h2>
<p>
pgpool.confでは空白行や#で始まる行はコメントと見なされます。
</p>

<!-- ================================================================================ -->

<h1><a name="common"></a>共通設定項目</h1>
<p>
各動作モードで共通する設定項目を説明します。
</p>

<dl>
<dt><a name="LISTEN_ADDRESS"></a>listen_addresses</dt>
    <dd>
    <p>
    pgpool-IIがTCP/IPコネクションを受け付けるアドレスをホスト名またはIPアドレスで指定します。
    「*」を指定するとすべてのIPインタフェースからのコネクションを受け付けます。
    「''」を指定するとTCP/IPコネクションを受け付けません。デフォルト値は「localhost」です。
    UNIXドメインソケット経由のコネクションは常に受け付けます。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="PORT"></a>port</dt>
    <dd>
    <p>
    pgpool-IIがコネクションを受け付けるポート番号です。デフォルト値は9999
    です。
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="SOCKET_DIR"></a>socket_dir</dt>
    <dd>
    <p>
    pgpool-IIがコネクションを受け付けるUNIXドメインソケットを置くディレクトリです。
    デフォルト値は'/tmp'です。
    このソケットは、cronによって削除されることがあるので注意してください。
    <code>'/var/run'</code>などのディレクトリに変更することをお勧めします。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="PCP_PORT"></a>pcp_port</dt>
    <dd>
    <p>
    pcpが使用するポート番号です。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="PCP_SOCKET_DIR"></a>pcp_socket_dir</dt>
    <dd>
    <p>
    pcpがコネクションを受け付けるUNIXドメインソケットを置くディレクトリです。
    デフォルト値は'/tmp'です。
    このソケットは、cronによって削除されることがあるので注意してください。
    <code>'/var/run'</code>などのディレクトリに変更することをお勧めします。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="BACKEND_SOCKET_DIR"></a>backend_socket_dir</dt>
    <dd>
    <font color="red"><em>DEPRECATED</em></font><br>
    <p>
    このパラメータは、libpqのポリシーに合わせて削除されます。
    代わりにbackend_hostnameパラメータを使ってください。
    </p>
    <p>
    UNIXドメインソケット経由でpgpool-IIがPostgreSQLと接続する際に使用する
    PostgreSQLのUNIXドメインソケットが置かれているディレクトリです。デフォルト値は/tmpです。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="PCP_TIMEOUT"></a>pcp_timeout</dt>
    <dd>
    <p>
    pcpがpgppoolと接続する際のタイムアウト値。0にするとタイムアウトしません。
    デフォルト値は10(秒)です。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="NUM_INIT_CHILDREN"></a>num_init_children</dt>
    <dd>
    <p>
    preforkするpgpool-IIのサーバプロセスの数です。デフォルト値は32になっています。
    これが、pgpool-IIに対してクライアントが同時に接続できる上限の数になります。
    これを超えた場合は、そのクライアントは、pgpool-IIのどれからのプロセスへのフロントエンドの接続が終了するまで
    待たされます(PostgreSQLと違ってエラーになりません)。
    待たされる数の上限は、2 * num_init_children です。
    基本的に後述のmax_pool * num_init_children分だけPostgreSQLへのコネクションが張られますが、
    他に以下の考慮が必要です。
    </p>
    <ul>
        <li>問い合わせのキャンセルを行うと通常のコネクションとは別に新たなコネクションが張られます。
            したがって、すべてのコネクションが使用中の場合は問い合わせのキャンセルができなくなってしまうので、
            ご注意下さい。
            問い合わせのキャンセルを必ず保証したい場合は、想定されるコネクション数の倍の値を
            設定することをおすすめします。
        </li>
        <li>一般ユーザでPostgreSQLに接続できるのは、
            max_connections - superuser_reserved_connections 分だけです。
        </li>
    </ul>
    <p>
    以上をまとめると、
    </p>
<pre>
max_pool * num_init_children &lt;= (max_connections - superuser_reserved_connections) (クエリのキャンセルを考慮しない場合)
max_pool * num_init_children * 2 &lt;= (max_connections - superuser_reserved_connections) (クエリのキャンセルを考慮する場合)
</pre>
    <p>
    のどちらかを満たすように設定してください。
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="CHILD_LIFE_TIME"></a>child_life_time</dt>
    <dd>
    <p>
    pgpool-IIの子プロセスの寿命です。アイドル状態になってから
    child_life_time秒経過すると、一旦終了して新しいプロセスを起動します。
    メモリーリークその他の障害に備えた予防措置です。
    child_life_timeのデフォルト値は300秒、すなわち5分です。
    0を指定するとこの機能は働きません（すなわち起動しっ放し）。
    なお、まだ一度もコネクションを受け付けていないプロセスにはchild_life_timeは適用されません。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="CHILD_MAX_CONNECTIONS"></a>child_max_connections</dt>
    <dd>
    <p>
    各pgpool-II子プロセスへの接続回数がこの設定値を超えると、その子プロセスを終了します。
    child_life_timeやconnection_life_timeが効かないくらい忙しいサーバで、
    PostgreSQLバックエンドが肥大化するのを防ぐのに有効です。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="CLIENT_IDLE_LIMIT"></a>client_idle_limit</dt>
    <dd>
    <p>
    前回クライアントから来たクエリから、client_idle_limit 秒越えても次の
    クエリが届かない場合は、クライアントへの接続を強制的に切断し、
    クライアントからの次のコネクションを待つようにします。
    この設定は、だらしないクライアントプログラムや、クライアントとpgpoolの間の
    TCP/IPコネクションが不調なことによって、
    pgpoolの子プロセスが占有されてしまう問題を回避するのに役立ちます。
    デフォルト値は 0(無効)です。このパラメータは、オンラインリカバリのセカンドステージでは無視されます。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="AUTHENTICATION_TIMEOUT"></a>authentication_timeout</dt>
    <dd>
    <p>
    認証処理のタイムアウト時間を秒単位で指定します。0 を指定するとタイムアウトを無効にします。
    authentication_timeout のデフォルト値は60です。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="LOGDIR"></a>logdir</dt>
    <dd>
    <p>
    このディレクトリ下に、pgpool-IIのDBノードの状態を記録するpgpool_statusファイルが書かれます。
    </p>
    </dd>

<dt><a name="LOG_DESTINATION"></a>log_destination</dt>
    <dd>
    <p>
    pgpool-IIは、stderrかsyslogのどちらかにログを書くことができます。デフォルトはstderrです。
    </p>
    <p>
    注意:syslogを使う場合は、syslogデーモンの設定を変更する必要があります。
    </p>
    <p>
    pgpool-IIは、syslog ファシリティ LOCAL0 から LOCAL7 までにログを書くことができます
    (syslog_facilityをご覧ください)。
    しかし、ほとんどのデフォルトのsyslog設定は、そのようなメッセージを廃棄してしまいます。
    そこで、syslogデーモンの以下のような設定が必要になります。
    </p>
<pre>
local0.*    /var/log/pgpool.log
</pre>
    </dd>

  <dt><a name="SYSLOG_FACILITY"></a>syslog_facility</dt>
    <dd>
    <p>
    syslogが有効な場合、このパラメータによってsyslogの「ファシリティ」を設定します。
    LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7から選択します。
    デフォルトは LOCAL0 です。
    併せてsyslogデーモンのドキュメントもご覧ください。
    </p>
    </dd>

<dt><a name="SYSLOG_IDENT"></a>syslog_ident</dt>
    <dd>
    <p>
    syslogが有効な場合、このパラメータによってsyslogのメッセージにあらわれるプログラム名を設定します。
    デフォルトは"pgpool"です。
    </p>
    </dd>

<dt><a name="PID_FILE_NAME"></a>pid_file_name</dt>
    <dd>
    <p>
    pgpool-IIのpid file(プロセスIDを格納したファイル)のフルパス名です。
    デフォルト値は'/var/run/pgpool/pgpool.pid'です。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="PRINT_TIMESTAMP"></a>print_timestamp</dt>
    <dd>
    <p>
    trueならばpgpool-IIのログにタイムスタンプを追加します。デフォルトはtrueです。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="CONNECTION_CACHE"></a>connection_cache</dt>
    <dd>
    <p>
    trueならPostgreSQLへのコネクションをキャッシュします。デフォルトはtrueです。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="HEALTH_CHECK_TIMEOUT"></a>health_check_timeout</dt>
    <dd>
    <p>
    pgpool-IIはサーバ障害やネットワーク障害を検知するために、定期的にバックエンドに接続を試みます。
    これを「ヘルスチェック」と言います。障害が検知されると、フェイルオーバや縮退運転を試みます。
    </p>
    <p>
    この パラメータは、ネットワークケーブルが抜けた際などにヘルスチェックが長時間待たされるのを防ぐための
    タイムアウト値を秒単位で指定します。
    デフォルトは20秒です。0を指定するとタイムアウト処理をしません
    (すなわち TCP/IP のタイムアウトまで待つことになります)。
    </p>
    <p>
    なお、ヘルスチェックを有効にすると、ヘルスチェックのための余分の接続が1つ必要になりますので、
    PostgreSQLのpostgresql.confの設定項目のmax_connectionsを少くとも1増やすようにしてください。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="HEALTH_CHECK_PERIOD"></a>health_check_period</dt>
    <dd>
    <p>
    ヘルスチェックを行う間隔を秒単位で指定します。0を指定するとヘルスチェックを行いません。
    デフォルトは0です(つまりヘルスチェックを行いません)。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
</p>
</dd>

<dt><a name="HEALTH_CHECK_USER"></a>health_check_user</dt>
    <dd>
    <p>
    ヘルスチェックを行うためのPostgreSQLユーザ名です。
    このユーザ名はPostgreSQLに登録済みでなければなりません。
    さもないと、ヘルスチェックがエラーとなります。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="HEALTH_CHECK_PASSWORD"></a>health_check_password</dt>
    <dd>
    <p>
    ヘルスチェックを行うためのPostgreSQLパスワードです。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="HEALTH_CHECK_MAX_RETRIES"></a>health_check_max_retries</dt>
    <dd>
    <p>
    ヘルスチェックに失敗した後(したがってフェイルオーバする前に)リトライする回数を指定します。
    この設定は動作にむらのあるネットワーク環境において、マスタが正常であるにも関わらず
    たまにヘルスチェックが失敗することが予想される場合に有用です。
    デフォルト値は0で、この場合はリトライをしません。
    この設定を有効にする場合は、併せて<a href="#FAIL_OVER_ON_BACKEND_ERROR">fail_over_on_backend_error</a>を
    offにすることをお勧めします。
    </p>
    <p>
    health_check_max_retriesを変更した場合は、pgpool.confの再読込が必要です。
    </p>
    </dd>

<dt><a name="HEALTH_CHECK_RETRY_DELAY"></a>health_check_retry_delay</dt>
    <dd>
    <p>
    ヘルスチェックのリトライの間の秒数を指定します(health_check_max_retries &gt; 0でなければ有効になりません)。
    0を指定すると、待ちなしに直ちにリトライします。
    </p>
    <p>
    <a href="#HEALTH_CHECK_RETRY_DELAY">health_check_retry_delay</a>を変更した場合は、pgpool.confの再読込が必要です。
    </p>
    </dd>

<dt><a name="FAILOVER_COMMAND"></a>failover_command</dt>
    <dd>
    <p>
    ノードが切り離された時に実行するコマンドを指定します。特殊文字を指定すると、
    pgpool が必要な情報に置き換えてコマンドを実行します。
    </p>

    <center>
    <table border>
    <tr><td>文字</td><td>意味</td></tr>
    <tr><td>%d</td><td>切り離されたノード番号</td></tr>
    <tr><td>%h</td><td>切り離されたノードのホスト名</td></tr>
    <tr><td>%H</td><td>新しいマスターのホスト名</td></tr>
    <tr><td>%p</td><td>切り離されたノードのポート番号</td></tr>
    <tr><td>%D</td><td>切り離されたノードのデータベースクラスタパス
    </td></tr>
    <tr><td>%M</td><td>古いマスターのノード番号</td></tr>
    <tr><td>%m</td><td>新しいマスターのノード番号</td></tr>
    <tr><td>%P</td><td>古いプライマリノード番号</td></tr>
    <tr><td>%%</td><td>'%'文字</td></tr>
    </table>
    </center>

    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    <p>
    フェイルオーバー時には、pgpoolはまず子プロセスを切断します(結果として、すべてのセッションが切断されます)。
    次に、pgpoolはフェイルオーバコマンドを実行し、その完了を待ちます。
    そのあとで新しいpgpoolの子プロセスが起動され、クライアントからの接続を受け付けられる状態になります。
    </p>
    </dd>

<dt><a name="FAILBACK_COMMAND"></a>failback_command</dt>
    <dd>
    <p>
    ノードが復帰した時に実行するコマンドを指定します。特殊文字を指定すると、
    pgpool が必要な情報に置き換えてコマンドを実行します。
    </p>

    <center>
    <table border>
    <tr><td>文字</td><td>意味</td></tr>
    <tr><td>%d</td><td>復帰したノード番号</td></tr>
    <tr><td>%h</td><td>復帰したノードのホスト名</td></tr>
    <tr><td>%p</td><td>復帰したノードのポート番号</td></tr>
    <tr><td>%D</td><td>復帰したノードのデータベースクラスタパス
    </td></tr>
    <tr><td>%M</td><td>古いマスターのノード番号</td></tr>
    <tr><td>%m</td><td>新しいマスターのノード番号</td></tr>
    <tr><td>%H</td><td>新しいマスターのホスト名</td></tr>
    <tr><td>%P</td><td>古いプライマリノード番号</td></tr>
    <tr><td>%%</td><td>'%'文字</td></tr>
    </table>
    </center>

    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="FOLLOW_MASTER_COMMAND"></a>follow_master_command</dt>
    <dd>
    <p>
    マスターノードのフェイルオーバー後に実行するコマンドを指定します。
    これは、マスタースレーブモードでストリーミングレプリケーション構成の場合のみ有効です。
    特殊文字を指定すると、pgpool が必要な情報に置き換えてコマンドを実行します。
    </p>

    <center>
    <table border>
    <tr><td>文字</td><td>意味</td></tr>
    <tr><td>%d</td><td>切り離されたノード番号</td></tr>
    <tr><td>%h</td><td>切り離されたノードのホスト名</td></tr>
    <tr><td>%p</td><td>切り離されたノードのポート番号</td></tr>
    <tr><td>%D</td><td>切り離されたノードのデータベースクラスタパス</td></tr>
    <tr><td>%M</td><td>古いマスターのノード番号</td></tr>
    <tr><td>%m</td><td>新しいマスターのノード番号</td></tr>
    <tr><td>%H</td><td>新しいマスターのホスト名</td></tr>
    <tr><td>%P</td><td>古いプライマリノード番号</td></tr>
    <tr><td>%%</td><td>'%'文字</td></tr>
    </table>
    </center>

    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>

    <p>
    空文字列以外を指定すると、マスターノードのフェイルオーバー後に新しいマスター以外のすべてのノードは切り離され、
    クライアントから再び接続を受け付けるために子プロセスの再起動が行われます。
    その後、切り離されたそれぞれのノードに対してfollow_master_commandに指定したコマンドが実行されます。
    通常は、ここにpcp_recovery_nodeコマンドを組み込んだシェルスクリプトなどを指定し、
    新しいマスターからスレーブをリカバリするために使用します。
    </p>
    </dd>

<dt><a name="FAIL_OVER_ON_BACKEND_ERROR"></a>fail_over_on_backend_error</dt>
    <dd>
    <p>
    trueならば、バックエンドのソケットへからの読み出し、書き込みに失敗するとフェイルオーバします。
    falseにすると、フェイルオーバせず、単にエラーがレポートされてセッションが切断されます。
    このパラメータをfalseにする場合には、health checkを有効にすることをお勧めします。
    なお、このパラメータがfalseの場合でも、バックエンドがシャットダウンされたことを
    pgpool-IIが検知した場合にはフェイルオーバが起きることに注意してください。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="IGNORE_LEADING_WHITE_SPACE"></a>ignore_leading_white_space</dt>
    <dd>
    <p>
    trueならば、load balanceの際にSQL文行頭の空白を無視します(全角スペースは無視されません)。
    これは、DBI/DBD:Pgのように、勝手に行頭にホワイトスペースを追加するようなAPIを使い、
    ロードバランスしたいときに有効です。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="LOG_STATEMENT"></a>log_statement</dt>
    <dd>
    <p>
    trueならばSQL文をログ出力します。この役目はPostgreSQLのlog_statementオプションと似ていて、
    デバッグオプションがないときでも問い合わせをログ出力して調べることができるので便利です。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="LOG_PER_NODE_STATEMENT"></a>log_per_node_statement</dt>
    <dd>
    <p>
    <a href="#LOG_STATEMENT">log_statement</a>と似ていますが、DBノード単位でログが出力されるので、
    レプリケーションや負荷分散の確認が容易です。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="LOG_HOSTNAME"></a>log_hostname</dt>
    <dd>
    <p>
    trueならば、psコマンドでの状態表示時にIPアドレスではなく、ホスト名を表示します。
    また、<a href="#LOG_CONNECTIONS">log_connections</a>が有効な場合にはログにホスト名を出力します。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>

<dt><a name="LOG_CONNECTIONS"></a>log_connections</dt>
    <dd>
    <p>
    trueならば、全てのクライアント接続をログへ出力します。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="ENABLE_POOL_HBA"></a>enable_pool_hba</dt>
    <dd>
    <p>
    trueならば、pool_hba.confに従ってクライアント認証を行います。
    詳細は<a href="#hba">クライアント認証(HBA)のためのpool_hba.conf設定方法</a>を参照してください。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="BACKEND_HOSTNAME"></a>backend_hostname</dt>
    <dd>
    <p>
    使用するPostgreSQLサーバのホスト名を指定します。
    pgpool-IIは、このホスト名を使ってPostgreSQLと通信します。
    </p>
    <p>
    TCP/IPを使用する場合、ホスト名またはIPアドレスを指定できます。
    "/"で始まる文字列を指定すると、TCP/IPではなく、UNIXドメインソケットを使用され、
    ディレクトリ名とみなしてそこにソケットファイルが作成されることになります。
    空文字(<code>''</code>)を指定すると、<code>/tmp</code>下に作成したUNIXドメインソケットで接続します。
    </p>
    <p>
    実際には、"backend_hostname"の後に0, 1, 2...と数字を付加して使用する複数
    のPostgreSQLを区別します(たとえば<code>backend_hostname0</code>)。
    この数字のことを「DBノードID」と呼び、0から開始します。
    DBノードID == 0のPostgreSQLは、特別に「マスターDB」と呼ばれます。
    複数のDBノードを運用している場合、条件によってはマスターDBがダウンしても運用を続けることができます。
    この場合は、稼働中かつDBノードIDがもっとも若いものが新しいマスターDBになります。
    </p>
    <p>
    ただし、ストリーミングレプリケーションモードで運用している場合は、
    DBノードIDが0のノードには特別な意味はなく、プライマリノードかどうかが問題になります。
    詳細は<a href="#stream">Streaming Replicationへの対応</a>をご覧ください。
    <p>
    1台しかPostgreSQLを使用しない場合は、"backend_hostname0"としてください。
    </p>
    <p>
    backend_hostname は新しく追加した行を設定ファイル再読み込みで追加することができます。
    すでにある情報を途中で変更することはできません。
    変更する場合には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="BACKEND_PORT"></a>backend_port</dt>
    <dd>
    <p>
    使用するPostgreSQLサーバのポート番号を指定します。
    実際には、"backend_port"の後に0, 1, 2...とDBノードIDを付加して使用する複数のPostgreSQLを区別します。
    1台しかPostgreSQLを使用しない場合は、"backend_port0"としてください。
    </p>
    <p>
    backend_port は新しく追加した行を設定ファイル再読み込みで追加することができます。
    すでにある情報を途中で変更することはできません。変更する場合には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="BACKEND_WEIGHT"></a>backend_weight</dt>
    <dd>
    <p>
    使用するPostgreSQLサーバに対する負荷分散の比率を0以上の整数または浮動小数点で指定します。
    "backend_weight"の後には、DBノードIDを付加して使用する複数のPostgreSQLを区別します。
    1台しかPostgreSQLを使用しない場合は、"backend_weight0"としてください。
    負荷分散を使用しない場合は、「1」を設定してください。
    </p>
    <p>
    backend_weight は新しく追加した行を設定ファイル再読み込みで追加することができます。
    pgpool-II 2.2.6/2.3以降では、設定ファイルの再読込でbackend_weight値を変更できます。
    新しく接続したクライアントセッションから、この新しいweight値が反映されます。
    マスタースレーブモードにおいて、あるスレーブに対して管理業務を実施する都合上、
    問い合わせがそのスレーブに送られるのを防ぎたい場合に有用です。
    </p>
    </dd>

<dt><a name="BACKEND_DATA_DIRECTORY"></a>backend_data_directory</dt>
    <dd>
    <p>
    使用する PostgreSQL サーバのデータベースクラスタのパスを指定します。
    実際には、"backend_data_directory"の後にDBノードIDを付加して使用する複数のPostgreSQLを区別します。
    このパラメータはオンラインリカバリの際に使用します。
    オンラインリカバリを使用しない場合には設定する必要はありません。
    </p>
    <p>
    backend_data_directory は新しく追加した行を設定ファイル再読み込みで追加することができます。
    すでにある情報を途中で変更することはできません。変更する場合には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="BACKEND_FLAG"></a>backend_flag</dt>
    <dd>
    <p>
    バックエンド単位での様々な挙動を制御するフラグです。
    実際には、"backend_flag"の後に数字を付けて、どのバックエンドのフラグか指定します。
    </p>
    <p>
    例: <code>backend_flag0</code>
    </p>
    <p>
    複数のフラグを"|"で連結して指定することができます。
    現在以下のものがあります。
    </p>

    <dl>
    <dt>ALLOW_TO_FAILOVER</dt>
        <dd>
        フェイルオーバやデタッチが可能になります。これがデフォルトの動作です。
        DISALLOW_TO_FAILOVERと同時には指定できません。
        </dd>
    <dt>DISALLOW_TO_FAILOVER</dt>
        <dd>
        フェイルオーバやデタッチが行われません。
        HheartbeatやPacemakerなどのHA(High Availability)ソフトでバックエンドを二重化しているなどの事情で、
        pgpool-II側でフェイルオーバの制御をして欲しくないときなどに指定します。
        ALLOW_TO_FAILOVERと同時には指定できません。
        </dd>
    </dl>

    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="SSL">ssl</a></dt>
    <dd>
    <p>
    trueならばpgpool-IIとフロントエンド、pgpool-IIとバックエンドの間のSSL接続が可能になります。
    なお、pgpool-IIとフロントエンドの接続にSSLが利用できるためには、
    <code>ssl_key</code>と<code>ssl_cert</code>が設定されてなければなりません。
    </p>
    <p>
    デフォルトではSSLサポートはオフになっています。
    SSLサポートを有効にするためには、configure時にOpenSSLサポートを有効にする必要があります。
    詳細は<a href="#install">インストール</a>の項目をご覧下さい。
    </p>
    <p>
    sslを有効に設定したら、pgpoolの再起動をしてください。
    </p>
    </dd>

<dt><a name="SSL_KEY"></a>ssl_key</dt>
    <dd>
    <p>
    フロントエンドとの接続に使用するプライベートキーファイルのフルパスを指定します。
    </p>
    <p>
    ssl_keyのデフォルト値はありません。
    ssl_keyの設定がない場合は、フロントエンドとの接続でSSLが使用されなくなります。
    </p>
    </dd>

    <dt><a name="SSL_CERT"></a>ssl_cert</dt>
    <dd>
    <p>
    フロントエンドとの接続に使用する公開x509証明書のフルパスを指定します。
    </p>
    <p>
    ssl_certのデフォルト値はありません。
    ssl_certの設定がない場合は、フロントエンドとの接続でSSLが使用されなくなります。
    </p>
    </dd>

<dt><a name="DEBUG_LEVEL"></a>debug_level</dt>
    <dd>
    <p>
    デバッグメッセージの詳細レベル。0でデバッグメッセージの出力なし。
    1以上でデバッグメッセージを出力します。
    数字が大きければより詳細なメッセージが出力されるようになります
    (3.0では今のところメッセージの詳細度は変りません)。
    デフォルト値は0です。
    </p>
    </dd>

<dt><a name="RELCACHE_EXPIRE"></a>relcache_expire</dt>
    <dd>
    <p>
    リレーションキャッシュの寿命を秒単位で指定します。
    0を指定すると、キャッシュの寿命の管理は行わず、プロセスが生きているか、
    キャッシュが溢れるまでは有効になります(デフォルトの動作)。
    </p>
    <p>
    リレーションキャッシュは、PostgreSQLのシステムカタログに対する問い合わせを保存しておくものです。
    問い合わせる内容は、テーブルの構造、テーブルが一時テーブルかどうかなどがあります。
    キャッシュはpgpoolの子プロセスのローカルメモりに保管されています。
    <p>
    もしALTER TABLEが発行されると、テーブルの構造が変わる場合があり、
    リレーションキャッシュの内容と一致しなくなる恐れがあります。
    relcache_expireにより、その危険性をコントロールできるようになります。
    </p>
    </dd>

</dl>

<h2>SSL証明書の生成</h2>
<p>
証明書の扱いについてはこのマニュアルの範囲外です。
PostgreSQLドキュメント<a href="http://www.postgresql.jp/document/pg842doc/html/ssl-tcp.html">
SSLによる安全なTCP/IP接続</a>の章に自分で認証する証明書を作成するコマンドの例があります。
</p>

<h2 id="failover_in_raw_mode">rawモードにおけるフェイルオーバ動作について</h2>
<p>
rawモードにおいて、2台以上のPostgreSQLサーバを指定すると、フェイルオーバが可能です。
フェイルオーバでは、正常時にはbackend_hostname0で指定したPostgreSQLのみを使用し、
ほかのサーバにはアクセスしません。
backend_hostname0のサーバがダウンすると、次にbackend_hostname1で指定したサーバにアクセスをこころみ、
成功すればそれを使用します。以下、backend_hostname2...でも同様になります。
</p>

<!-- ================================================================================ -->

<h1><a name="connection_pool_mode"></a>コネクションプールモード</h1>
<p>
rawモードに加え、コネクションプーリングが利用できるようになります。
コネクションプールモードを有効にするには、 <a href="#CONNECTION_CACHE">connection_cache</a> をonにします。
以下の設定項目がコネクションプールの動作に影響を与えます。
</p>

<dl>
<dt><a name="MAX_POOL"></a>max_pool</dt>
<dd>
    <p>
    pgpool-IIの各サーバプロセスがキープするPostgreSQLへの最大コネクション数です。
    pgpool-IIは、ユーザ名、データベースが同じならばコネクションを再利用しますが、
    そうでなければ新たにPostgreSQLへのコネクションを確立しようとします。
    したがって、ここでは想定される[ユーザ名:データベース名]のペアの種類の数だけを
    max_poolに指定しておく必要があります。
    もしmax_poolを使いきってしまった場合は一番古いコネクションを切断し、
    そのスロットが再利用されます。
    </p>
    <p>
    max_poolのデフォルト値は4です。
    </p>
    <p>
    なお、pgpool-II全体としては、<a href="#NUM_INIT_CHILDREN">num_init_children</a> *
    <a href="#MAX_POOL">max_pool</a> 分だけ
    PostgreSQLへのコネクションが張られる点に注意してください。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="CONNECTION_LIFE_TIME"></a>connection_life_time</dt>
    <dd>
    <p>
    コネクションプール中のコネクションの有効期間を秒単位で指定します。
    0を指定すると有効期間は無限になります。
    connection_life_timeのデフォルト値は0です。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="RESET_QUERY_LIST"></a>reset_query_list</dt>
    <dd>
    <p>
    セッションが終了するときにコネクションを初期化するためのSQLコマンドを「;」で区切って列挙します。
    デフォルトは以下のようになっていますが、任意のSQL文を追加しても構いません。
<pre>
reset_query_list = 'ABORT; DISCARD ALL'
</pre>

    <p>
    PostgreSQLのバージョンによって使用できるSQLコマンドが違います。
    各バージョンごとのお勧め設定は以下です(ただし、"ABORT"は必ずコマンドに含めてください)。
    </p>

    <table border>
    <tr><th>PostgreSQLバージョン</th><th>reset_query_listの推奨設定値</th></tr>
    <tr><td>7.1以前</td><td>ABORT</td></tr>
    <tr><td>7.2から8.2</td><td>ABORT; RESET ALL; SET SESSION AUTHORIZATION DEFAULT</td></tr>
    <tr><td>8.3以降</td><td>ABORT; DISCARD ALL</td></tr>
    </table>

    <ul>
    <li>「ABORT」は、PostgreSQL 7.4以上ではトランザクションブロックの中にいない場合には発行されません。</li>
    </ul>

    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

</dl>

<h2 id="failover_in_cp_mode">コネクションプールモードにおけるフェイルオーバ動作について</h2>
<p>
rawモードと同様の動作をします。
</p>

<!-- ================================================================================ -->

<h1><a name="replication_mode"></a>レプリケーションモード</h1>
<p>
レプリケーションを有効にするモードです(設定ファイルの雛形はpgpool.conf-replication)。
rawモード、コネクションプールモードに加え、以下を設定します。
</p>

<dl>
<dt><a name="REPLICATION_MODE"></a>replication_mode</dt>
    <dd>
    <p>
    レプリケーションモードで動作させる場合はtrueを指定してください。デフォルト値はfalseです。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="LOAD_BALANCE_MODE"></a>load_balance_mode</dt>
    <dd>
    <p>
    trueを指定するとレプリケーションモードまたはマスタースレーブモードの際に、
    SELECT文をロードバランスして検索性能を向上させることができます。デフォルト値はfalseです。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="REPLICATION_STOP_ON_MISMATCH"></a>replication_stop_on_mismatch</dt>
    <dd>
    <p>
    各DBノードから送られてくるパケットの種類が不一致になった場合に、DBノードを切り放して縮退運転に入ります。
    </p>
    <p>
    良くあるケースとしては、replicate_selectが指定されていてSELECTが各DBノードで実行されているときに、
    検索結果行数が一致しないなど、があります(これに限定されるものではありません。
    たとえばあるDBノードでUPDATEが成功したのに、他のDBノードでは失敗した場合が一例です)。
    ただし、pgpoolはパケットの中身まではチェックしていないので、SELECT結果のデータ内容が異なっていても、
    縮退は起きないことに注意してください。
    </p>
    <p>
    縮退対象のDBノードは「多数決」で少数派になったものが対象になります。
    もし多数決で同票になった場合は、マスタDBノード(DBノード番号がもっともわかいもの)を含むグループが優先され、
    それ以外のグループに所属するDBノードが切り放しの対象になります。
    </p>
    <p>
    このオプションがfalseの場合は、該当のセッションを強制的に終了するだけに留めます。
    デフォルト値はfalseです。
    </p>

<dt><a name="FAILOVER_IF_AFFECTED_TUPLES_MISMATCH"></a>failover_if_affected_tuples_mismatch</dt>
    <dd>
    <p>
    各DBノードで実行されたINSERT/UPDATE/DELETEの結果行数が不一致になった場合に、
    DBノードを切り放して縮退運転に入ります。
    </p>
    <p>
    縮退対象のDBノードは「多数決」で少数派になったものが対象になります。
    もし多数決で同票になった場合は、マスタDBノード(DBノード番号がもっともわかいもの)を含むグループが優先され、
    それ以外のグループに所属するDBノードが切り放しの対象になります。
    </p>
    <p>
    このオプションがfalseの場合は、該当のセッションを強制的に終了するだけに留めます。
    デフォルト値はfalseです。
    </p>
    </dd>

<dt><a name="WHITE_FUNCTION_LIST"></a>white_function_list</dt>
    <dd>
    <p>
    データベースに対して<strong>更新を行なわない関数名</strong>をコンマ区切りで指定します。
    このリストに含まれない関数呼び出しを含むSELECTは、負荷分散の対象とはならず、
    レプリケーションモードにおいてはすべてのDBノードで実行されます。
    (マスタースレーブモードにおいては、マスター(primary)DBノードにのみ送信されます)。
    </p>
    <p>
    関数名には正規表現を使うことができます。
    たとえば、読み出しのみの関数が"get_"あるいは"select_"で始まるならば、以下のような指定が可能です。
    </p>
<pre>
white_function_list = 'get_.*,select_.*'
</pre>
    </dd>

<dt><a name="BLACK_FUNCTION_LIST"></a>black_function_list</dt>
    <dd>
    <p>
    データベースに対して<strong>更新を行なう関数名</strong>をコンマ区切りで指定します。
    このリストに含まれる関数呼び出しを含むSELECTは、負荷分散の対象とはならず、
    レプリケーションモードにおいてはすべてのDBノードで実行されます。
    このリストに含まれない関数呼び出しを含むSELECTは、負荷分散の対象となります。
    </p>
    <p>
    関数名には正規表現を使うことができます。
    たとえば、読み出しのみの関数が"set_"、"update_"、"delete_"あるいは"insert_"で始まるならば、
    以下のような指定が可能です。
    </p>
<pre>
black_function_list = 'nextval,setval,set_.*,update_.*,delete_.*,insert_.*'
</pre>

    <p>
    white_function_listとblack_function_listの両方を空以外にすることはできません。
    どちらか一方のみに関数名を指定します。
    </p>
    <p>
    pgpool-II 3.0より前のバージョンでは、固定でnextvalとsetvalが書き込みを行なう関数として認識されていました。
    それと同じ動作を行なわせるには、以下のようにwhite_function_listとblack_function_listを指定します。
    </p>
<pre>
white_function_list = ''
black_function_list = 'nextval,setval,lastval,currval'
</pre>

    <p>
    上の例では、nextvalとsetvalに加え、lastvalとcurrvalが追加されていることに注意してください。
    lastvalとcurrvalは書き込みを行う関数ではありませんが、これらの関数が負荷分散されることによって、
    エラーが発生するのを未然に防ぐことができます。
    black_function_listに含まれる関数は負荷分散されないからです。
    </p>
    </dd>

<dt><a name="REPLICATE_SELECT"></a>replicate_select</dt>
    <dd>
    <p>
    true を設定すると、レプリケーションモードでは SELECT 文をレプリケーションします。
    これは pgpool-II 1.0 までの挙動と同じになります。
    false を設定すると SELECT 文をマスタのみに送信します。デフォルト値は false です。
    </p>
    <p>
    replicate_select、<a href="#LOAD_BALANCE_MODE">load_balance_mode</a>、
    SELECT問合わせが明示的なトランザクションブロックの内側にあるかどうかどうかで、
    レプリケーションモードの動作が変化します。詳細を表に示します。
    </p>

    <table border>
    <tr>
    <td>SELECTが明示的なトランザクションブロックの内側にある</td>
    <td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td>
    </tr>

    <tr>
    <td>replicate_selectがtrue</td>
    <td>Y</td>
    <td>Y</td>
    <td>N</td>
    <td>N</td>
    <td>Y</td>
    <td>Y</td>
    <td>N</td>
    <td>N</td>
    </tr>

    <tr>
    <td>load_balance_modeがtrue</td>
    <td>Y</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>Y</td>
    </tr>

    <tr>
    <td>結果(R:レプリケーション, M: マスタのみに送信, L: ロードバランスされる)</td>
    <td>R</td><td>R</td><td>M</td><td>M</td><td>R</td><td>R</td><td>M</td><td>L</td>
    </tr>
    </table>
    </dd>

<dt><a name="INSERT_LOCK"></a>insert_lock</dt>
    <dd>
    <p>
    SERIAL型を使っているテーブルをレプリケーションすると、SERIAL型の列の値がDBノードの間で
    一致しなくなることがあります。
    この問題は、該当テーブルを明示的にロックすることで回避できます
    (もちろんトランザクションの並列実行性は犠牲になりますが)。
    しかし、そのためには、
    </p>
<pre>
INSERT INTO ...
</pre>

    <p>
    を
    </p>

<pre>
BEGIN;
LOCK TABLE ...
INSERT INTO ...
COMMIT;
</pre>

    <p>
    に書き換えなければなりません。
    insert_lockをtrueにすると自動的にトランザクションの開始、テーブルロック、トランザクションの終了を
    行ってくれるので、こうした手間を省くことができます
    （すでにトランザクションが開始されている場合はLOCK TABLE...だけが実行されます）。
    </p>
    <p>
    pgpool-II 2.2以降は、テーブルがSERIAL列を持つかどうか自動判別するため、
    SERIAL列がなければ決してテーブルをロックしません。
    </p>
    <p>
    pgpool-II 3.0.4までの3.0シリーズは、対応するシーケンステーブルに対して行ロックをかけることで
    排他制御を行ないます。
    それ以前のバージョンと比べると、VACUUM(autovacuumを含む)とのロック競合がなくなるメリットがあります。
    しかし、これは他の問題を引き起こします。
    トランザクション周回が起きた後、シーケンステーブルに対する行ロックはPostgreSQLの内部エラー
    (詳細には、トランザクション状態を保持するpg_clogへのアクセスエラー)を起こします。
    これを防ぐため、PostgreSQLのコア開発者はシーケンステーブルに対する行ロックを許可しないことを決定しました。
    これはもちろんpgpool-IIを動作不能にします(修正されたPostgreSQLはバージョン
    9.0.5, 8.4.9, 8.3.16そして8.2.22としてリリースされるでしょう)。
    </p>
    <p>
    pgpool-II 3.0.5以降では、新しいPostgreSQLがシーケンステーブルに対するロックを許可しなくなったため、
    pgpool_catalog.insert_lockテーブルに対して行ロックをかけることで排他制御を行ないます。
    したがって、pgpool-II経由でアクセスするすべてのデータベースにinsert_lockテーブルを
    あらかじめ作成しておく必要があります。
    詳細は<a href="#install">insert_lockテーブルの作成</a>の項目をご覧ください。
    もし、insert_lockテーブルが存在しない場合は、挿入対象のテーブルに対してロックを行います。
    これは、pgpool-II 2.2と2.3シリーズのinsert_lockと同じ動作です。
    また、過去のバージョンと互換性のあるinsert_lockを使用したい場合は、configureスクリプトで設定できます。
    詳細は<a href="#install">configureの実行</a>の項目をご覧下さい。
    </p>
    <p>
    なお、あまり必要ないかも知れませんが、コメントを利用して、この挙動を細かく制御することもできます。
    </p>

    <ol>
        <li>insert_lockをtrueにして、INSERT文の先頭に/*NO INSERT LOCK*/コメントを追加する。
        このコメントがあると、テーブルロックは行われません(pgpool-II 3.0以降でも同様)。
        </li>
        <li>insert_lockをfalseにして、INSERT文の先頭に/*INSERT LOCK*/コメントを追加する。
        このコメントがあると、このINSERT文に対してのみテーブルロックが行われます(pgpool-II 3.0以降でも同様)。
        </li>
    </ol>

    <p>
    insert_lockのデフォルト値はtrueです。
    </p>
    <p>
    なお、insert_lockを有効にしてregression testを実行すると、少くともPostgreSQL 8.0では
    transactions, privileges, rules, alter_tableがfailします。
    ruleでは、viewに対してLOCKをしようとしてしまうこと、ほかのものは
    </p>
<pre>
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
</pre>

    <p>
    というようなメッセージが出てしまうためです。たとえば、transactions では、
    存在しないテーブルに対してINSERTを行うテストが含まれており、
    pgpoolが最初に存在しないテーブルに対してLOCKを行う結果、エラーになってトランザクションがアボート状態になり、
    続くINSERTで上記エラーが出てしまいます。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="RECOVERY_USER"></a>recovery_user</dt>
    <dd>
    <p>
    オンラインリカバリを行うための PostgreSQL ユーザ名です。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="RECOVERY_PASSWORD"></a>recovery_password</dt>
    <dd>
    <p>
    オンラインリカバリを行うための PostgreSQL ユーザパスワードです。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="RECOVERY_1ST_STAGE_COMMAND"></a>recovery_1st_stage_command</dt>
    <dd>
    <p>
    オンラインリカバリ中に起動するコマンド名を指定します。
    このスクリプトはPostgreSQLのマスタサーバ(プライマリサーバ)が起動します。
    コマンドファイルはセキュリティ上の観点からデータベースクラスタ以下にある
    コマンドやスクリプトのみを呼び出します。
    例えば、recovery_1st_stage_command = 'sync-command' と設定してある場合、
    $PGDATA/sync-command を起動しようとします。
    </p>
    <p>
    recovery_1st_stage_command は次の3つの引数を受けとります。
    </p>
    <ol>
        <li>マスタ(プライマリ)データベースクラスタへのパス</li>
        <li>リカバリ対象のPostgreSQLのホスト名</li>
        <li>リカバリ対象のデータベースクラスタへのパス</li>
    </ol>
    <p>
    recovery_1st_stage_command を実行している間は pgpool ではクライアン
    トからの接続を<b>制限しません</b>。参照や更新を行うことができます。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="RECOVERY_2ND_STAGE_COMMAND"></a>recovery_2nd_stage_command</dt>
    <dd>
    <p>
    2 回目のオンラインリカバリ中に起動するコマンド名を指定します。
    このスクリプトはPostgreSQLのマスタサーバ(プライマリサーバ)が起動します。
    コマンドファイルはセキュリティ上の観点からデータベースクラスタ以下にある
    コマンドやスクリプトのみを呼び出します。
    例えば、recovery_2nd_stage_command = 'sync-command' と設定してある場合、
    $PGDATA/sync-command を起動しようとします。
    </p>
    <p>
    recovery_2nd_stage_command は次の3つの引数を受けとります。
    </p>
    <ol>
        <li>マスタ(プライマリ)データベースクラスタへのパス</li>
        <li>リカバリ対象のPostgreSQLのホスト名</li>
        <li>リカバリ対象のデータベースクラスタへのパス</li>
    </ol>
    </p>
    <p>
    recovery_2nd_stage_command を実行している間は pgpool ではクライアントから
    接続、参照、更新処理を一切<b>受け付けません</b>。
    また、バッチ処理などによって接続しているクライアントが長時間存在している場合にはコマンドを起動しません。
    新たな接続を制限し、現在の接続数が 0 になった時点
    でコマンドを起動します。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="RECOVERY_TIMEOUT"></a>recovery_timeout</dt>
    <dd>
    <p>
    pgpoolは、オンラインリカバリの際にすべてのクライアントが接続を終了するまで待ちます。
    recovery_timeoutでその最大待ち時間を指定します。単位は秒です。
    待ち時間がrecovery_timeoutを越えると、オンラインリカバリは中止され、通常の状態に戻ります。
    </p>
    <p>
    アイドル状態のクライアントが自分から切断するのを待ちたくない場合は、
    <a href="#CLIENT_IDLE_LIMIT_IN_RECOVERY">client_idle_limit_in_recovery</a>を利用することもできます。
    </p>
    </p>
    <p>
    recovery_timeoutは、この他、オンラインリカバリの最後にリカバリ対象のDBノードで
    postmasterを起動する際の待ち時間にも利用されます。
    </p>
    <p>
    recovery_timeoutのデフォルト値は90秒です。
    recovery_timeoutを0としてもタイムアウトが無効になるわけではなく、
    単に即座にタイムアウトするだけですので注意してください。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="CLIENT_IDLE_LIMIT_IN_RECOVERY"></a>client_idle_limit_in_recovery</dt>
    <dd>
    <p>
    client_idle_limitと似ていますが、このパラメータはリカバリのセカンドステージでのみ効力があります。
    前回クライアントから来たクエリから、client_idle_limit_in_recovery 秒越えても次のクエリが届かない場合は、
    ク    ライアントへの接続を強制的に切断し、リカバリのセカンドステージの進行が妨害されるのを防ぎます。
    -1を指定すると、直ちにクライアントへの接続を切断してセカンドステージに入ります。
    デフォルト値は 0(無効)です。
    </p>
    <p>
    クライアントが忙しく、アイドル状態にならない場合はclient_idle_limit_in_recoveryを設定しても
    セカンドステージに移行できません。
    この場合、client_idle_limit_in_recoveryに-1を設定すると、クライアントがビジーであっても
    ただちにクライアントへの接続を切断し、セカンドステージに移行することができます。
    </p>
    <p>
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
    </p>
    </dd>

<dt><a name="LOBJ_LOCK_TABLE"></a>lobj_lock_table</dt>
    <dd>
    <p>
    ラージオブジェクトのレプリケーションを行いたいときにロック管理に使うためのテーブル名を指定します。
    このテーブルが指定されていて、ラージオブジェクトの作成要求がクライアントから送信され、
    かつその要求の中にラージオブジェクトのIDの明示的な指定が含まれていない場合
    (つまり、lo_creatでラージオブジェクトを作成する場合)、
    pgpool-IIは、排他制御のためにこのテーブルをロックした後、
    ラージオブジェクトを格納するシステムカタログpg_largeobjectのラージオブジェクトに格納されている
    IDの最大値を取りだし、その値+1のIDを使ってlo_create()を呼び出してラージオブジェクトの作成を行います
    (lo_create()を持たないバージョン8.1より前のPostgreSQLではこの処理は行われません)。
    この方法により、すべてのDBノードで同じIDを持つラージオブジェクトが作成されることが保証されます。
    </p>
    <p>
    このような処理の対象となるラージオブジェクトの操作は、PostgreSQLのC言語用のAPI(libpq)で言うと、lo_creat()です。
    2010年2月時点の我々の調査では、以下の言語のラージオブジェクト作成APIは、すべてlo_creat()を呼び出すか、
    またはlo_creat()と同じ通信プロトコルを使っているので、pgpool-IIの上記の操作の対象になり、
    ラージオブジェクトのレプリケーションが安全に行われるようになります。
    </p>

    <ul>
        <li>Java(JDBCドライバ)</li>
        <li>PHP(pg_lo_create関数、またはPDOなどの該当API)</li>
        <li>psqlから\lo_importを呼び出す場合</li>
    </ul>

    <p>
    上記以外であっても、ラージオブジェクトの作成APIで
    ラージオブジェクトのIDを引数として渡すようになっていないものは
    間違いなくlo_creat()を使っており、pgpool-IIの上記の操作の対象になると考えて良いでしょう。
    </p>

    <p>
    pgpool-IIの上記処理の対象とならないようなラージオブジェクトの作成処理は以下のものです。
    </p>
    <ul>
        <li>libpqのlo_create()を使用している</li>
        <li>C言語以外のAPIで、lo_create()を使用しているもの</li>
        <li>バックエンド関数のlo_importをSELECTで呼び出す場合</li>
        <li>バックエンド関数のlo_creatをSELECTで呼び出す場合</li>
    </ul>
    <p>
    lobj_lock_tableで指定するテーブルはどのような定義のものでも構いませんが、
    あらかじめ作成済でかつすべてのユーザが書き込み可能でなければなりません。
    そのようなテーブルを作る例を示します。
    </p>

<pre>
CREATE TABLE public.my_lock_table ();
GRANT ALL ON public.my_lock_table TO PUBLIC;
</pre>

    <p>
    この操作はpgpool-II経由で接続するすべてのデータベースに対して、あらかじめ実施しておかなければなりません。
    しかし、この操作をtemplate1データベースに対して一度行っておけば、
    以後作成されるデータベースにはこのテーブルが含まれるようになるので、管理の手間が省けます。
    </p>
    <p>
    lobj_lock_tableに指定するテーブル名が空文字の場合は、ラージオブジェクトに関する上記の処理は行いません
    (したがって、ラージオブジェクトのレプリケーションは保証されません)。
    lobj_lock_tableのデフォルト値は空文字です。
    </p>
    </dd>

</dl>

<h2 id="condition_for_load_balance">ロードバランスの条件について</h2>
<p>
load_balance_mode = true を設定した場合、以下の条件のすべてを満たした時に
SELECTなどの問い合わせがロードバランスされます。
</p>
<ul>
    <li>PostgreSQLのバージョンが7.4以降である</li>
    <li>問い合わせが明示的なトランクザションブロックの内側にない(つまり、BEGINを発行していない)</li>
    <li>SELECT文(WITH付も含む。black_listまたはwhite_listで指定された書き込みを含むSELECTを除く)
        またはCOPY TO STDOUT, EXPLAIN, EXPLAIN ANALYZE SELECT... のいずれかである</li>
    <li>SELECT INTO 文ではない</li>
    <li>SELECT FOR UPDATE/SELECT FOR SHARE文ではない</li>
    <li>クエリ文字列が SELECTまたはWITH で始まる(ignore_leading_white_space = trueの場合は空白は無視します)</li>
</ul>
<p>
(<a href="#replicate_select">replicate_selectの項目</a>も参考にしてください)
また、<a href="where_to_send_queries.pdf">詳細な判定条件をフローチャートにしたもの</a>もご覧下さい。
</p>

<p>
なお、
</p>

<pre>
/*REPLICATION*/ SELECT ...
</pre>

<p>
とすることによって、本来負荷分散されたり、マスタのみに送信されるべき問合わせが
すべてのバックエンドに送信される（レプリケーションされる）ようになります。
副作用がある関数を含む問合わせに対してはこのテクニックが利用できます。
</p>

<p>
<font color="red">
注意: JDBC ドライバなどのように、ドライバ内で autocommit の有効・無効のオプションがある場合、
autocommit を無効にすると、ドライバが内部で BEGIN コマンドを実行する関係上、
正しくロードバランスされない可能性があります。
クエリをロードバランスさせたい場合は autocommit を有効にしてください。
たとえばJDBCであれば setAutoCommit(true) を実行してください。
</font>
</p>

<h2 id="detach_in_replication_mode">レプリケーションモードにおける縮退運転について</h2>
<p>
PostgreSQLサーバのうち、1台がダウンすると、そのサーバを切り離して縮退運転に入ります。
1台でもサーバが生き残っていれば、システムとしての運用を継続できます。
</p>

<h2 id="errors_in_replication_mode">レプリケーションモード固有のエラーについて</h2>
<p>
レプリケーションモードにおいて、pgpoolはレプリケーション時に INSERT、UPDATE、DELETE の更新件数が
すべてのノードが同じでない場合、
<a href="#FAILOVER_IF_AFFECTED_TUPLES_MISMATCH">failover_if_affected_tuples_mismatch</a> が falseならば、
意図的に構文エラーを起すSQLを送信することによって、トランザクションをアボートさせます。
trueならば、フェイルオーバが起きます。その際、以下のようなエラーメッセージが表示されます。
</p>

<pre>
=# UPDATE t SET a = a + 1;
ERROR: pgpool detected difference of the number of update tuples Possible last query was: "update t1 set i = 1;"
HINT: check data consistency between master and other db node
</pre>

<p>
ログには更に以下のように、更新行数が記録されます(この場合はDBノード0が0行、DBノード1が1行)。
</p>
<pre>
2010-07-22 13:23:25 LOG:   pid 5490: SimpleForwardToFrontend: Number of affected tuples are: 0 1
2010-07-22 13:23:25 LOG:   pid 5490: ReadyForQuery: Degenerate backends: 1
2010-07-22 13:23:25 LOG:   pid 5490: ReadyForQuery: Number of affected tuples are: 0 1
</pre>

<!-- ================================================================================ -->

<h1><a name="master_slave_mode"></a>マスタースレーブモード</h1>
<p>
master/slaveモードは、Slony-IやStreaming Replicationのような、
master/slave式のレプリケーションソフトにレプリケーションをまかせるモードです。
このモードで使うためには、レプリケーションモードと同じように、
DBノードのホスト情報(<a href="#BACKEND_HOSTNAME">backend_hostname</a>,
<a href="#BACKEND_PORT">backend_port</a>, <a href="#BACKEND_WEIGHT">backend_weight</a>,
<a href="#BACKEND_FLAG">backend_flag</a> それにオンラインリカバリが必要ならば
<a href="#BACKEND_DATA_DIRECTORY">backend_data_directory</a>)をセットし、
<a href="#MASTER_SLAVE_MODE">master_slave_mode</a>と<a href="LOAD_BALANCE_MODE">load_balance_mode</a>をtrueにします。
</p>
<p>
pgpool-IIは、レプリケーションされる必要のある問い合わせはマスターに送り、
その他の問い合わせを可能ならば負荷分散します。問い合わせによってマスターDBだけに問い合わせが送られる場合と、
DBノードの間でロードバランスされて問い合わせが送られる場合があります。
</p>

<p>
マスタスレーブモードでは、一時テーブルの作成、更新、検索はマスタノードでのみ実行されます。
SELECTをマスタだけで実行するように強制することができます。
このためには、/*NO LOAD BALANCE*/ コメントをSELECTに前に挿入しなければなりません。
</p>
<p>
マスタースレーブモードでは、pgpool.confのreplication_modeをfalseに、
<a href="#MASTER_SLAVE_MODE">master_slave_mode</a> をtrueにします(同時にtrueにはできません)。
また、'<a href="#MASTER_SLAVE_SUB_MODE">master_slave_sub_mode</a>'を指定します。
これは、'slony'(デフォルト)か、'stream'です。
</p>
<p>
'slony'はSlony-Iを利用する時に指定します。
'stream'は、PostgreSQL組み込みのStreaming Replicationを利用するときに指定します。
</p>
Slony-Iを使う場合の設定ファイルの雛形はpgpool.conf.sample-master-slaveです。
Streaming Replicationを使う場合の雛形はpgpool.conf.sample-streamです。
</p>
<p>
このパラメータを変更した時には pgpool-II を再起動してください。
</p>
<p>
マスタースレーブモードでも、DB書き込みを行なう関数の呼び出しを含むSELECTを負荷分散の対象から外す指定を
<a href="#white_function_list">white_function_list</a>と
<a href="#black_function_list">black_function_list</a>で行なうことができます。
詳細は<a href="#white_function_list">white_function_list</a>の項をご覧下さい。
</p>

<!-- ================================================================================ -->

<h1><a name="stream">Streaming Replicationへの対応</a></h1>
<p>
前述のように、マスタスレーブモードで、'<a href="#MASTER_SLAVE_SUB_MODE">master_slave_sub mode</a>'に
'stream'を指定すると、PostgreSQL 9.0から利用可能になったStreaming Replicationに対応します
(pgpool-IIでは、今のところ、Streaming ReplicationとHot Standbyを併用することを前提にしています)。
このモードでは、以下の設定項目も利用できます。

<ul id="params_for_stream_mode">
<li id="DELAY_THRESHOLD">delay_threshold
    <p>
    スタンバイサーバへのレプリケーションの遅延許容度をバイト単位で指定します。
    pgpool-IIは、スタンバイサーバの遅延がこの値を超えた場合には、
    負荷分散が有効であってもそのDBノードにSELECTを送信せず、プライマリサーバに送るようにします。
    delay_thresholdが0の場合は、遅延のチェックを行ないません。
    また、delay_thresholdが指定されていても、sr_check_periodが無効(=0)ならば、やはりこの機能は働きません。
    デフォルト値は0です。
    </p>
    <p>
    このパラメータは設定ファイルの再読込によって変更できます。
    </p>
</li>

<li id="SR_CHECK_PERIOD">sr_check_period
    <p>
    ストリーミングレプリケーションの遅延チェックの間隔を秒単位で指定します。
    デフォルト値は0で、これはチェックを行わないことを意味します。
    </p>
    <p>
    このパラメータは設定ファイルの再読込によって変更できます。
    </p>
</li>

<li id="SR_CHECK_USER">sr_check_user
    <p>
    ストリーミングレプリケーションの遅延チェックを行うユーザ名を指定します。
    このユーザは、すべてのバックエンドに存在しなければなりません。
    さもなければエラーになります。
    sr_check_userとsr_check_passwordは、sr_check_periodが0であっても
    指定が必要です。pgpool-IIは、どのサーバがprimaryサーバであるのかを調べるために、
    PostgreSQLバックエンドに関数呼び出しのリクエストを送ります。
    そのセッションでsr_check_userとsr_check_passwordが使われるからです。
    </p>
    <p>
    このパラメータは設定ファイルの再読込によって変更できます。
    </p>
</li>

<li id="SR_CHECK_PASSWORD">sr_check_password
    <p>
    ストリーミングレプリケーションの遅延チェックを行うユーザに対するパスワードをを指定します。
    パスワードが必要なければ空文字('')を指定します。
    </p>
    <p>
    このパラメータは設定ファイルの再読込によって変更できます。
    </p>
</li>

<li id="LOG_STANDBY_DELAY">log_standby_delay
    <p>
    レプリケーションの遅延状況をログする条件を指定します。
    'none'を指定すると、ログを出力しません。
    'always'ならヘルスチェックを実行するたびに必ず出力します。
    'if_over_threshold'を指定すると、delay_thresholdを超えたときだけログが出力されます。
    デフォルト値は'none'です。
    </p>
    <p>
    このパラメータは設定ファイルの再読込によって変更できます。
    </p>
    <p>
    なお、レプリケーションの遅延状況は show pool_status コマンドでも確認できます。
    項目名は"standby_delay#"です(#はDBノードIDです)。
    </p>
</li>
</ul>

<h2 id="failover_in_stream_mode">Streaming Replicationでのフェイルオーバ</h2>
<p>
Streaming replicationを利用したマスタスレーブモードでは、PrimaryやStandbyノードが停止した場合に、
レプリケーションモードと同じように自動フェイルオーバを行なわせることができます。
特に何も設定しなくても、停止したノードを自動的に切り放すことができますが、Streaming replicationでは、
「トリガファイル」を作成することにより、Standbyノードを、リカバリモードから更新問い合わせを受け付ける
通常のPostgreSQLの動作モードに自動変更することができます。
これを利用して、フェイルオーバコマンドを併用して、Primaryノードがダウンしたときに、
Standbyノードが自動的にとって代るような設定を行なうことができます。
</p>
<p>
<strong>注意: 複数のStandbyノードを利用している場合、この設定を行なうときは、
<a href="#DELAY_THRESHOLD">delay_threshold</a>を設定して、
他のStandbyに振り分けられたSELECTが古いデータを取得しないようにしておくことをお勧めします。
また、1台目のStandbyノードがPrimaryにとって代ったのちにダウンしてしまったケースで、
2台目のStandbyが更に取って代わるとデータに不整合がおきるので、そのような設定は行なわないようにしてください。</strong>
</p>
<p>
フェイルオーバの設定手順を示します。
</p>
<p>
<ol>
    <li>フェイルオーバ用のスクリプトを適当な場所(ここでは/usr/local/pgsql/bin)に配置して、実行権限を与えておきます。
<pre>
$ cd /usr/loca/pgsql/bin
$ cat failover_stream.sh
#! /bin/sh
# Failover command for streming replication.
# This script assumes that DB node 0 is primary, and 1 is standby.
#
# If standby goes down, does nothing. If primary goes down, create a
# trigger file so that standby take over primary node.
#
# Arguments: $1: failed node id. $2: new master hostname. $3: path to
# trigger file.

failed_node=$1
new_master=$2
trigger_file=$3

# Do nothing if standby goes down.
if [ $failed_node = 1 ]; then
    exit 0;
fi

# Create trigger file.
/usr/bin/ssh -T $new_master /bin/touch $trigger_file

exit 0;

chmod 755 failover_stream.sh
</pre>
    </li>

    <li>pgpool.confの、<a href="#FAILBACK_COMMAND">failover_commmand</a>を設定します。
<pre>
failover_command = '/usr/local/src/pgsql/9.0-beta/bin/failover_stream.sh %d %H /tmp/trigger_file0'
</pre>
    </li>

    <li>standbyノードのrecovery.confを設定します。
    <a href="recovery.conf.sample">recovery.confのサンプル</a>は PostgreSQLのインストールディレクトリ下の
    "share/recovery.conf.sample"にあります。
    これをstanndbyノードのデータベースクラスタ下に"recovery.conf"としてコピーしておきます。
    そして、以下の項目を設定します。
<pre>
standby_mode = 'on'
primary_conninfo = 'host=primary_hostのホスト名 user=postgres'
trigger_file = '/tmp/trigger_file0'
</pre>
    </li>

    <li>primaryノードのpostgresql.confを設定します。
    以下は例ですので、必ず実際に合わせて調整してください。
<pre>
wal_level = hot_standby
max_wal_senders = 1
</pre>
    </li>

<li>primaryノードのpg_hba.confを設定します。
以下は例ですので、必ず実際に合わせて調整してください。

<pre>
host    replication    postgres        192.168.0.10/32        trust
</pre>
    </li>

</ol>

<p>
primaryとstandbyのPostgreSQLを起動すれば、Streaming replicationが開始されます。
そして、primaryノードがダウンしたときに、自動的にstandbyノードが通常のPostgreSQLとして立ち上がり、
更新問い合わせを受け付けるようになります。
</p>

<h2 id="load_balance_in_stream_mode">Streaming Replicationでのクエリ振り分け</h2>
<p>
Streaming replicationとHot Standbyを利用している環境では、primaryノードに送ってよい問い合わせ、
standbyに送ってもよい問い合わせ、両方に送らなければならない問い合わせを厳密に管理する必要があります。
pgpool-IIのStreaming Replicationモードは、こうした振り分けを自動的に行ないます。
ここでは、そのロジックについて説明します。
</p>
<p>
まず、問い合わせの種類によって以下のように分けられます。
</p>

<ul>
    <li>Primaryノードにしか送られない問い合わせ
    <ul>
        <li>INSERT, UPDATE, DELETE, COPY FROM, TRUNCATE, CREATE, DROP, ALTER, COMMENT</li>
        <li>SELECT ... FOR SHARE | UPDATE</li>
        <li>トランザクションの分離レベルがシリアライザブルの場合のSELECT</li>
        <li>ROW EXCLUSIVE MODEよりも強いLOCK</li>
        <li>トランザクションコマンドの一部
            <ul>
                <li>BEGIN READ WRITE, START TRANSACTION READ WRITE
                <li>SET TRANSACTION READ WRITE, SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE
                <li>SET transaction_read_only = off
            </ul>
        </li>
        <li>二相コミット関連のコマンド。PREPARE TRANSACTION, COMMIT PREPARED, ROLLBACK PREPARED</li>
        <li>LISTEN, UNLISTEN, NOTIFY</li>
        <li>VACUUM</li>
        <li>シーケンス関連の関数(nextvalやsetvalなど)の呼び出し。</li>
        <li>ラージオブジェクトの生成</li>
    </ul>
    </li>

    <li>Primary/Standbyどちらにも送ることのできる問い合わせ。
    <p>
    負荷分散設定が有効ならば、standbyノードにも送信されます。
    ただし、レプリケーションの遅延上限(delay_threshold)が設定されていて、
    レプリケーションの遅延が<a href="#DELAY_THRESHOLD">delay_threshold</a>を上回っている場合は
    問い合わせはPrimaryに送られます。
    </p>
    <ul>
        <li>上記以外のSELECT</li>
        <li>COPY TO</li>
        <li>DECLARE, FETCH, CLOSE</li>
        <li>SHOW</li>
    </ul>
    </li>

    <li>Primary/Standbyどちらにも送られる問い合わせ
    <ul>
        <li>SET</li>
        <li>DISCARD</li>
        <li>DEALLOCATE ALL</li>
    </ul>
    </li>
</ul>

<p>
明示的なトランザクションでは、以下のようになります。
</p>

<ul>
    <li>BEGINなどのトランザクション開始コマンドは、Primaryサーバに送られます。</li>
    <li>続くSELECTなど、Primary/Standbyどちらにも送ることのできる問い合わせは、
        Primaryのトランザクション内でそのまま実行されるか、Standbyサーバで実行されます。</li>
    <li>
    INSERTなど、Standbyに送ることのできない問い合わせが現われた場合は、Primaryサーバで実行されます。
    以後、SELECTなど、本来Standbyに送信しても構わないコマンドもPrimaryサーバで実行されます。
    これは、トランザクションの中で実行されたINSERTなどの問い合わせの結果を
    SELECTが直ちに参照できるようにするためです。
    この状態は、トランザクションが閉じるか、アボートするまで続きます。
    </li>
</ul>

<p>
問い合わせが、拡張問い合わせモードで実行される場合は、問い合わせのparse段階で、
問い合わせが負荷分散可能かどうかで送信先が決まります。
その際の判断ルールは、通常のSQLと同じです。
たとえば問い合わせがINSERTならば、Primaryサーバで実行される、という具合です。
parseに続くbind, describe, executeも同じDBノードで実行されます。
</p>

<p>
[注: SELECTが負荷分散されて Standby ノードで parseが実行されてから更新クエリが来た場合は、
そのSELECTはPrimaryノードで実行されなければなりません。
そのため、同じSELECTが再度Primaryノードでパースされることになります。]
</p>

<p>
最後に、pgpool-IIのパーサが構文エラーと判断した問い合わせはPrimaryノードだけに送られます。
</p>

<h2 id="online_recovery_in_stream_mode">Streaming Replicationでのオンラインリカバリ</h2>
<p>
Streaming replicationを利用したマスタスレーブモードでは、
レプリケーションモードと同じようにオンラインリカバリが利用できます。
primaryサーバをマスタとし、standbyサーバをリカバリします。
primaryサーバが動作しているのがこの方法の前提条件ですので、
primaryサーバが停止している状態ではオンラインリカバリはできません。
primaryサーガ停止している状態からの復旧は、すべてのDBノードとpgpool-IIを停止させて手動で実施しなければなりません。
</p>

<ol>
    <li>リカバリ処理を実行するユーザ <a href="#RECOVERY_USER">recovery_user</a> を設定します。
        通常、postgresユーザとなります。
<pre>
recovery_user = 'postgres'
</pre>
    </li>

    <li><a href="#RECOVERY_PASSWORD">recovery_password</a> を設定します。
        これは、<a href="#RECOVERY_USER">recovery_user</a> がDBにログインするときに使うパスワードです。
<pre>
recovery_password = 't-ishii'
</pre>
    </li>

    <li><a href="#RECOVERY_1ST_STAGE_COMMAND">recovery_1st_stage_command</a> を設定します。
    <p>
    ここで指定するファイルは、primaryサーバからベースバックアップを取得し、
    standbyサーバにリストアするものでなければなりません。
    recovery_1st_stage_command は、primaryのPostgreSQLから、recovery_userの権限で起動され、
    その時に引数を受けとります。
    詳細は、<a href="#RECOVERY_1ST_STAGE_COMMAND">recovery_1st_stage_command</a>の設定項目をご覧ください。
    </p>
    <p>
    このスクリプトファイルは、primaryのデータベースクラスタ下に配置し、実行権限を与えておきます。
    サンプルとして、primary/standbyそれぞれ一台構成の場合のスクリプト
    <a href="basebackup.sh">(basebackup.sh)</a>を示します。
    このスクリプトでは、recovery_user がパスワードなしでリカバリ対象の
    standbyノードにログインできることを前提にしているので、
    あらかじめsshの設定を行なっておく必要があります。
    </p>
<pre>
recovery_1st_stage_command = 'basebackup.sh'
</pre>
    </li>

    <li><a href="#RECOVERY_2ND_STAGE_COMMAND">recovery_2nd_stage_command</a> は、空のままで構いません。
<pre>
recovery_2nd_stage_command = ''
</pre>
    </li>

    <li>オンラインリカバリを実施するための PostgreSQL の C 言語関数やSQL関数を各DBノードにインストールします。

    <pre>
# cd pgpool-II-x.x.x/sql/pgpool-recovery
# make
# make install
# psql -f pgpool-recovery.sql template1
    </pre>
    </li>

    <li>オンラインリカバリが終了したあと、pgpool-IIは、停止していたDBノードのPostgreSQLを起動します。
    そのためのスクリプトを、各DBノードのDBクラスタにインストールします。
    <p>
    <a href="pgpool_remote_start">スクリプトのサンプル</a>がソースコードの"sample"ディレクトリに含まれているので、
    それを利用してください。
    このサンプルの中では、PostgreSQLの起動をpg_ctlコマンドで行っており、pg_ctlコマンドへのパスが記述されています。
    デフォルトでは/usr/local/pgsql/bin/pg_ctlとなっているので、お使いの環境に合わせて修正してください。
    </p>
    <p>
    なお、このスクリプトはsshを使用しますので、少くとも、primaryのDBノードから、standbyのDBノードに対して、
    recovery_userでパスワードなしでsshが利用できることが必要です。
    必要ならばあらかじめ設定しておいてください。
    </p>
    </li>
</ol>

<p>
以上でオンラインリカバリの設定が終了しました。
standbyノードを停止した状態で、pcp_recovery_nodeを利用するか、
pgpoolAdminの「リカバリ」ボタンでオンラインリカバリが出来るようになったはずです。
うまくいかない場合は、pgpool-IIのログ、primaryサーバ、standbyサーバのログを確認してください。
</p>

<p>
参考までに、ストリーミングレプリケーションでのオンラインリカバリの内部処理の流れを説明します。
</p>

<ol id="setting_for_online_recovery_in_stream_mode">
    <li>pgpool-IIは、primaryサーバにユーザ: <a href="#RECOVERY_USER">recovery_user</a>,
        パスワード: <a href="#RECOVERY_PASSWORD">recovery_password</a> で
        template1データベースに接続します。
    </li>
    <li>primaryサーバで、pgpool_recovery関数を実行します。
    </li>
    <li>pgpool_recovery関数は、<a href="#RECOVERY_1ST_STAGE_COMMAND">recovery_1st_stage_command</a> で
        指定されたスクリプトを実行します。
        <p>
        なお、PostgreSQLは、データベースクラスタディレクトリ中で関数を実行します。
        よって、pgpool_recovery関数もprimaryサーバのデータベースクラスタディレクトリ中で
        関数を実行されることに注意してください。
        </p>
    </li>
    <li>primaryサーバで、pgpool_remote_start関数を実行します。
    <p>
    この関数は、primaryサーバのデータベースクラスタディレクトリ中にある
    pgpool_remote_startという名前のスクリプトを起動し、
    ここからssh経由でリカバリ対象のstandbyサーバのPostgreSQLをpg_ctlコマンドを使って起動します。
    起動はバックグラウンドで行われ、起動できたかどうかは次のステップで確認されます。
    </p>
    </li>
    <li>pgpool-IIから、standbyサーバのPostgreSQLのpostgresデータベース
        (postgresデータベースがない場合はtemplate1データベース)に、
        ユーザ: <a href="#RECOVERY_USER">recovery_user</a>,
        パスワード: <a href="#RECOVERY_PASSWORD">recovery_password</a> でtemplate1データベースに接続を試みます。
        <p>
        リトライは、<a href="#RECOVERY_TIMEOUT">recovery_timeout</a>秒間行われます。
        PostgreSQLの起動に成功したら、次のステップに移ります。
        </p>
    </li>
    <li><a href="#FAILBACK_COMMAND">failback_command</a>が空でない場合は、
        pgpool-IIの親プロセスは指定されたスクリプトを起動します。
    </li>
    <li><a href="#FAILBACK_COMMAND">failback_command</a>が終了したら、pgpool-IIの子プロセスをすべて再起動します。
    </li>
</ol>

<!-- ================================================================================ -->

<h1><a name="parallel"></a>パラレルモード</h1>
<p>
パラレルクエリ機能が利用できるモードです。
テーブルを分割させ、各ノードにデータを持たせることができます。またレプリケーションや負荷分散機能も同時に使うことができます。
</p>
<p>
パラレルモードでは、pgpool.confの<a href="#REPLICATION_MODE">replication_mode</a>または
<a href="#LOAD_BALANCE_MODE">loadbalance_mode</a>にtrueを設定し、
<a href="#MASTER_SLAVE_MODE">master_slave</a> をfalseにし、
<a href="#PARALLEL_MODE">parallel_mode</a> をtrueにします。
このパラメータを変更した時には pgpool-II を再起動してください。
</p>

<h2 id="system_db">システムDBの設定</h2>
<p>
パラレルモードを利用するためには、システムDBを設定する必要があります。
システムDBはデータを各PostgreSQLサーバで分割するためのルールをPostgreSQLのテーブルの形で保持します。
システムDBはpgpoolが動作するホストと同じホストに置く必要はありません。
システムDBの設定はpgpool.confで行います。
</p>

<dl>
<dt><a name="SYSTEM_DB_HOSTNAME"></a>system_db_hostname</dt>
    <dd>
    <p>
    システムDBが動いているホスト名です。空文字を指定すると、UNIXドメインソケットで接続します。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="SYSTEM_DB_PORT"></a>system_db_port</dt>
    <dd>
    <p>
    システムDBのポート番号です。
    </p>
    <p>
    このパラメータを変更した時には pgpool-IIを再起動してください。
    </p>
    </dd>

<dt><a name="SYSTEM_DBNAME"></a>system_dbname</dt>
    <dd>
    <p>
    システムDBは専用のデータベースに設置します。そのデータベース名を指定します。
    このデータベースはあらかじめ存在しなければなりません。ここでは、
    "pgpool"というデータベース名にするものとします。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="SYSTEM_DB_SCHEMA"></a>system_db_schema</dt>
    <dd>
    <p>
    システムDBは専用のスキーマに設置します。そのスキーマ名を指定します。
    このスキーマはあらかじめ存在しなければなりません。ここでは、
    "pgpool_catalog"というスキーマにするものとします。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="SYSTEM_DB_USER"></a>system_db_user</dt>
    <dd>
    <p>
    システムDBに接続するときのユーザ名です。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

<dt><a name="SYSTEM_DB_PASSWORD"></a>system_db_password</dt>
    <dd>
    <p>
    システムDBに接続するときのパスワードです。パスワードを設定していない場合は空文字にしておきます。
    </p>
    <p>
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
    </dd>

</dl>

<h2 id="system_db_sql">システムDBの初期設定</h2>
<p>
システムDBにスキーマとテーブルを作成します。初期設定用のスクリプトが
$prefix/share/system_db.sqlにあるのでそれを利用します。
ただし、このスクリプトではスキーマ名が"pgpool_catalog"となっているので、
違うスキーマを使う場合は適当に書き換えてください。
また、データベース名として"pgpool"以外を使う場合は以下を適当に読み替えてください。
<pre>
psql -f $prefix/share/system_db.sql pgpool
</pre>

<h2 id="install_dblink">dblinkのインストール</h2>
<p>
パラレルモードではdblinkを使います。dblinkはPostgreSQLソースファイル($POSTGRES_SRC)
</p>
<pre>
$(POSTGRES_SRC)/contrib/dblink
</pre>
<p>
にあります。$POSTGRES_SRC/contrib/dblink/README.dblinkを参考にシステム
DBにdblinkをインストールしてください。
</p>
<p>
また、pgpoolデータベースに関数の登録が必要です。
</p>
<pre>
psql pgpool &lt; $POSTGRES_SRC/contrib/dblink/dblink.sql
</pre>

<h2 id="connection_setting">コネクション数の設定</h2>
<p>
パラレルモードでは、クエリによりシステムDBからdblink経由でpgpoolに接続するので、
想定される同時接続数以上のコネクションが必要になる場合があります。
そのため、pgpool.confの<a href="#NUM_INIT_CHILDREN">num_init_children</a>には
同時接続数より十分大きい値を設定して下さい。
</p>
<p>
目安として以下の式で<a href="#NUM_INIT_CHILDREN">num_init_children</a>を設定してください。
</p>
<pre>
num_init_children = 想定される同時接続数 * ( 1 + クエリの中で使われているテーブルの最大数)
</pre>

<h3 id="distdef">データ分割ルールの登録</h3>
<p>
データ分割を行うテーブルに対しては、テーブル情報をあらかじめ pgpool_catalog.dist_def
というテーブルに登録しておきます。
</p>

<pre>
CREATE TABLE pgpool_catalog.dist_def(
    dbname TEXT,                   -- DB名
    schema_name TEXT,              --schema名
    table_name TEXT,               -- テーブル名
    col_name TEXT NOT NULL CHECK (col_name = ANY (col_list)),    -- 分散キー列名
    col_list TEXT[] NOT NULL,      -- tableの属性名
    type_list TEXT[] NOT NULL,     -- 属性のタイプ名
    dist_def_func TEXT NOT NULL,   -- 分散先のDBノードを決定する関数名
    PRIMARY KEY (dbname,schema_name,table_name)
    );
</pre>

<h3 id="replicate_def">レプリケーションテーブルのルール登録</h3>
<p>
一つのSQL文にJOIN等でデータ分割ルールに登録したテーブルと共に
レプリケーションを行うテーブルを指定する場合には、レプリケーションを行うテーブルの情報を
あらかじめ、pgpool_catalog.replicate_defというテーブルに登録しておきます。
</p>

<pre>
CREATE TABLE pgpool_catalog.replicate_def(
    dbname TEXT,                 -- DB名
    schema_name TEXT,            -- schema名
    table_name TEXT,             -- テーブル名
    col_list TEXT[] NOT NULL,    -- tableの属性名
    type_list TEXT[] NOT NULL,   -- 属性のタイプ名
    PRIMARY KEY (dbname,schema_name,table_name)
);
</pre>

<h2 id="example_partitioning">pgbench テーブルでの分割ルール例</h2>

<p>
pgbenchのテーブルを分割するルールの例を示します。
</p>
<p>
この例では、accountsテーブルに対しては分割を行い、branchesテーブル
とtellersテーブルに対してはレプリケーションを行うことにします。
また、accountsテーブルとbanchesテーブルはbidで結合されることを想定し
branchesテーブルはレプリケーションテーブルのルール登録を行います。
</p>
<p>
もし、accountsテーブル、branchesテーブルとtellersテーブルの３つの
テーブルの結合が行われる場合には、あらかじめtellersテーブルに対しても
レプリケーションテーブルのルール登録を行う必要があります。　
</p>

<pre>
INSERT INTO pgpool_catalog.dist_def VALUES (
    'pgpool',
    'public',
    'accounts',
        'aid',
        ARRAY['aid','bid','abalance','filler'],
        ARRAY['integer','integer','integer','character(84)'],
        'pgpool_catalog.dist_def_accounts'
);

INSERT INTO pgpool_catalog.replicate_def VALUES (
    'pgpool',
    'public',
    'branches',
    ARRAY['bid','bbalance','filler'],
    ARRAY['integer','integer','character(84)']
);
</pre>

<p>
ここで、pgpool_catalog.dist_def_accountsは、引数として分割キーの値を受け取り、
どのPostgreSQLサーバ(「DBノード」と呼びます)を0からの番号で返す関数です。
ここでは、3台のDBノードにデータを分割する関数の例を示します。
</p>
<pre>
CREATE OR REPLACE FUNCTION pgpool_catalog.dist_def_accounts (val ANYELEMENT) RETURNS INTEGER AS '
  SELECT CASE WHEN $1 &gt;= 1 and $1 &lt;= 30000 THEN 0
          WHEN $1 &gt; 30000 and $1 &lt;= 60000 THEN 1
          ELSE 2
END' LANGUAGE SQL;
</pre>

<!-- ================================================================================ -->

<h1><a name="hba"></a>クライアント認証(HBA)のための pool_hba.conf 設定方法</h1>
<p>
PostgreSQLのpg_hba.confと同じようにpgpoolでもpool_hba.confファイルを使った
クライアント認証がサポートされています。
</p>
<p>
pgpoolをインストールするとデフォルトインストール先の設定ファイルディレクトリ
"/usr/local/etc"にpool_hba.conf.sampleが一緒にインストールされます。
このpool_hba.conf.sampleファイルをpool_hba.confとしてコピーし、
必要であれば編集してください。
デフォルトではpool_hbaによる認証は有効になっています。
</p>
<p>
pool_hba.confのフォーマットはpg_hba.confのものとほとんど同じです。
</p>
<pre>
local      DATABASE  USER  METHOD  [OPTION]
host       DATABASE  USER  CIDR-ADDRESS  METHOD  [OPTION]
</pre>
<p>
各フィールドで設定できる値の詳細は"pool_hba.conf.sample"を参照してください。
</p>
<p>
以下はpool_hbaの制限事項です。
</p>

<ul>
    <li>"hostssl"接続タイプはサポートされません</li>
    <p>
    pool_hba.confに"hostssl"は指定することはできませんが、pgpool-IIは2.3以降でSSLをサポートしています。
    詳細は<a href="#ssl">SSL</a>を参照してください。
    </p>

    <li>DATABASEフィールド値として"samegroup"はサポートされません</li>
    <p>
    pgpoolはバックエンドサーバにあるユーザ情報を事前に知る事ができないため、
    データベース名はpool_hba.confにある値のみと比較されます。
    なのでグループに関する認証はpool_hbaで行うことができません。
    </p>
    </li>

<li>USERフィールド値として"+"を使ったグループ指定はサポートされません</li>
    <p>
    上記の"samegroup"と同じ理由で、ユーザ名はpool_hba.confにある値のみと比較されます。
    グループに関する認証はpool_hbaで行うことはできません。
    </p>
    </li>

<li>IPv6アドレス/マスク表記法はサポートされません</li>
    <p>
    現在pgpoolはIPv6をサポートしていません。
    </p>
    </li>

<li>"trust", "reject", "pam", "md5"以外のメソッドはサポートされません</li>
    <p>
    これも上記の"samegroup"と同じ理由によるものです。
    pgpoolはバックエンドのユーザ/パスワード情報を持っていないので、
    バックエンドに保存されているパスワードを使った認証を行うことができません。
    </p>
    <p>
    md5に関しては、pool_passwdというパスワードファイルを併用することによって利用できます。
    詳細は<a href="#md5">認証・アクセス制御方式</a>を参照してください。
    </p>
    </li>

</ul>

<p>
ここで説明された機能、制限はクライアントとpgpool間で行われるクライアント認証についてだということに
注意してください。
クラインアントはpgpoolのクライアント認証に成功したとしても、
PostgreSQLによるクライアント認証に成功しないと接続状態となりません。
pool_hbaにとってはクライアントに指定されたユーザ名やデータベース名(例. psql -U testuser testdb)が
実際にバックエンド上に存在するかどうかは問題ではありません。
それがpool_hba.confの値とマッチするかどうかでチェックが行われます。
</p>
<p>
pgpoolが稼働するホスト上のユーザ情報を使ったPAM認証を利用することができます。
pgpoolをPAMサポート付きでビルドするにはconfigureオプションに"--with-pam"を指定してください。
</p>
<pre>
./configure --with-pam
</pre>
<p>
実際にPAM認証を有効にするには、pool_hba.confで"pam"メソッドを設定するのに加え、
pgpoolのサービス設定ファイルをシステムのPAM設定ディレクトリ（通常は /etc/pam.d に作成する必要があります。
サービス設定ファイルの例はインストールディレクトリの"share/pgpool.pam"を参考にしてく
ださい。
</p>

<!-- ================================================================================ -->

<h1><a name="query_cache"></a>クエリキャッシュの設定方法</h1>

<p>
pgpool-IIでは、すべてのモードでクエリキャッシュを利用することができます。
クエリキャッシュは、SELECTの結果を再利用することにより、性能を向上させます。
利用する場合には、pgpool.confの設定を以下のように設定します。
</p>
<pre>
enable_query_cache = true
</pre>

<p>
また、システムDBに以下のテーブルを作成してください。
</p>
<pre>
CREATE TABLE pgpool_catalog.query_cache (
  hash TEXT,
  query TEXT,
  value bytea,
  dbname TEXT,
  create_time TIMESTAMP WITH TIME ZONE,
  PRIMARY KEY(hash, dbname)
);
</pre>

<p>
ただし、この例ではスキーマ名が"pgpool_catalog"となっているので、
違うスキーマを使う場合は適当に書き換えてください。
</p>
<p>
<strong>注意: 現在のクエリキャッシュの実装では、キャッシュがデータベース上に作成されます。
そのため、実行にあまり時間のかからないようなSELECTでは、クエリキャッシュを有効にすることによって、
かえって遅くなることがあります。また、クエリキャッシュの内容は、テーブルが更新されてもそのままです。
手動で上記テーブルから削除するか、-c オプション(クエリキャッシュのクリア)を追加して
pgpool-IIを再起動する必要があります。</strong>
</p>

<!-- ================================================================================ -->

<h1><a name="memqcache"></a>オンメモリクエリキャッシュの設定方法</h1>

<p>
pgpool-IIでは、すべてのモードでオンメモリクエリキャッシュを利用することができます。
上記のクエリキャッシュと違い、メモリ上にキャッシュが置かれるので高速であるばかりでなく、
データが更新されると自動的にキャッシュが無効になり、pgpool-IIの再起動の必要がありません。
</p>
<p>
オンメモリクエリキャッシュは、問い合わせのSELECT文(拡張問い合わせの場合は更にバインドパラメータ)と
検索結果をペアで記録し、2回目以降に同じSELECT文が発行された場合に、キャッシュから結果を返します。
通常のSELECT文処理と違って、PostgreSQLにアクセスしないだけでなく、
pgpool内部のSQLパース処理などを経由しないため、非常に高速です。
</p>
<p>
反面、キャッシュにヒットしない場合は通常のSELECT文の処理に加えてキャッシュ処理のオーバヘッドが生じるので、
かえって遅くなります。
また、あるテーブルが更新された場合、そのテーブルを参照している
すべてのキャッシュが自動削除されるため(自動削除しない設定も可能)、
更新処理が多いシステムではオンメモリクエリキャッシュを有効にしていることでかえって遅くなります。
キャッシュのヒット率が70%以下の場合は、オンメモリクエリキャッシュの設定を有効にしないほうが良いでしょう。
</p>

<h2 id="MEMORY_CACHE_RESTRICTIONS">オンメモリクエリキャッシュの制限事項</h2>
<p>
<ul>
  <li>オンメモリクエリキャッシュでは、テーブルに変更があると、関連するキャッシュを自動的に削除して古いデータが返却されないようにする機能があります。
	  このため、pgpoolは常にUPDATEやINSERTやALTER TABLEなどのコマンドが発行されたかどうかをモニタしています。
	  しかし、トリガ、外部キーやDROP TABLE CASCADEなどの働きによって暗黙的にテーブルが更新されたことはpgpool-IIからはわからないため、この機能が働きません。
	  この問題を回避するためには、<a href="#MEMQCACHE_EXPIRE">memqcache_expire</a>を使って一定時間経過したキャッシュを削除するようにするか、<a href="#WHITE_MEMQCACHE_TABLE_LIST">white_memqcache_table_list</a>か
	  <a href="#BLACK_MEMQCACHE_TABLE_LIST">black_memqcache_table_list</a>を使って、該当テーブルがキャッシュされないようにしてください。</li>
  <li>複数のpgpool-IIを動かす環境で共有メモリを使ったオンメモリクエリキャッシュを使用すると、あるpgpool-II経由でテーブルが更新された時に、他のpgpool-IIのキャッシュが削除されず、古いデータを読みだしてしまうことがあります。
	  このような環境では、キャッシュストレージにmemcachedを使ってください。</li>
</ul>
</p>

<h2 id="MEMORY_CACHE_ENABLED">オンメモリクエリキャッシュの有効化</h2>
<p>
オンメモリクエリキャッシュを有効にするには、pgpool.confの"memory_cache_enabled"を有効にします。
<pre>
memory_cache_enabled = true
</pre>
</p>

<h2 id="MEMQCACHE_METHOD">キャッシュストレージの選択</h2>
<p>
メモリキャッシュのストレージには、共有メモリと<a href="http://memcached.org">memcached</a>のどちらかを
選択することができます(併用はできません)。
<p>
共有メモリを使用するクエリキャッシュは高速で、memcachedの立ち上げも必要なく、手軽に利用できます。
ただし、共有メモリサイズの上限によって保存できるキャッシュの量に制限があります。
memcachedをキャッシュストレージに使用する場合は、ネットワークアクセスのオーバヘッドがあるものの、
比較的自由にキャッシュメモリの大きさを設定できます。
</p>
<p>
共有メモリを利用する場合は"memqcache_method"に 'shmem'、Memcachedを利用する場合は'memcached'と設定します。
デフォルトは、'shmem'です。
</p>

<h2 id="memqcache_cases">キャッシュが作成される場合と作成されない場合</h2>
<p>
すべてのSELECT(もしくはWITH)がオンメモリクエリキャッシュの対象になるわけではありません。
キャッシュとDBの一貫性を極力保つために、キャッシュされないケースがあります。以下それを列挙します。
</p>
<ul>
  <li>SELECT FOR SHAREまたはUPDATE</li>
  <li>IMMUTABLEでない関数を使っているSELECT</li>
  <li>一時テーブルを使っているSELECT</li>
  <li>システムカタログを検索しているSELECT</li>
  <li>VIEWを使っているSELECT</li>
  <li>明示的なトランザクション内でSELECTが発行され、そのトランザクションがアボートした時</li>
  <li><a href="#WHITE_MEMQCACHE_TABLE_LIST">white_memqcache_table_list</a>、
      <a href="#BLACK_MEMQCACHE_TABLE_LIST">black_memqcache_table_list</a>が指定されてい得る場合</li>
  <li>SELECT結果が大きい場合(<a href="#MEMQCACHE_MAXCACHE">memqcache_maxcache</a>の項参照)</li>
</ul>

<h2 id="non_memqcache_case">キャッシュがあっても参照されない場合</h2>
<p>
オンメモリクエリキャッシュが存在しても、そのキャッシュが利用されないケースがあります。
以下それを列挙します。
</p>
<ul>
  <li>明示的なトランザクション内で更新クエリが発行されている場合は、そのトランザクション内では
      一切クエリキャッシュは参照されません。</li>
  <li>そのキャッシュを違うユーザが作成していた場合(セキュリティ上の理由)</li>
  <li>キャッシュの寿命を超えていた場合(<a href="#MEMQCACHE_EXPIRE">memqcache_expireの項</a>を参照)</li>
</ul>

<h2 id="memqcache_params">共通設定項目</h2>
<p>
キャッシュストレージを共有メモリにする場合でも、memcachedにする場合でも、共通で設定する項目を説明します。
</p>

<dl>
<dt id="MEMQCACHE_EXPIRE">memqcache_expire</dt>
    <dd>
    <p>
    クエリキャッシュの寿命を秒単位で設定します。デフォルトは60です。
    0を指定すると寿命が無限大になり、関連テーブルが更新されるまではキャッシュが有効になります。
    なお、この設定は、<a href="#MEMQCACHE_AUTO_CACHE_INVALIDATION">memqcache_auto_cache_invalidation</a>とは
    独立です。
    </p>
    </dd>

<dt id="MEMQCACHE_AUTO_CACHE_INVALIDATION">memqcache_auto_cache_invalidation</dt>
    <dd>
    <p>
    trueならば関連するテーブルが更新されるとキャッシュを無効化します。
    falseならばテーブルが更新されてもキャッシュを無効化しません。
    デフォルト値はtrueです。
    なお、この設定は<a href="#MEMQCACHE_EXPIRE">memqcache_expire</a>の設定とは独立です。
    </p>
    </dd>

<dt id="WHITE_MEMQCACHE_TABLE_LIST">white_memqcache_table_list</dt>
    <dd>
    <p>
    SELECT結果をキャッシュしたいテーブル名をカンマ区切りで指定します。正規表現も利用できます。
    white_memqcache_table_listもblack_memqcache_table_listも初期値の''である場合は、
    すべてのテーブルがキャッシュの対象になります。
    </p>
    </dd>

<dt id="BLACK_MEMQCACHE_TABLE_LIST">black_memqcache_table_list</dt>
    <dd>
    <p>
    SELECT結果をキャッシュしたくないテーブル名をカンマ区切りで指定します。正規表現も利用できます。
    white_memqcache_table_listもblack_memqcache_table_listも初期値の''である場合は、
    すべてのテーブルがキャッシュの対象になります。
    </p>
    </dd>

<dt id="MEMQCACHE_MAXCACHE">memqcache_maxcache</dt>
    <dd>
    <p>
    SELECT文の実行結果がmemqcache_maxcacheを超えると、キャッシュされません。単位はバイトです。
    </p>
    </dd>

<dt id="MEMQCACHE_OIDDIR">memqcache_oiddir</dt>
    <dd>
    <p>
    SELECT文が使用するテーブルにOIDを格納する一時ファイル領域のトップディレクトリをフルパスで指定します。
    memqcache_oiddir以下には、データベースOID名のディレクトリが作成され、
    更にその下にはテーブルOID名のファイルが作成されます。
    テーブルOID名ファイルの中には、クエリキャッシュへのポインタが格納されており、
    テーブルの更新があった際にキャッシュを削除するキーとなります。
    この領域はpgpoolが再起動されると自動的に削除されます。
    </p>
    </dd>
</dl>

<h2 id="monitoring_memqcache">キャッシュのモニタリング</h2>
<p>
オンメモリクエリキャッシュをモニタする方法を説明します。
キャッシュから検索結果が取得されたかどうかは、<a href="#LOG_PER_NODE_STATEMENT">log_per_node_statement</a> を
有効にすることで確認できます。
</p>
<pre>
2012-05-01 15:42:09 LOG:   pid 20181: query result fetched from cache. statement: select * from t1;
</pre>

<p>
クエリキャッシュのヒット率は、show pool_statusコマンドで確認できます。
</p>
<pre>
memqcache_stats_start_time           | Tue May  1 15:41:59 2012 | Start time of query cache stats
memqcache_no_cache_hits              | 80471                    | Number of SELECTs not hitting query cache
memqcache_cache_hits                 | 36717                    | Number of SELECTs hitting query cache
</pre>


<p>
この例では、
</p>
<p>
<pre>
(memqcache_cache_hits) / (memqcache_no_cache_hits+memqcache_cache_hits) = 36717 / (36717 + 80471) = 31.3%
</pre>
<p>
がキャッシュヒット率ということになります。
</p>

<h2 id="shmem_params">共有メモリ設定項目</h2>
<p>
キャッシュストレージとして共有メモリを使用する場合の設定項目を説明します。
</p>

<dl>
<dt id="MEMQCACHE_TOTAL_SIZE">memqcache_total_size</dt>
    <dd>
    <p>
    キャッシュストレージに使用する共有メモリ領域のサイズを指定します。単位はバイトです。
    </p>
    </dd>

<dt id="MEMQCACHE_MAX_NUM_CACHE">memqcache_max_num_cache</dt>
    <dd>
    <p>
    キャッシュの数を指定します。
    この設定項目は、キャッシュの管理領域の大きさを決めるために使用します
    (<a href="MEMQCACHE_TOTAL_SIZE">memqcache_total_size</a>とは別に取られます)。
    管理領域の大きさは、memqcache_max_num_cache * 48(バイト)になります。
    この数は少なすぎるとキャッシュを登録することができずにエラーになります。
    逆に多すぎると無駄になります。
    </p>
    </dd>

<dt id="MEMQCACHE_CACHE_BLOCK_SIZE">memqcache_cache_block_size</dt>
    <dd>
    <p>
    キャッシュストレージとして共有メモリを使用する場合は、メモリを
    memqcache_cache_block_size のブロックに分けて利用します。検索結果
    のキャッシュはこのブロックに入るだけ詰め込まれます。
    ただし、キャッシュは複数のブロックにまたがって格納されないので、
    memqcache_cache_block_sizeを検索結果が超えると、キャッシュに格納できなくなります。
		この場合、以下のようなメッセージが表示されます。
    </p>
		<p>
		<pre>
		2012-05-02 15:08:17 LOG:   pid 13756: pool_add_temp_query_cache: data size exceeds memqcache_maxcache. current:4095 requested:111 memq_maxcache:4096
		</pre>
		</p>
    </dd>
</dl>

<h2 id="memcached_params">memcached設定項目</h2>
<p>
キャッシュストレージとしてmemcachedを使用する場合の設定項目を説明します。
</p>

<dl>
<dt id="MEMQCACHE_MEMCACHED_HOST">memqcache_memcached_host</dt>
    <dd>
    <p>
    memcachedが動いているホスト名またはIPアドレスを指定します。
    pgpool-IIと同じマシンでmemcachedを動かす場合は、'localhost'とします。
    </p>
    </dd>

<dt id="MEMQCACHE_MEMCACHED_PORT">memqcache_memcached_port</dt>
    <dd>
    <p>
    memcachedのポート番号を指定します。デフォルト値は 11211 です。
    </p>
    </dd>
</dl>

<h3 id="install_memcached">memcachedのインストール</h3>
<p>
pgpool-IIのクエリキャッシュストレージとしてmemcachedを使用する場合は、動作しているmemcachedと、
libmemcachedというクライアントライブラリのインストールが必要です。
rpmなどからインストールするのがおすすめですが、ここではソースコードからインストールする方法を説明します。
</p>
<p>
memcachedのソースコードは<a href="http://memcached.org/">memcached開発ページ</a>からダウンロードできます。
</p>

<dl>
<dt>configureの実行
    <dd>
    <p>
    ソースコードのtar ballを展開したら、configureを実行します。
    </p>
<pre>
./configure
</pre>
    </dd>

<dt>makeの実行
    <dd>
<pre>
make
make install
</pre>
    </dd>
</dl>

<h3 id="install_libmemcached">libmemcachedのインストール</h3>

<p>
memcachedのクライアントライブラリは、libmemcachedを使用しています。<br>
memcachedのインストール後に、libmemcachedをインストールする必要があります。
</p>

<p>
libmemcachedのソースコードは、<a href="http://libmemcached.org/libMemcached.html">libMemcached開発ページ</a>から
ダウンロードできます。
</p>

<dl>
<dt>configureの実行
    <dd>
    <p>
    ソースコードのtar ballを展開したら、configureを実行します。
    </p>
<pre>
./configure
</pre>

    <p>
    configureに指定できるオプションは以下です。
    </p>

    <ul>
    <li><code>--with-memcached=path</code><br/>
    Memcachedがインストールされているトップディレクトリを指定します。</li>
    </ul>
    </dd>

<dt>makeの実行
    <dd>
<pre>
make
make install
</pre>
    </dd>
</dl>

<!-- ================================================================================ -->

<h1>pgpool-IIの起動と停止<a name="start"></a></h1>
<p>
以上で設定が終わったので、各DBノードを起動し、必要ならばシステムDBも起動してからpgpool-IIを起動します。
</p>
<pre>
pgpool [-c][-f config_file][-a hba_file][-F pcp_config_file][-n][-D][-d]
</pre>

<table>
<tr><td>-c</td><td>クエリキャッシュを消去します</td></tr>
<tr><td>-f config_file</td><td>pgpool-IIの設定ファイルを指定します</td></tr>
<tr><td>-a hba_file</td><td>HBA認証設定ファイルを指定します</td></tr>
<tr><td>-F pcp_config_file</td><td>pcpの設定ファイルを指定します</td></tr>
<tr><td>-n</td><td>デーモンモードで起動しません(制御端末を切り離しません</td></tr>
<tr><td>-D</td><td>pgpool_statusを削除し、以前の状態を復元しません</td></tr>
<tr><td>-d</td><td>デバッグモードで起動します</td></tr>
</table>

<p>
pgpool-IIの停止は後述のpcpコマンドでもできますが、pgpool-IIコマンドを使うこと
もできます。
</p>
<pre>
pgpool [-f config_file][-F pcp_config_file] [-m {s[mart]|f[ast]|i[mmediate]}] stop
</pre>

<p>
<table>
<tr><td>-m s[mart]</td><td>接続中のクライアントが接続を終わるのを待ってから停止します(デフォルト)</td></tr>
<tr><td>-m f[ast]</td><td>接続中のクライアントが接続を終わるのを待たずに直ちに停止します</td></tr>
<tr><td>-m i[mmediate]</td><td>-m fと同じ動作です</td></tr>
</table>
</p>

<p id="pool_status_file">
pgpoolが停止すると、[logdir]/pgpool_statusというファイルにバックエンドの状態を書き込みます。
次回pgpoolが起動したときにこのファイルが存在すると、バックエンドの状態をそこから復元します。
これによって、
</p>

<ol>
<li>バックエンドが停止してフェイルオーバ</li>
<li>pgpool経由で正常なDBを更新</li>
<li>pgpoolを停止</li>
<li>停止していたDBを再起動</li>
<li>pgpoolを再起動</li>
</ol>

<p>
というシーケンスで、不整合のあるDBからレプリケーション状態に移行することを防ぐことができます。
</p>
<p>
もしもDBの状態に不整合がなくなっている、あるいはpgpool.confを書き換えて設定を変えてしまった、
というときはpgpool_statusを削除すればバックエンドの状態の復元を行いません。
</p>

<!-- ================================================================================ -->

<h1>pgpool-IIの設定ファイルの再読み込み<a name="reload"></a></h1>
<p>
pgpool-IIの設定ファイルは、pgpool-IIを再起動することなく読み直すことができます。
</p>
<pre>
pgpool [-f config_file][-a hba_file][-F pcp_config_file] reload
</pre>

<table>
<tr><td>-f config_file</td><td>pgpool-IIの設定ファイルを指定します</tr>
<tr><td>-a hba_file</td><td>HBA認証設定ファイルを指定します</tr>
<tr><td>-F pcp_config_file</td><td>pcpの設定ファイルを指定します</tr>
</table>

<p>
設定項目によっては、再読み込みを行なっても反映されないものがあるので、ご注意下さい。
また、設定の変更はすでに接続中のセッションには反映されません。
次回、クライアントがpgpool-IIに接続したときから反映されます。
</p>

<!-- ================================================================================ -->

<h1><a name="show-commands"></a>SHOWコマンド</h1>
<h2 id="show_commands">概要</h2>
<p>
pgpool-IIでは、SHOWコマンドを使って情報を参照することができます。
SHOWはSQLコマンドですが、pgpool-IIは一部のSHOWコマンドを独自に解釈して、pgpool-IIが管理する情報を返却します。
以下のようなものがあります。
</p>
<ul>
  <li>pool_status 構成情報</li>
  <li>pool_nodes DBノード情報</li>
  <li>pool_processes pgpool-IIプロセスの内部情報</li>
  <li>pool_pools コネクションプール情報</li>
  <li>pool_version pgpool-IIのバージョン</li>
</ul>

<p>"pool_status" SQL は以前からありますが、他のSQLはpgpool-II 3.0から追加されました。</p>
<p>
<u>注意</u>: "pool"という用語は、pgpoolプロセスによって所有されるPostgreSQLセッションを指します。
pgpoolによって所有されるセッション全体ではありません。
</p>

<h2 id="pool_status">pool_status</h2>
<p>"SHOW pool_status" は設定パラメータの名前と値、説明を表示します。出力の一部を示します。</p>
<pre>
benchs2=# show pool_status;
             item              |              value              |                           description
-------------------------------+---------------------------------+------------------------------------------------------------------
 listen_addresses              | 127.0.0.1                       | host name(s) or IP address(es) to listen to
 port                          | 9999                            | pgpool accepting port number
 socket_dir                    | /tmp                            | pgpool socket directory
 num_init_children             | 5                               | # of children initially pre-forked
 child_life_time               | 300                             | if idle for this seconds, child exits
</pre>

<h2 id="pool_nodes">pool_nodes</h2>
<p>"SHOW pool_nodes"は、DBノードのリストを表示します。
ホスト名、ポート番号、状態、重み(ロードバランスモードで運用しているときにのみ意味があります)、
ノードの役割が表示されます。
状態(status)の意味については、<a href="#pcp_node_info">pcp_node_infoリファレンス</a>で説明されています。
</p>
<pre>
benchs2=# show pool_nodes;
  id  |  hostname   | port | status | lb_weight |  role
------+-------------+------+--------+-----------+---------
   0  | 127.0.0.1   | 5432 | 2      | 0.5       | primary
   1  | 192.168.1.7 | 5432 | 3      | 0.5       | standby
(2 lignes)
</pre>

<h2 id="pool_processes">pool_processes</h2>
<p>"SHOW pool_processes"は、接続待ち、あるいは接続中pgpool-IIの子プロセスの状態を表示します。
</p>
<p>
6つのカラムがあります。
</p>
<ul>
    <li>pool_pid はpgpool-IIプロセスのプロセスIDです。</li>
    <li>start_timeはこのプロセスが起動された時刻です(1970年1月1日からの経過秒で表示されます)。</li>
    <li>databaseはこのプロセスが接続しているデータベース名です。</li>
    <li>usernameはこのプロセスの接続で使用しているユーザ名です。</li>
    <li>create_time isはこの接続が作成された時刻です。</li>
    <li>pool_counter はこの接続が使用された回数です。</li>
</ul>

<p>返却行数は常にnum_init_childrenになります。
また、データベース名などが表示されるのは、そのプロセスにフロントエンドからの接続がある場合に限ります。</p>
<pre>
benchs2=# show pool_processes;
 pool_pid |     start_time      | database | username  |     create_time     | pool_counter
----------+---------------------+----------+-----------+---------------------+--------------
 8465     | 2010-08-14 08:35:40 |          |           |                     |
 8466     | 2010-08-14 08:35:40 | benchs   | guillaume | 2010-08-14 08:35:43 | 1
 8467     | 2010-08-14 08:35:40 |          |           |                     |
 8468     | 2010-08-14 08:35:40 |          |           |                     |
 8469     | 2010-08-14 08:35:40 |          |           |                     |
(5 lines)
</pre>

<h2 id="pool_pools">pool_pools</h2>
<p>"SHOW pool_pools"は、pgpool-IIのコネクションプールの状態を表示します。
</p>
<p>
11のカラムがあります。
</p>

<ul>
    <li>start_timeはこのプロセスが起動された時刻です(1970年1月1日からの経過秒で表示されます)。</li>
    <li>pool_pid はpgpool-IIプロセスのプロセスIDです。</li>
    <li>pool_id はコネクションプールIDです。(0からmax_pool-1の値です)</li>
    <li>backend_id はPostgreSQLバックエンドの識別子です(0からバックエンド数-1の値です)</li>
    <li>databaseはこのプロセスが接続しているデータベース名です。</li>
    <li>usernameはこのプロセスの接続で使用しているユーザ名です。</li>
    <li>create_time isはこの接続が作成された時刻です。</li>
    <li>majorversion と minorversion はこの接続で使用されているプロトコルバージョン番号です。</li>
    <li>pool_counter はこの接続が使用された回数です。</li>
    <li>pool_backendpid は PostgreSQL のバックエンドプロセスのプロセスIDです。</li>
    <li>pool_connected は真偽値で、0ならフロントエンドからの接続無し、1なら接続ありを表します。</li>
</ul>

<p>返却行数は常に<a href="#NUM_INIT_CHILDREN">num_init_children</a> * <a href="#MAX_POOL">max_pool</a>になります。
<pre>
benchs2=# show pool_pools;
  pool_pid |     start_time      | pool_id | backend_id | database | username  |     create_time     | majorversion | minorversion | pool_counter | pool_backendpid | pool_connected
----------+---------------------+---------+------------+----------+-----------+---------------------+--------------+--------------+--------------+-----------------+----------------
 8465     | 2010-08-14 08:35:40 | 0       | 0          |          |           |                     |              |              |              |                 |
 8465     | 2010-08-14 08:35:40 | 1       | 0          |          |           |                     |              |              |              |                 |
 8465     | 2010-08-14 08:35:40 | 2       | 0          |          |           |                     |              |              |              |                 |
 8465     | 2010-08-14 08:35:40 | 3       | 0          |          |           |                     |              |              |              |                 |
 8466     | 2010-08-14 08:35:40 | 0       | 0          | benchs   | guillaume | 2010-08-14 08:35:43 | 3            | 0            | 1            | 8473            | 1
 8466     | 2010-08-14 08:35:40 | 1       | 0          |          |           |                     |              |              |              |                 |
 8466     | 2010-08-14 08:35:40 | 2       | 0          |          |           |                     |              |              |              |                 |
 8466     | 2010-08-14 08:35:40 | 3       | 0          |          |           |                     |              |              |              |                 |
 8467     | 2010-08-14 08:35:40 | 0       | 0          |          |           |                     |              |              |              |                 |
 8467     | 2010-08-14 08:35:40 | 1       | 0          |          |           |                     |              |              |              |                 |
 8467     | 2010-08-14 08:35:40 | 2       | 0          |          |           |                     |              |              |              |                 |
 8467     | 2010-08-14 08:35:40 | 3       | 0          |          |           |                     |              |              |              |                 |
 8468     | 2010-08-14 08:35:40 | 0       | 0          |          |           |                     |              |              |              |                 |
 8468     | 2010-08-14 08:35:40 | 1       | 0          |          |           |                     |              |              |              |                 |
 8468     | 2010-08-14 08:35:40 | 2       | 0          |          |           |                     |              |              |              |                 |
 8468     | 2010-08-14 08:35:40 | 3       | 0          |          |           |                     |              |              |              |                 |
 8469     | 2010-08-14 08:35:40 | 0       | 0          |          |           |                     |              |              |              |                 |
 8469     | 2010-08-14 08:35:40 | 1       | 0          |          |           |                     |              |              |              |                 |
 8469     | 2010-08-14 08:35:40 | 2       | 0          |          |           |                     |              |              |              |                 |
 8469     | 2010-08-14 08:35:40 | 3       | 0          |          |           |                     |              |              |              |                 |
(20 lines)
</pre>

<h2 id="pool_version">pool_version</h2>
<p>"SHOW pool_version" はpgpool-IIのバージョン情報を表示します。
例を示します。
</p>
<pre>
benchs2=# show pool_version;
      pool_version
------------------------
 3.0-dev (umiyameboshi)
(1 line)
</pre>


<!-- ================================================================================ -->

<h1><a name="online-recovery"></a>オンラインリカバリ</h1>
<h2>オンラインリカバリ概要</h2>
<p>
この章では、レプリケーションモードで利用する場合のオンラインリカバリ機能
について説明します。
マスタ／スレーブモード(Streaming Replication)でのオンラインリカバリの利用方法については、
<a href="#stream">Streaming Replicationへの対応</a>をご覧下さい。
レプリケーションモードで pgpool が動作している場合、ダウンしたノードのデータを再同期させた上で、
ノードを復帰させることができます。この機能を「オンラインリカバリ」と呼びます。
</p>

<p>
オンラインリカバリを実施するためには、ノードが切り離されていると
pgpool が検知している必要があります。ノードを動的に追加したい場合には
pgpool.conf の backend_hostnameなどのパラメータを追加しておき、
設定ファイルを再読み込みさせると、ノードが切り離された状態で pgpool にノード情報が登録されます。
</p>

<p>
また、リカバリするノードの PostgreSQL がすでに動作中であれば、あらかじめ
PostgreSQL をシャットダウンさせておいてください。
</p>

<!--
<p>
<font color="red">注意: オンラインリカバリを実行する前に、マスタノード
(稼働中のノードのうち、一番番号が若いノード)上でのautovacuumを停止してください。
オンラインリカバリ中にautovacuumが動くと、データベースの内容が変化する可能性があるため、
ノード間の同期がきちんと取れなくなる可能性があります。
この制限は、rsyncなどの単純なコピー方法を使っている場合にのみ適用されます。
PostgreSQLのPITRを使っている場合は適用されません。
</font>
</p>
-->

<p>
pgpool ではオンラインリカバリを 2 段階に分けて実施します。
pgpool のクライアントからは完全なデータの同期を取るために若干の接続待ちが発生します。
リカバリ手順で以下の通りです。
</p>

<ol>
    <li>CHECKPOINT 実行</li>
    <li>ファーストステージの実施</li>
    <li>接続がすべて切断されるまで待機</li>
    <li>CHECKPOINT 実行</li>
    <li>セカンドステージの実施</li>
    <li>postmaster の起動(pgpool_remote_start の実行)</li>
    <li>ノードの復帰</li>
</ol>

<p>
データ同期の第一段階を「ファーストステージ」と呼びます。ファーストステージ中に1 回目のデータ同期を行います。
ファーストステージ中はデータの更新や参照を並行して行うことができます。
</p>

<p>
ファーストステージで処理する内容はユーザが定義することができます。
スクリプトでは 3 つの引数を受け取ることができます。
</p>
<ol>
    <li>マスタのデータベースクラスタパス</li>
    <li>リカバリノードのホスト名</li>
    <li>リカバリノードのデータベースクラスタパス</li>
</ol>

<p>
次に 2 回目のデータ同期を行います。これを「セカンドステージ」と呼びます。
pgpool ではセカンドステージに入る前に接続中のクライアントがすべて接続が終了されるまで待ちます。
その間に接続リクエストが来た場合には、その接続をすべてブロックします。
</p>

<p>
セカンドステージで処理する内容はユーザが定義することができます。
スクリプトでは 3 つの引数を受け取ることができます。
</p>
<ol>
    <li>マスタのデータベースクラスタパス</li>
    <li>リカバリノードのホスト名</li>
    <li>リカバリノードのデータベースクラスタパス</li>
</ol>

<p>
すべての接続が終了されると、ファーストステージ以降に更新されたデータを同期するための
セカンドステージが開始されます。そこで最終的なデータの同期を行います。
この間はクライアントからは pgpool への接続が待たされる状態になります。
</p>

<p>
<font color="red">
なお、オンラインリカバリの制限事項として、複数のホストに pgpool を配置して
レプリケーションさせている場合には、オンラインリカバリは正しく動作しません。
どれかの pgpool にリカバリリクエストを出した時に、他の pgpool から更新が伝搬すると、
データを同期させることができなく
なります。
</font>
</p>

<h2 id="online_recovery_params">pgpool の設定</h2>
<p>
オンラインリカバリを設定するためには、pgpool.conf の以下の値を設定してください。
</p>

<ul>
    <li><a href="#BACKEND_DATA_DIRECTORY">backend_data_directory</a></li>
    <li><a href="#RECOVERY_USER">recovery_user</a></li>
    <li><a href="#RECOVERY_PASSWORD">recovery_password</a></li>
    <li><a href="#RECOVERY_1ST_STAGE_COMMAND">recovery_1st_stage_command</a></li>
    <li><a href="#RECOVERY_2ND_STAGE_COMMAND">recovery_2nd_stage_command></a></li>
</ul>

<h2 id="installing-c-functions">C 言語関数のインストール</h2>
<p>
次に、リカバリを実施するための PostgreSQL の C 言語関数を各ノードの
template1 データベースにインストールします。ソースコードは
</p>

<pre>
pgpool-II-x.x.x/sql/pgpool-recovery/
</pre>

<p>
にあります。ディレクトリを移動し、make install してください。
</p>

<pre>
% cd pgpool-II-x.x.x/sql/pgpool-recovery/
% make install
</pre>

<p>
C 言語関数のモジュールをインストールしたら、続いて C 言語関数を呼びだすための SQL をインストールします。
</p>

<pre>
% cd pgpool-II-x.x.x/sql/pgpool-recovery/
% psql -f pgpool-recovery.sql template1
</pre>

<h2 id="recovery_script">リカバリスクリプトの配置</h2>
<p>
データを同期させるためのスクリプトと、リモートから postmaster を再起動させるためのスクリプトを
各ノードの $PGDATA 以下に配置します。
あらかじめpgpool-II-x.x.x/sample 以下にサンプルスクリプトも用意してありますので参考にしてください。
ここではサンプルスクリプトを使って、PITR によるリカバリ方法と、rsync によるリカバリ方法を説明します。
</p>

<h3 id="recovery_pitr">PITR によるリカバリ</h3>
<p>
ここでは PostgreSQL 8.2 以降で PITR 機能を使ってリカバリをする設定例を説明します。
PITR によるリカバリをする場合にはあらかじめ PostgreSQL の設定で
ログをアーカイブさせるようにしておいてください。
</p>

<p>
まずファーストステージでベースバックアップを取得し、リカバリ先へコピーするスクリプト
(ここではファイル名を copy-base-backup とします)を用意します。
例えば以下のようなスクリプトで取得することができます。
</p>

<pre>
#! /bin/sh

DATA=$1
RECOVERY_TARGET=$2
RECOVERY_DATA=$3

psql -c "select pg_start_backup('pgpool-recovery')" postgres
echo "restore_command = 'scp $HOSTNAME:/data/archive_log/%f %p'" &gt; /data/recovery.conf
tar -C /data -zcf pgsql.tar.gz pgsql
psql -c 'select pg_stop_backup()' postgres
scp pgsql.tar.gz $RECOVERY_TARGET:$RECOVERY_DATA
</pre>

<p>
ベースバックアップ取得時に recovery.conf を生成しておきます。
</p>
<pre>
restore_command = 'scp master:/data/archive_log/%f %p'
</pre>

<p>
セカンドステージでは最新の状態まで PITR によるリカバリを実施できるようにするために、
pgpool_recovery_pitr スクリプトを$PGDATA にコピーします。
このスクリプトではトランザクションログを強制的に切り替えるようにします。
</p>
<p>
通常、トランザクションログを切り替えるには、pg_switch_xlog 関数を利用しますが、
この関数は、アーカイブログファイルが生成される前に終了してしまう可能性があります。
</p>
<p>
そこで、より安全にオンラインリカバリを行うために
pgpool_switch_xlog 関数が用意されています。
pgpool_switch_xlog 関数の基本動作は pg_switch_xlog 関数と同じですが、
トランザクションログの切り替えによるアーカイブログファイルの生成を
待ってから終了します。
この関数は、前述の「C言語関数のインストール」を実施するとインストールされ、
引数にはアーカイブログの出力先ディレクトリを指定します。
</p>
<p>
<pre>
#! /bin/sh
# Online recovery 2nd stage script
#
datadir=$1       # master dabatase cluster
DEST=$2          # hostname of the DB node to be recovered
DESTDIR=$3       # database cluster of the DB node to be recovered
port=5432        # PostgreSQL port number
archdir=/data/archive_log    # archive log directory

# Force to flush current value of sequences to xlog 
psql -p $port -t -c 'SELECT datname FROM pg_database WHERE NOT datistemplate AND datallowconn' template1|
while read i
do
  if [ "$i" != "" ];then
    psql -p $port -c "SELECT setval(oid, nextval(oid)) FROM pg_class WHERE relkind = 'S'" $i
  fi
done

psql -p $port -c "SELECT pgpool_switch_xlog('$archdir')" template1
</pre>

<p>
スクリプト中のwhileループは、全データベース中のシーケンス値をトランザクションログに吐き出します。
これによって、シーケンスも正しくリカバリされるようになります。
</p>

<p>
スクリプトの配置が完了したら pgpool.conf に設定します。
</p>

<pre>
recovery_1st_stage_command = 'copy-base-backup'
recovery_2nd_stage_command = 'pgpool_recovery_pitr'
</pre>

<p>
これで PITR によるオンラインリカバリの準備が完了です。
</p>

<h4 id="pool_remote_start">pgpool_remote_start</h4>
<p>
データ再同期後に postmaster を起動させるスクリプトです。
pgpool からは以下の形式でスクリプトを実行します。
</p>

<pre>
% pgpool_remote_start remote_host remote_datadir
remote_host:    リカバリノードのホスト名
remote_datadir: リカバリノードのデータベースクラスタパス
</pre>

<p>
サンプルスクリプトでは ssh 経由で postmaster を起動しています。
こちらもあらかじめパスフレーズ無しで ssh 経由でログインできるように設定しておく必要があります。
</p>

<p>
PITR によるリカバリであれば、pgpool_remote_start 内でベースバックアップを展開し、
recovery.conf の内容にしたがってリカバリした後にpostmaster が接続可能状態になります。
</p>

<pre>
#! /bin/sh
DEST=$1
DESTDIR=$2
PGCTL=/usr/local/pgsql/bin/pg_ctl

# Expand a base backup
ssh -T $DEST 'cd /data/; tar zxf pgsql.tar.gz' 2&gt;/dev/null 1&gt;/dev/null &lt; /dev/null
# Startup PostgreSQL server
ssh -T $DEST $PGCTL -w -D $DESTDIR start 2&gt;/dev/null 1&gt;/dev/null &lt; /dev/null &amp;
</pre>

<h3 id="recovery_rsync">rsync によるリカバリ </h3>
<p>
7.4 以前の場合は PITR 機能がありません。また、8.0 と 8.1 の場合は
トランザクションログを強制的に切り替える関数が用意されていません。
そこで PITR を使わずにrsync を使ったリカバリ方法を説明します。
</p>
<p>
sample ディレクトリに pgpool_recovery というファイルがあります。
マスタから復帰させるノードへのデータの物理コピーを行うスクリプトです。
pgpool からは以下の形式でスクリプトを実行します。
</p>

<pre>
% pgpool_recovery datadir remote_host remote_datadir
datadir:        マスタのデータベースクラスタパス
remote_host:    リカバリノードのホスト名
remote_datadir: リカバリノードのデータベースクラスタパス
</pre>

<p>
サンプルスクリプトでは rsync を使って物理コピーをしています。もし
rsync を使う場合は、パスフレーズ無しで ssh 経由でログインできるように
あらかじめ設定しておく必要があります。
</p>

<p>
rsyncに関する注記:
</p>
<ul>
    <li>-c (or --checksum) オプションを付けないと、ファイルが確実に転送されない場合があります。</li>
    <li>-z (or --compress)オプションは低速なネットワークでは効果がありますが、
        100M以上の高速なネットワークではかえってCPU負荷を増やし、結果的に遅くなることがあります。
        高速ネットワークでは、このオプションを使用しないことをお勧めします。
    </li>
    <li>rsync の新しいバージョン(3.0.5)では、50%も性能が良くなったという報告が
        pgpool-generalメーリングリストでありました。
     </li>
</ul>

<p>
pgpool_recovery を使う場合は pgpool.conf に以下の行を追加してください。
</p>

<pre>
recovery_1st_stage_command = 'pgpool_recovery'
recovery_2nd_stage_command = 'pgpool_recovery'
</pre>

<h2 id="perform_online_recovery">リカバリの実行</h2>
<p>
以上でオンラインリカバリの準備が整いました。
オンラインリカバリを実行するには <a href="#pcp_recovery_node">pcp_recovery_node</a> コマンドを使うか、
pgpool 管理ツールから実行してください。
</p>

<p>
注意点として、<a href="#pcp_recovery_node">pcp_recovery_node</a> を実行する際に、タイムアウトを長くして
ください。pgpoolAdmin から実行する場合は pgmgt.conf.php 内の
_PGPOOL2_PCP_TIMEOUT を大きくしてください。
</p>

<h2 id="minorup_w_online_recovery">オンラインリカバリを利用したPostgreSQLのマイナーバージョンアップ</h2>
<h3>レプリケーションモードの場合</h3>
<p>
レプリケーションモードでpgpool-IIが動作している場合は、
オンラインで各ノードのPostgreSQLをバージョンアップできます。
ただし、ノードの切り離し時と追加時に、pgpool-IIに接続しているすべての
すべてのセッションが切断されるので注意してください。
また、オンラインリカバリが利用できるバージョンアップはマイナーバージョンアップのみで、
ダンプ/リストアが不要なリリースに限ります。
</p>

<p>
はじめに、上記の「オンラインリカバリの概要」を参考に各ノードでオンラインリカバリが利用できるように準備します。
</p>

<p>
PostgreSQLのバージョンアップは、マスタ以外のノードから行い、最後にマスタノードをバージョンアップします。
そこで、まずバージョンアップを行うマスタ以外の１つのノードのPostgreSQLを停止します。
pgpool-IIがPostgreSQLの停止を検知すると、以下のようなログを出力して縮退運転に移行します。
その際、pgpool-IIに接続しているすべてのセッションは一旦切断されます。
</p>
<pre>
2010-07-27 16:32:29 LOG:   pid 10215: set 1 th backend down status
2010-07-27 16:32:29 LOG:   pid 10215: starting degeneration. shutdown host localhost(5433)
2010-07-27 16:32:29 LOG:   pid 10215: failover_handler: set new master node: 0
2010-07-27 16:32:29 LOG:   pid 10215: failover done. shutdown host localhost(5433)
</pre>

<p>
停止したノードのPostgreSQLをバージョンアップします。
バージョンアップは、新しいバージョンのPostgreSQLを古いバージョンのインストール先に上書きしても構いませんが、
問題が起きた時に元のバージョンに戻せるようにインストール先を変えておくことをお勧めします。
</p>

<p>
新しいバージョンのPostgreSQLを古いバージョンと別の場所にインストールした場合、
リカバリスクリプトを編集することなくそのまま使用するには、シンボリックリンクなどを使用してインストール先のパスを以前と合わせる必要があります。
上書きインストールした場合は以下のC言語関数をインストールするまでの操作は不要です。
すぐにオンラインリカバリが実行できます。
</p>

<p>
古いバージョンのPostgreSQLのインストール先ディレクトリ名を変更します。
以下は、PostgreSQLが/usr/local/pgsqlにインストールされていたと仮定した一例です。
</p>
<pre>
$ mv /usr/local/pgsql /usr/local/pgsql-old
</pre>

<p>
新しいバージョンのPostgreSQLのインストール先にシンボリックリンクを作成します。
これにより、今までどおりのパスで新しいバージョンのPostgreSQLが使用できるようになります。
以下は、新しいバージョンのPostgreSQLが/usr/local/pgsql-newにインストールされていると仮定した一例です。
</p>
<pre>
$ ln -s /usr/local/pgsql-new /usr/local/pgsql
</pre>

<p>
データベースクラスタディレクトリがPostgreSQLのインストール先ディレクトリの下位にある場合は、
同じパスでデータベースクラスタにアクセスできるようにシンボリックリンクを作成するかコピーします。
以下は、シンボリックリンクを作成する例です。
</p>
<pre>
$ ln -s /usr/local/pgsql-old/data /usr/local/pgsql/data
</pre>

<p>
新しいバージョンのPostgreSQLに、オンラインリカバリ用の関数を
「C言語関数のインストール」を参考にインストールします。
オンラインリカバリは、データベースクラスタをコピーしますので、最後のpsqlを使用した関数の作成は不要です。
make installを実行してください。
</p>

<p>
最後にオンラインリカバリを実行して、１つのノードのバージョンアップが完了します。
オンラインリカバリは、pcp_recovery_nodeコマンドを実行するかpgpoolAdminで行います。
</p>

<p>
以上の手順をマスタ以外のノードで繰り返し、最後にマスタノードで行えば、
全体のPostgreSQLのマイナーバージョンアップは完了です。
</p>

<h3>Streaming Replicationを利用している場合</h3>
<p>
マスタースレーブモードでStreaming Replicationを利用している場合は、
オンラインでスタンバイのPostgreSQLをマイナーバージョンアップできます。
</p>

<p>
スタンバイのPostgreSQLをマイナーバージョンアップする手順は、上記のレプリケーションモードの手順と同じです。
ただし、recovery_1st_stage_commandとrecovery_2nd_stage_commandの設定などは、
「Streaming Replicationでのオンラインリカバリ」を参考にしてください。
</p>

<p>
プライマリのPostgreSQLのマイナーバージョンアップは、オンラインではできません。
pgpool-IIの停止が必要になります。
プライマリのPostgreSQLもバージョンアップの方法自体は、スタンバイと同様です。
プライマリのPostgreSQLのバージョンアップは以下の手順で行います。
<ol>
<li>pgpool-IIを停止
<li>プライマリのPostgreSQLを停止
<li>プライマリのPostgreSQLをバージョンアップ
<li>プライマリのPostgreSQLを起動
<li>pgpool-IIを起動
</ol>
</p>

<!-- ================================================================================ -->

<h1><a name="backup"></a>バックアップ</h1>
<p>
バックエンドとシステムDBのPostgreSQLのバックアップは、単体のPostgreSQLと同様に、
物理バックアップ、論理バックアップ(pg_dump, pg_dumpall)、PITRが使用できます。
ただし、論理バックアップとPITRの操作は、pgpool-IIを経由せずにPostgreSQLに対して直接行ってください。
これは、<a href="#LOAD_BALANCE_MODE">load_balance_mode</a>や<a href="#REPLICATE_SELECT">replicate_select</a>などの
設定によるバックアップの失敗を避けるためです。
</p>

<h2 id="backup_rep_or_ms_mode">レプリケーションモード、マスタースレーブモード</h2>
<p>
レプリケーションモードとマスタースレーブモードでpgpool-IIが動作している場合は、
クラスタを構成しているいずれかのノードでバックアップを行います。
</p>

<p>
マスタースレーブモードで非同期のレプリケーションを行っている場合で、かつ、
最新のバックアップを取得したい場合は、マスタノードでバックアップしてください。
</p>

<p>
バックアップ時の注意点として、PostgreSQLに対してpg_dumpコマンドなどを実行すると、
ACCESS SHAREモードのロックがかかります。
そのため、ACCESS SHAREモードと競合するACCESS EXCLUSIVEロックが必要になるコマンド
（ALTER TABLE、DROP TABLE、TRUNCATE、REINDEX、CLUSTERおよびVACUUM FULLなど）は、ロック待ちが発生します。
これは、非同期のレプリケーションで、スレーブノードに対してバックアップを行っている場合も、
マスタが影響を受けることがありますので注意してください。
</p>

<h2 id="backup_parallel">パラレルモード</h2>
<p>
パラレルモードでpgpool-IIが動作している場合、クラスタ全体のデータが一貫性のある状態でバックアップを取得するには、
アプリケーション、またはpgpool-IIの一時的な停止が必要になります。
</p>

<p>
論理バックアップを利用する場合は、アプリケーション、またはpgpool-IIを停止し、
すべてのノードでpg_dump, pg_dumpallコマンドを実行します。
そして、すべてのノードでダンプが終了したら、アプリケーション、またはpgpool-IIを起動してください。
</p>

<p>
PITRを利用する場合は、まず各ノードのシステムの時刻がほぼ一致していることを確認してください。
そして、事前に各ノードでアーカイブログの設定を行い、ベースバックアップを取得します。
ベースバックアップが終了したら、アプリケーション、またはpgpool-IIを一時的に停止します。
停止後、その時刻と次に起動した時刻を記録します。
この一時的な停止によって、クラスタ全体のデータが一貫性のある状態を保った期間ができます。
ベースバックアップとアーカイブログを使用して各ノードをリストアする場合は、
一時停止期間の真ん中あたりの時刻をrecovery.confのrecovery_target_timeに指定したうえで、リカバリを行ってください。
</p>

<h2 id="backup_system_db">システムDBのバックアップ</h2>
<p>
パラレルクエリモード、またはクエリキャッシュを使用している場合は、システムDBもバックアップする必要があります。
pgpool.confのsystem_db_dbnameに設定したデータベースをバックアップしてください。
</p>

<!-- ================================================================================ -->

<h1><a name="deploy"></a>pgpool-IIの配置について</a></h1>
<p>
pgpool-IIは、独立したサーバに配置することもできますし、アプリケーションサーバと同居させることもできますし、
その他の配置も考えられます。
ここではそれぞれの配置方法を紹介し、それぞれの特徴、メリット、デメリットを検討します。
</p>

<ul>
<dt>専用のサーバに配置
    <dd>
    <p>
    pgpool-IIを物理的に独立した専用のサーバに配置する方法です。
    分かりやすい方法ですし、他のサーバソフトウェアの影響を受けないのでpgpool-IIをもっとも安全に運営できますが、
    サーバ装置を1台余計に増やす必要があるのが欠点です。
    また、そのサーバが単一障害点になります(pgpool-IIが単一障害点になることを回避するには、
    後述のpgpool-HAを併用します)。
    </p>
    </dd>

<dt>Webサーバやアプリケーションサーバと同居
    <dd>
    <p>
    Apache、JBoss、TomcatなどのWebサーバやアプリケーションサーバが稼働しているサーバに
    pgpool-IIを同居させる方法です。
    この方法では、Webサーバやアプリケーションサーバとpgpool-IIの通信がローカルマシン内になるので、
    ソケット通信がマシン間で通信するよりも高速になるメリットがあります。
    また、複数のWebサーバ／アプリケーションサーバがあれば、自然と単一障害点を回避できるようになります。
    (この場合、複数のpgpool-IIの設定は同じにしてください)。
    なお、複数のpgpool-IIが動作しているケースでは以下の点に注意してください。
    </p>
    <ul>
        <li>pgpool-IIとDBサーバの間のネットワークが不安定だと、pgpool-IIから見てDBノード#1がダウン、
            他のpgpool-IIから見て正常、というような状態になってしまうことがあります。
            ネットワークを二重化するなどして、ネットワーク障害が起きないようにしてください。
        </li>
        <li>レプリケーションモードで、オンラインリカバリ実行中は、一つのpgpool-IIだけ残して
            他のpgpool-IIを落してください。
            さもないと、リカバリ後の結果に整合性がなくなる可能性があります。
            マスター／スレーブモード+Streaming Replicationモードでは、同時に複数のpgpool-IIで
            オンラインリカバリを実行しない限り、問題ありません。
        </li>
    </ul>
    </dd>

<dt>DBサーバと同居
    <dd>
    <p>
    PostgreSQLの稼働しているDBサバと同居させる方法です。
    この方法では、pgpool-IIが単一障害点になることがなく、余計なサーバを追加する必要もない点が優れていますが、
    アプリケーションがどのDBサーバに接続するのかを自ら判断する必要があるのが欠点です。
    この問題を解決するには、pgpool-HAと組み合わせて仮想IPを利用します。
    </p>
    </dd>
</ul>

<h2 id="pgpool_ha">pgpool-HAについて</h2>
<p>
pgpool-HAは、heartbeatなどを利用してpgpool-IIを二重化し、pgpool-II自体の可用性を上げるソフトウェアです。
pgpool-IIと同様、pgpoolプロジェクトのサブプロジェクトであり、pgpoolの開発サイトでOSSとして公開されています。
</p>

<!-- ================================================================================ -->

<h1><a name="troubleshooting"></a>トラブルシューティング</h1>
<p>
この章では、pgpool-IIを運用中に直面しやすい障害と、その対策方法をケース別に説明します。
</p>

<dl>
<dt id="health_check_failed">health check failed</dt>
    <dd>
    <p>
    ヘルスチェックでpgpool-IIがDBノードの障害を検出しました。
    </p>
<pre>
2010-07-23 16:42:57 ERROR: pid 20031: health check failed. 1 th host foo at port 5432 is down
2010-07-23 16:42:57 LOG:   pid 20031: set 1 th backend down status
2010-07-23 16:42:57 LOG:   pid 20031: starting degeneration. shutdown host foot(5432)
2010-07-23 16:42:58 LOG:   pid 20031: failover_handler: set new master node: 0
2010-07-23 16:42:58 LOG:   pid 20031: failover done. shutdown host foo(5432)
</pre>
    <p>
    このログは、DBノード1(ホスト名 foo)がダウンして切り離され、
    新しくDBノード0がマスタとして扱われ出したことを示しています。
    DBノード1をチェックし、異常原因を取り除いた後に、可能であればオンラインリカバリ機能を使っ
    てDBノード1を復帰させてください。
    </p>
    </dd>

<dt id="failed_to_read_kind_from_frontend">failed to read kind from frontend</dt>
    <dd>
<pre>
2010-07-26 18:43:24 LOG:   pid 24161: ProcessFrontendResponse: failed to read kind from frontend. frontend abnormally exited
</pre>
    <p>
    pgpool-IIから見てクライアントが突然セッションを切断した際にこのようなログが残ります。
    原因としては、アプリケーションのバグ、アプリケーションが強制終了された、
    やネットワークの一時的な障害が考えられます。
    このログが出ても、DBが壊れるとか一貫性がなくなるような問題は起きませんが、
    継続してこのログが出力されるようであれば、アプリケーションやネットワークの障害を調査することをおすすめします。
    </p>
    </dd>

<dt id="kind_mismatch">kind mismatchエラー</dt>
    <dd>
    <p>
    レプリケーションモードで運用している場合に出ることがあるエラーです。
    </p>
<pre>
2010-07-22 14:18:32 ERROR: pid 9966: kind mismatch among backends. Possible last query was: "FETCH ALL FROM c;" kind details are: 0[T] 1[E: cursor "c" does not exist]
</pre>
    <p>
    pgpool-IIは、SQLコマンドを各DBノードに送信したら、各DBノードから同じレスポンスが返ってくることを期待します。
    このエラーは、異なるレスポンスが返ってきたことを示します。
    Possible last query was:のあとに、このエラーを返す原因となった問い合わせのSQL文が表示されます。
    そのあとで、各DBノードからのレスポンスの種類と、レスポンスがエラーの場合は、
    PostgreSQLのエラーメッセージが表示されます。
    ここでは、"0[T]"により、0番目のDBノードが"T"(行情報の開始)という応答を返したこと、
    一方"1[E"で、DBノード1がエラーを返したとこと、そのエラーメッセージは
    「cursor "c" does not exist」であったことがわかります。
    <p>
    注意: このエラーは、マスタースレーブモードでも出ることがあります。
    たとえば、SETコマンドは、各セッションの状態を同じにするために、基本的にすべてのDBノードに送信されるからです。
    </p>
    <p>
    データベースを調べて原因を特定し、もしDBの同期が崩れているようであれば、
    オンラインリカバリを使って正しいデータと同期させてください。
    </p>
    </dd>

<dt id="difference_of_number">pgpool detected difference of the number of inserted, updated or deleted tuples</dt>
    <dd>
    <p>
    レプリケーションモードにおいて、pgpool-IIが、DBノード間でINSERT/UPDATE/DELETEが返す結果行の違いを検出しました。
    </p>
<pre>
2010-07-22 11:49:28 ERROR: pid 30710: pgpool detected difference of the number of inserted, updated or deleted tuples. Possible last query was: "update t1 set i = 1;"
2010-07-22 11:49:28 LOG:   pid 30710: ReadyForQuery: Degenerate backends: 1
2010-07-22 11:49:28 LOG:   pid 30710: ReadyForQuery: Affected tuples are: 0 1
</pre>
    <p>
    この例では、update t1 set i = 1によって更新された行数が、DBノードで異なっています。
    また、次の行では、DBノード1を切り離したこと、更にDBノード0での結果行数が0だったのに対して、DBノード1では、1行だったことを表しています。
    </p>
    <p>
    正しくないデータを持っていると思われるDBノードを停止し、オンラインリカバリを使って
    正しいデータと同期させてください。
    </p>
    </dd>
</dl>

<!-- ================================================================================ -->

<h1>制限事項<a name="restriction"></a></h1>
<p>
<h2>PostgreSQLの機能</h2>
<ul>
    <li>pg_terminate_backend()でバックエンドを終了させるとフェイルオーバしてしまいます。
        これは、PostgreSQLがpostmasterをシャットダウンしたときと同じメッセージをpgpoolに送るためです。
        今のところ対応方法はないので、この関数を使わないようにしてください。
    </li>
</ul>

<h2><a name="md5"></a>認証・アクセス制御方式</h2>
<p>
<ul>
    <li>レプリケーションモードまたマスタ/スレーブモード時にはtrust, reject, clear
        text password, pam, 認証方式だけが利用できます。
        crypt認証は利用できません。
        md5認証に関しては、PostgreSQLに該当ユーザをmd5認証付でPostgreSQLに登録し、
        次にpgpoolに付属するpg_md5コマンドを使って、pool_passwdという認証ファイルを作成することにより
        利用できるようになります。
        <ol>
        <li>DBユーザのアカウントでログインし、"pg_md5 --md5auth パスワード"
            または "pg_md5 --md5auth --username=ユーザ名 パスワード" を実行します。
        </li>
        <li>md5により暗号化されたユーザ名とパスワードがpool_passwdに登録されます。
            pool_passwdがまだ存在しなければ、pgpool.confと同じディレクトリ内に作成されます。
        </li>
        <li>pool_passwdのフォーマットは、"ユーザ名:パスワード"となっています。
        </li>
        <li>pool_hba.confにmd5認証のエントリを作成します。
            pool_hba.confについては、<a href="#hba">クライアント認証(HBA)のためのpool_hba.conf設定方法</a>
            を参照してください。
        </li>
        <li>注意事項: pool_passwdに登録するパスワードは、PostgreSQLに登録したパスワードと
            完全に同じでなければなりません。
        </li>
        <li>pool_passwdとPostgreSQLのmd5パスワードを変更したら、pgpool reload を実行してください。
            pgpool-II 3.1またはそれよりも以前のバージョンでは、pgpool-IIの再起動が必要です。
        </li>
    </ol>
    </li>

    <li>それ以外のモードでは、trust, reject, clear text password, pam, crypt, md5認証方式だけが利用できます。
    </li>
    </ul>

<h2 id="temp_table_in_master_slave_mode">一時テーブルの扱い</h2>
<p>
制限対象:マスタースレーブモード
</p>

<p>
一時テーブルの作成、更新は常にマスタ(primary)で行なわれます。
一時テーブルの検索も、pgpool-II 3.0以降では、マスタで行なわれるので、
一時テーブルを使っているかどうかを意識する必要はありません。
ただし、文字列として一時テーブル名をSELECTの中で使っている場合は一時テーブルかどうかの確認のしようがないので、
負荷分散されてしまい、その一時テーブルが見つからないか、
もしくは同じ名前の別のテーブルを検索してしまうことになります。
そのような問い合わせは避けるか、/*NO LOADB ALNCE*/のコメントを挿入してください。
</p>
<pre>
SELECT 't1'::regclass::oid;
</pre>

<p>
ちなみに、psqlの\dコマンドのように、システムカタログを問い合わせる中で
文字列としてのテーブル名を使っている場合は、pgpool-II 3.0以降ではマスタで検索が行なわれるので、問題になりません。
なぜなら、システムカタログへの検索は常にマスタで行なわれるからです。
</p>

<h2 id="caution_in_replication_mode">レプリケーションモードで注意が必要な関数など</h2>
<p>
pgpool-IIでは同じ問い合わせを送っても異なる結果を返すようなデータ、
たとえば乱数やトランザクションID、OIDのようなものに関してはレプリケーションはしますが、
2台のホストでまったく同じ値がコピーされる保証はありません。
</p>
<p>
シリアル型に関しては、insert_lockを有効にしておけばテーブルロックを利用して同期が取られます。
シーケンスを扱う関数をSELECT setval()、SELECT nextval()で呼び出している場合は
自動的にレプリケーションされるので同期が取れます。
</p>
<p>
pgpool-II 2.3以降では、テーブルのデフォルト値での利用も含め、
CURRENT_TIMESTAMP, CURRENT_DATE, now()は、自動的にマスタ側から取得した時刻値に置き換えることによって
レプリケーションできるようになっています。
ただし、以下の点に注意してください。
</p>

<ul>
    <li><p>
        pgpool-II 3.1より前のバージョンではDEFAULTにタイムスタンプを返す式が
        含まれているかどうかの判定は正確ではありません。例えば
        </p>
<pre>
CREATE TABLE rel1(
  d1 date DEFAULT CURRENT_DATE + 1
)
</pre>
    のようなものも現在のタイムスタンプとして書き換えを行います。
    pgpool-II 3.1以降では、拡張プロトコルとPREPARE以外の場合にこの点が改善されており、
    上記の例にあるような例も正しく処理されます(つまり、デフォルト値として明日の日付がセットされます)。
    </p>
    <p>
    なお、列の定義が、
    </p>
<pre>
foo bigint default (date_part('epoch'::text,('now'::text)::timestamp(3) with time zone) * (1000)::double precision)
</pre>
    <p>
    のように、データ型が日付、時刻以外になっている場合は書き換えは行ないません。
    </p>
    </li>

<li>INSERT ... SELECTでは、列のDEFAULTに対する書き換えを行いません。例えば、
<pre>
CREATE TABLE rel1(
  c1 int,
  c2 timestamp default now()
)
</pre>
    の時、
<pre>
INSERT INTO rel1(c1) VALUES(1)
</pre>
    は
<pre>
INSERT INTO rel1(c1, c2) VALUES(1, '2009-01-01 23:59:59.123456+09')
</pre>
    のように書き換えられますが
<pre>
INSERT INTO rel1(c1) SELECT 1
</pre>
    は書き換えられません。
    </li>
</ul>

<p>
PostgreSQL 8.2かそれより前のPostgreSQLをお使いの場合、
CREATE TEMP TABLEで作成されたテーブルはフロントエンドがセッションを終了しても削除されません。
これは、コネクションプールの効果でバックエンドから見るとセッションが継続しているように見えるからです。
セッションの終了時に明示的にDROP TABLEするか、トランザクションブロックの中で
CREATE TEMP TABLE ... ON COMMIT DROPをお使い下さい。
</p>
<p>
PostgreSQL 8.3以降では、reset_query_listにDISCARD ALLを指定すれば自動的に削除されるので問題ありません。
</p>

<h2 id="ng_queries">クエリについて</h2>
<p>
pgpool-II では扱うことができないクエリについて説明します。
</p>

<h3 id="ng_multibyte_chars">マルチバイト文字について</h3>
<p>
制限対象:全モード
</p>
<p>
現在の実装では、マルチバイト文字の変換処理を行いません。
クライアントエンコーディング、バックエンドノードのサーバエンコーディング、システムDB
のサーバエンコーディングを一致させるようにしてください。
</p>

<h3 id="ng_multi_statement">マルチステートメント</h3>
<p>
制限対象:全モード
</p>
<p>
マルチステートメント(';' で区切って複数の文をまとめた SQL)を pgpool が
正しく処理することができません。必ず文を分けて送信してください。
</p>
<p>
なお、psql を使って pgpool に接続した場合は、psql 内部でマルチステートメントを分解し、
1 つずつ送信するので、実際には問題になりません。
</p>

<h3 id="ng_extended_protocol">拡張問い合わせプロトコル</h3>
<p>
制限対象:パラレルモード
</p>
<p>
JDBC ドライバなどのような拡張問い合わせプロトコルには対応していません。
必ず簡易問い合わせプロトコルを使用してください。
</p>

<h3 id="ng_select">SELECT</h3>
<p>
制限対象:パラレルモード
</p>
<p>
postgresql.conf の add_missing_from設定値を off (デフォルト値)に設定してください。
add_missing_from 設定値が on の時に使えるクエリは正しくpgpoolで処理されない可能性
があります。
</p>

<h3 id="ng_insert">INSERT</h3>
<p>
制限対象:パラレルモード
</p>
<p>
データ分割をしているテーブルに対してINSERT を行う際には、分割ルールとなる値を DEFAULT にはできません。
例えばテーブル t に x というカラムがあり、x が分割ルールの対象カラムだった場合には、
</p>
<pre>
INSERT INTO t(x) VALUES (DEFAULT);
</pre>
<p>
はできません。また、分割ルールとなる値が関数呼び出しの場合も
対応していません。
</p>
<pre>
INSERT INTO t(x) VALUES (func());
</pre>
<p>
必ず明示的に値を与える必要があります。
</p>
<p>
また、SELECT INTO や INSERT INTO ... SELECT という形式もサポートしていません。
</p>

<h3 id="ng_update">UPDATE</h3>
<p>
制限対象:パラレルモード
</p>
<p>
分割ルールとなるカラムを更新すると分割ルールに従ったデータの整合性が崩
れる可能性があります。pgpool-II では特にデータの再配置ということは行い
ません。
</p>
<p>
もし制約違反などにより一部のノードでエラーになった場合にロールバックす
ることはできません。
</p>
<p>
WHERE 句にデータ分割を行ったテーブルを参照するサブクエリや関数呼び出しがある場合には正しく動かない可能性が
あります。
</p>
<pre>
例：UPDATE branches set bid = 100 where bid = (select max(bid) from beances);
</pre>

<h3 id="ng_select_for_update">SELECT ... FOR UPDATE</h3>
<p>
制限対象:パラレルモード
</p>
<p>
WHERE 句にデータ分割を行ったテーブルを参照するサブクエリや関数呼び出しがある場合には正しく動かない可能性が
あります。
<pre>
例：SELECT * FROM  branches where bid = (select max(bid) from beances) FOR UPDATE;
</pre>
</p>

<h3 id="ng_copy">COPY</h3>
<p>
制限対象:パラレルモード
</p>
<p>
COPY BINARY には対応していません。また、ファイルからのコピーにも対応していません。
COPY FROM STDIN と COPY TO STDOUT のみ対応しています。
</p>

<h3 id="ng_create_table">ALTER/CREATE TABLE について</h3>
<p>
制限対象:パラレルモード
</p>
<p>
pgpool に情報を更新させるためには、pgpool を再起動する必要があります。
</p>

<h3 id="ng_transaction">トランザクション</h3>
<p>
制限対象:パラレルモード
</p>
<p>
トランザクション中に発行される SELECT は dblink を経由する場合には別ト
ランザクションになります。以下に例を示します。
</p>
<pre>
BEGIN;
INSERT INTO t(a) VALUES (1);
SELECT * FROM t ORDER BY a; &lt;-- 上の INSERT した値は見えない
END;
</pre>
<p>
また制約違反などにより一部のノードでエラーになった場合にロールバックすることはできません。
</p>

<h3 id="ng_view">View/Rule</h3>
<p>
制限対象:パラレルモード
</p>
<p>
View や Rule は各ノードに同じ内容が定義されます。
</p>
<pre>
CREATE VIEW sample AS SELECT * FROM a, b where a.i = b.i
</pre>
<p>
上記のような テーブル結合を含んだVIEWは、a と b は同じノード内でのみ結合処理を行い、
各ノードからの実行結果を統合します。ノードをまたがった JOIN を行う View を作成することはできません。
Rule についても同様になります。
</p>
<p>
ただし、データ分割したテーブルを同じノード内でのみ結合したい場合に、VIEWを作成することは可能です。
この場合にはVIEWをpgpool_catalog.dist_defテーブルにVIEWを登録しておきます。
</p>
<p>
また、pgpool_catalog.dist_defテーブルのcol_nameとdist_def_funcには、
VIEWで定義したカラムとVIEWに対してINSERTが発行された場合に
何処のノードにクエリを問い合わせるのかを決定する関数を登録してください。
</p>

<h3 id="ng_fuction">関数/トリガについて</h3>
<p>
制限対象:パラレルモード
</p>
<p>
関数は各ノードに同じ内容が定義されます。関数内で JOIN や他のノードのデータ操作を行うことはできません。
</p>

<h3 id="ng_natural_join">Natural Join について</h3>
<p>
制限対象:パラレルモード
</p>
<p>
Natural Join は利用できません。ON 結合条件または、USING(結合カラム) を明示的に
指定する必要があります。
</p>

<h3 id="ng_using">USING 句について</h3>
<p>
制限対象:パラレルモード
</p>
<p>
JOIN 構文の中で利用される USING 句はクエリの書き換え処理によって ON 句に変換されます。
そのため、ターゲットリストに "*" を利用する問い合わせを行う場合には、同じ列名が出力されます。
</p>

<h3 id="ng_dead_lock">デッドロックについて</h3>
<p>
制限対象:パラレルモード
</p>
<p>
ノード間をまたがるデッドロックを検出することができません。
</p>
<pre>
例：accountsテーブルは以下のルールで分割されている。
    aid &lt;= 100000 ノード 0
    aid &gt;= 100000 ノード 1

  A) BEGIN;
  B) BEGIN;
  A) SELECT * FROM accounts WHERE aid = 100001 FOR UPDATE;
  B) SELECT * FROM accounts WHERE aid = 100000 FOR UPDATE;
  A) SELECT * FROM accounts WHERE aid = 100000 FOR UPDATE;
  B) SELECT * FROM accounts WHERE aid = 100001 FOR UPDATE;
</pre>
<p>
この場合、単一のノードではデッドロックを検知できないため、pgpool は待
たされた状態になります。この現象は SELECT FOR UPDATE 以外にも行ロック
を獲得するクエリで発生する可能性があります。
</p>
<p>
また、あるノードでデッドロックが発生した場合は、各ノードのトランザクショ
ンの状態が異なる状況になります。そのため、デッドロックを検知した時点で
以下のログを出力して pgpool は該当のプロセスを終了させます。
<pre>
pool_read_kind: kind does not match between master(84) slot[1] (69)
</pre>

<h3 id="ng_schema">スキーマについて</h3>
<p>
制限対象:パラレルモード
</p>
<p>
public 以外のスキーマに属すようなオブジェクトの参照は必ず
</p>
<pre>
スキーマ.オブジェクト
</pre>
<p>
と指定するようにしてください。
</p>
<pre>
set search_path = xxx
</pre>
<p>
を指定し、スキーマ名を省略すると、pgpool がどの分散ルールを適用するか
判断できません。
</p>

<h3 id="ng_relname">テーブル名、カラム名について</h3>
<p>
制限対象:パラレルモード
</p>
<p>
pool_で始まるテーブル、カラム名は使えません。クエリ書き換えの際に内部処理で使用します。
</p>

<h2 id="caution_system_db">システム DB</h2>

<h3>分割ルール</h3>
<p>
pgpool-II では分割ルールの対象のカラムは 1 つのみとします。x と y の
OR 条件などといったものには対応していません。
</p>

<h2>ビルドに必要な環境</h2>

<h3>libpq</h3>
<p>
pgpool-II では libpq をリンクします。libpq のバージョンは 2.0 の場合、
configure に失敗します。必ず libpq 3.0 以降(PostgreSQL 7.4以降) をリンクするよ
うにしてください。また、SystemDB のバージョンも PostgreSQL 7.4 以降が
必須になります。
</p>

<h2 id="caution_query_cache">クエリキャッシュ</h2>
<p>
現在のクエリキャッシュの実装では、キャッシュの無効化を手動で行う必要があります。
</p>

</p>

<!-- ================================================================================ -->

<h1>リファレンス<a name="reference"></a></h1>
<h2>PCPコマンドリファレンス</h2>

<h3 id="pcp_command">PCPコマンド一覧</h3>
<p>
pgpool-IIを操作するUNIXコマンドとして、以下のものがあります。
</p>
<pre>
* pcp_node_count     - ノード数を取得する
* pcp_node_info      - ノード情報を取得する
* pcp_proc_count     - プロセス一覧を取得する
* pcp_proc_info      - プロセス情報を取得する
* pcp_systemdb_info  - システムDB情報を取得する
* pcp_detach_node    - ノードを切り離す
* pcp_attach_node    - ノードを復帰させる
* pcp_promote_node   - ノードをマスターに昇格させる
* pcp_stop_pgpool    - pgpool-IIを停止させる
* pcp_recovery_node  - マスタノードを使ってノードのデータを再同期、ノード起動させる
</pre>


<h2 id="pcp_comand_args">共通引数</h2>
<p>
   全てのコマンドには共通する引数があります。これは接続するpgpool-IIの情報や認証
   情報などです。
<pre>
ex)
$ pcp_node_count [-d] 10 localhost 9898 postgres hogehoge

第一引数    - タイムアウト値
    秒数でタイムアウト値を指定します。この時間内にpgpool-IIから応
    答がない場合はコネクションを切断して終了します。なお、
    このオプションは 2.1 からは無視するようになっています。
第二引数    - pgpool-IIが稼動しているホスト名
第三引数    - PCPポート番号
第四引数    - PCPユーザ名
第五引数    - PCPパスワード

オプション引数として、-dがあります。-dが指定されるとデバッグ情報を出力します。
</pre>
<p>
PCPユーザ名とパスワードは ./configure 時に --prefix で指定した
'インストールディレクトリ/etc' にある pcp.conf 内に記述されているものを指定します。
pcp.conf ファイルの場所がデフォルト以外の場所にある場合、
pgpool の-F オプションでその位置を指定することができます。
パスワードはコマンドに渡す時点でmd5化されている必要はありません。
</p>


<h2>コマンド群</h2>
<p>
全てのコマンドは、実行した結果が標準出力に表示されます。
</p>


<h3 id="pcp_node_count">pcp_node_count</h3>
<pre>
書式：
pcp_node_count  _timeout_  _host_  _port_  _userid_  _passwd_
</pre>
<p>
pgpool-IIの pgpool.conf で定義されたノードの総数を表示します。切り離されているノードの区別はしません。
</p>


<h3><a name="pcp_node_info"></a>pcp_node_info</h3>
<pre>
書式：
pcp_node_info  _timeout_  _host_  _port_  _userid_  _passwd_  _nodeid_
</pre>

<p>
pgpool-IIの pgpool.conf で定義されたノードの情報を表示します。出力結果は以下の例の通りです。
</p>

<pre>
ex)
$ pcp_node_info 10 localhost 9898 postgres hogehoge 0
host1 5432 1 1073741823.500000

結果は以下の順の通りです。
1. ノードのホスト名
2. ノードのポート番号
3. ステータス
4. ロードバランスウェイト

ステータスは[0..3]までの数字で表わされます。各数字の意味は：
0 - 初期化時のみに表われる。PCPコマンドで表示されることはない。
1 - ノード稼働中。接続無し
2 - ノード稼働中。接続有り
3 - ノードダウン
</pre>

<p>
ロードバランスウェイトはNormalizeされたフォーマットで出力されます。
</p>
<p>
定義されていないノードIDを指定するとBackendErrorと表示され、終了コード12で終了します。
</p>


<h3 id="pcp_proc_count">pcp_proc_count</h3>
<p>
<pre>
書式：
pcp_proc_count  _timeout_  _host_  _port_  _userid_  _passwd_
</pre>
<p>
pgpool-IIの子プロセスのプロセスIDを一覧表示します。複数ある場合は空白文字で区切られます。
</p>

<h3 id="pcp_proc_info">pcp_proc_info</h3>
<p>
<pre>
書式：
pcp_proc_info  _timeout_  _host_  _port_  _userid_  _passwd_  _processid_
</pre>
<p>
pgpool-IIの子プロセス情報を表示します。出力結果は以下の例の通りです。
</p>
<pre>
ex)
$ pcp_proc_info 10 localhost 9898 postgres hogehoge 3815
postgres_db postgres 1150769932 1150767351 3 0 1 14067 1
postgres_db postgres 1150769932 1150767351 3 0 1 14068 1

結果は以下の順の通りです。
1. 接続しているデータベース名
2. 接続しているユーザ名
3. プロセススタート時刻
4. コネクション作成時刻
5. プロトコルメジャーバージョン
6. プロトコルマイナーバージョン
7. コネクション使用回数
8. PostgreSQLバックエンドプロセスID
9. フロントエンドから接続がある場合は1、そうでなければ0

コネクションがバックエンドに対して張られていない場合、データは表示されません。
コネクション情報が複数ある場合、複数行に1行1コネクション情報で表示されます。
時刻はEPOCHタイムからの秒数で表わされます。

定義されていないプロセスIDを指定するとBackendErrorと表示され、<a href="#exit_status">終了コード12</a>で終了します。
</pre>

<h3 id="pcp_systemdb_info">pcp_systemdb_info</h3>
<pre>
書式：
pcp_systemdb_info  _timeout_  _host_  _port_  _userid_  _passwd_

pgpool-IIのシステムDB情報を表示します。出力結果は以下の通りです。

$ pcp_systemdb_info 10 localhost 9898 postgres hogehoge
localhost 5432 yamaguti '' pgpool_catalog pgpool 3
yamaguti public accounts aid 4 aid bid abalance filler integer integer integer character(84) dist_def_accounts
yamaguti public branches bid 3 bid bbalance filler integer integer character(84) dist_def_branches
yamaguti public tellers bid 4 tid bid tbalance filler integer integer integer character(84) dist_def_tellers

まず一行目にシステムDBの情報が表示されます。結果は以下の順の通りです。

1. ホスト名
2. ポート番号
3. ユーザ名
4. パスワード。空の場合は''で表示されます。
5. スキーマ名
6. データベース名
7. 分散定義関数の数

二行目以降は分散定義が表示されます。複数の定義がある場合は、一つの定義につき
一行表示されます。結果は以下の順の通りです。

1. 分散対象のデータベース名
2. 分散対象のスキーマ名
3. 分散対象のテーブル名
4. 分散キーカラム名
5. 分散対象テーブル中のカラム数
6. カラム名リスト(5.のカラム数分表示されます)
7. カラム型リスト(5.のカラム数分表示されます)
8. 分散定義関数名

システムDBが定義されていない(pgpool-IIモードでない、かつクエリキャッシュがオ
フの)場合に実行すると、BackendErrorと表示され、終了コード12で終了します。
</pre>

<h3 id="pcp_detach_node">pcp_detach_node</h3>
<pre>
書式：
pcp_detach_node  [-g] _timeout_  _host_  _port_  _userid_  _passwd_  _nodeid_

pgpool-IIのノードを切り離します。
-gを指定すると、すべてのクライアントが接続を終了するまでノードを復帰しません。
(ただし、client_idle_limit_in_recovery が -1 あるいは、recovery_timeout が設定されている場合を除く)
</pre>

<h3 id="pcp_attach_node">pcp_attach_node</h3>
<pre>
書式：
pcp_attach_node  _timeout_  _host_  _port_  _userid_  _passwd_  _nodeid_

pgpool-IIのノードを復帰させます。
</pre>

<h3 id="pcp_promote_node">pcp_promote_node</h3>
<pre>
書式:
pcp_promote_node  [-g] _timeout_  _host_  _port_  _userid_  _passwd_  _nodeid_

pgpool-IIのノードをマスターに昇格させます。これは、マスタースレーブモードでストリーミング
レプリケーション構成の場合のみ使用できます。
-gを指定すると、すべてのクライアントが接続を終了するまでノードをマスターに昇格しません。
(ただし、client_idle_limit_in_recovery が -1 あるいは、recovery_timeout が設定されている場合を除く)
</pre>
</p>

<h3 id="pcp_stop_pgpool">pcp_stop_pgpool</h3>
<pre>
書式：
pcp_stop_pgpool  _timeout_  _host_  _port_  _userid_  _passwd_  _mode_

pgpool-IIを指定されたモードでシャットダウンします。指定できるモードは以下の通
りです。

s    - smart モード
f    - fast モード   
i    - immediate モード

pgpool-IIが起動していない場合はConnectionErrorと表示され、終了コード8で終了し
ます。

※ 現在は fast モードと immediate シャットダウンの処理に区別はあり
  ません。命令を送った時点でクライアントがいる・いないに関わらず
  シャットダウン処理を即座に行います。
</pre>
</p>

<h3 id="pcp_recovery_node">pcp_recovery_node</h3>
<pre>
書式：
pcp_recovery_node  _timeout_  _host_  _port_  _userid_  _passwd_  _nodeid_

pgpool-IIのノードをデータを再同期させた上で復帰させます。
</pre>
</p>

<h2 id="exit_status">終了ステータス</h2>
<p>
PCPコマンドは正常に処理を終了した場合、ステータス'0'で終了します。エラーが起
きた場合は以下のステータスにより終了します。
<pre>
UNKNOWNERR    1    不明なエラー
EOFERR        2    EOFエラー
NOMEMERR      3    メモリ不足
READERR       4    サーバからのデータ読み込みエラー
WRITEERR      5    サーバへのデータ書き込みエラー
TIMEOUTERR    6    タイムアウト
INVALERR      7    PCPコマンドへの不正なオプション
CONNERR       8    サーバ接続エラー
NOCONNERR     9    接続が存在しない
SOCKERR      10    ソケットエラー
HOSTERR      11    ホスト名解決エラー
BACKENDERR   12    サーバでのPCP処理エラー。存在しないプロセスIDの情報を取得しようとした場合など
AUTHERR      13    認証エラー
</pre>
</p>

<!-- ================================================================================ -->

<h1>内部情報<a name="internal"></a></h1>
<p>
pgpool-IIバージョン 2.0 以降では、1.x バージョンと比べ大幅な改良が加えられています。
1.x バージョンの情報とは互換性がないので注意してください。
</p>

<h2 id="parallel_execute_engine">パラレル実行エンジン</h2>

<p>
pgpool-IIにはパラレル実行エンジンが組み込まれています。
</p>
<p>
このエンジンは、パラレルモードのときに、各ノードに同じクエリを問い合
わせ、ノードの応答順に結果をフロントエンドに送信するエンジンのことを
指します。
</p>

<h2 id="rewrite_query">クエリ書き換え</h2>
<p>
パラレルモードでpgpool-IIが行うクエリ書き換えについて説明します。
</p>
<p>
パラレルモードでは、クライアントが送信した検索系(SELECT処理)の問い合わせは、
大きく分けて以下の 2 つの処理を行います。
</p>
<ol>
    <li>クエリの解析</li>
    <li>クエリの書き換え</li>
</ol>

<p>
これら２つの処理について順に説明致します。
</p>

<h3 id="analyze_query">クエリの解析</h3>
<h4>はじめに</h4>
<p>
クライアントが送信した検索系の問い合わせは、SQLパーサを通してからシステムDBに登録されている情報を
もとにクエリ解析を行います。クエリの解析には実行ステータスの遷移で評価しています。
</p>
<p>
ここで実行ステータスというのは、あるデータの集合が何処で取得または処理できるのか判断するものです。
例えば、pgpool_catalog.dist_defテーブルに登録されているテーブルのデータ集合全体は、
データが分割されているのですべてのノードから取得する必要があります。
逆に、pgpool_catalog.replicate_defテーブルに登録されているテーブルのデータ集合全体は、
すべてのノードから取得するのではなく、いずれかのノード
から取得すれば十分です。
</p>
<p>
ここで実行ステータスというのは、あるデータの集合が何処で取得または処理できるのか判断するものです。
ここですべてのノードで処理する必要がある状態を P 状態、一つのノードで処理する必要がある状態を
L 状態として定義します。
</p>
<p>
ここで実行ステータスというのは、あるデータの集合が何処で取得または処理できるのか判断するものです。
もう一つ、特別な状態として S 状態があります。
これは、すべてのノードから取得した全データに対して処理を行ったときの状態のことを示します。
</p>
<p>
ここで実行ステータスというのは、あるデータの集合が何処で取得または処理できるのか判断するものです。
例えば、ソート処理です。pgpool_catalog.dist_defテーブルに登録されている
テーブルのデータに対するソート処理は、すべてのノードからデータを取得した後に実行する必要があります。

</p>
<p>
検索系クエリは、以下の処理順に解析され、実行ステータスが遷移していきます。
実行ステータスが遷移していく過程で S 状態となると、以降の処理は必ず S 状態となります。
そして最後のSELECTの最終実行ステータスの状態により、何処のDBで処理されるかが決定します。

<ol>
    <li> UNION、EXTRACT、INTERCECTが利用されているかどうか</li>
    <li> FROM 句の実行ステータス</li>
    <li> TARGETLIST による実行ステータスの変化</li>
    <li> WHERE 句 にる実行ステータスの変化</li>
    <li> GROUP BY 句による実行ステータスの変化</li>
    <li> HAVING 句による実行ステータスの変化</li>
    <li> ORDER BY 句による実行ステータスの変化</li>
    <li> LIMIT OFFSET 述語に実行ステータスの変化</li>
    <li> SELECTの最終実行ステータスの取得</li>
</ol>
<p>
SELECTの最終実行ステータスと処理される場所との関係は、以下の通りです。
</p>

<table border>
<tr><td>実行ステータス</td><td>処理される場所</td></tr>
<tr><td align = center>L</td><td>いずれかのノードに問い合わせを行う</td></tr>
<tr><td align = center>P</td><td>すべてのノード同じ問い合わせを行い、パラレル実行エンジンを通してクライアントに返却</td></tr>
<tr><td align = center>S</td><td>システムDBで処理を行った後にクライアントに返却</td></tr>
</td></tr>
</table>

<p>
またサブクエリに対しても上記のルールが適応されます。
以下の単純なクエリでは、p1-tableがシステムDBのpgpool_catalog.dist_defテーブルに登録されている場合、
つまりデータの分割が
行われている場合には、サブクエリの最終実行ステータスが P となり、
その結果サブクエリの呼び出し元である SELECT の実行ステータスも P となります。
</p>
<pre>
SELECT * FROM (SELECT * FROM P1-table) as P2-table;
</pre>

<p>
次に具体的に実行ステータスがどのように遷移するのか説明します。
まず2. From句の実行ステータス から説明します。
</p>

<h4>FROM 句の実行ステータス</h4>
<p>
検索系クエリ(SELECT)は FROM 句によりデータの集合を定義します。
FROM句から構成せれるデータ集合は P 状態, L 状態、または S 状態を取ります。
FROM句に指定しているテーブルが一つの場合には、単純にテーブルの実行ステータスが
FROM句から構成されるデータ集合全体の実行ステータスとなります。
FROM句に複数のテーブル、又はサブクエリがある場合
には、結合方法によって以下のように実行ステータスが決定します。
</p>

<table border>
<tr><td>結合方式</td><td align = center colspan = 3> LEFT OUTER JOIN </td><td align = center colspan = 3> RIGHT OUTER JOIN </td><td align = center colspan = 3>FULL OUTER JOIN</td><td align = center colspan = 3>　　　その他　　　</td></tr>
<tr><td align = center>左＼右</td><td> P </td><td> L </td><td> S </td><td> P </td><td> L </td><td> S </td><td> P </td><td> L </td><td> S </td><td> P </td><td> L </td><td> S </td></tr>
<tr><td align = center> P </td><td> S </td><td> P </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> P </td><td> S </td></tr>
<tr><td align = center> L </td><td> S </td><td> L </td><td> S </td><td> P </td><td> L </td><td> S </td><td> S </td><td> L </td><td> S </td><td> P </td><td> L </td><td> S </td></tr>
<tr><td align = center> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td></tr>
</td></tr>
</table>

<p>
以下の例では、P1-tableが P 状態のテーブルでL1-table,L2-tableが L 状態のテーブルだとします。
すると上記の表により、P1-table (左)とL1-table (右) が結合し P 状態となり、
さらに P 状態と L 状態のL2-tableが結合してFROM句の実行ステータスは P 状態となります。 
<pre>
SELECT * FROM P1-table,L1-table,L2-table;
</pre>
</p>

<h4>TARGETLIST と WHERE句の実行ステータス</h4>

<p>
基本的なクエリでは、FROM 句と同じ実行ステータスを継承します。
しかし、TARGETLIST と WHERE句の実行ステータスは、以下の場合に変化します。
</p>
<ol>
    <li>サブクエリがある場合</li>
    <li>FROM句が P 状態の場合、かつ、TARGETLISTに集約関数、DISTINCTがある場合 </li>
    <li>FROM句で定義したテーブル(データ集合)に存在しないカラムが使われている場合</li>
</ol>
<p>
サブクエリの最終実行ステータスが P 状態、または、S 状態の場合には、
TARGETLIST、WHERE句の実行ステータスは、S 状態となります。
下記の例では、サブクエリで使われているテーブルが、P 状態の場合には、
サブクエリの最終実行ステータスはP 状態となります。
そのため L1-tableの実行ステータスに依存せずに、WHERE句の実行ステータスは S状態となり、
このクエリの実行場所はシステムDBとなります。
</p>
<pre>
SELECT * FROM L1-table WHERE L1-table.column IN (SELECT * FROM P1-table);
</pre>

<p>
FROM 句が P 状態の場合、かつ、TARGETLISTに集約関数がある場合は、
データを取得後に集計する必要があるため、S状態に遷移します。
また、特定の条件の下では、集約関数による最適化が行われます。
</p>

<p>
FROM句で定義したテーブル、サブクエリには存在しないカラムがWHERE句に使われている場合があります。
これは以下のような相関サブクエリ内で発生します。
</p>
<pre>
SELECT * FROM L1-table WHERE L1-table.col1 IN (SELECT * FROM P1-table WHERE P1-table.col = L1-table.col1);
</pre>
<p>上記のサブクエリに使われている L1-table.col1は、L1-tableを外部参照しています。
この場合にサブクエリのWHERE句の実行ステータスは S 状態となります。


<h4>GROUP BY 句、HAVING 句、ORDER BY 句、LIMIT OFFSET 述語の実行ステータス</h4>

<p>
WHERE句の実行ステータスが P 状態の場合に、GROUP BY , HAVING 句、ORDER BY 句、
LIMIT OFFSET 述語があるとS状態に遷移します。
GROUP BY句が存在しないクエリはWHERE句の実行ステータスを継承します。
また、HAVING句が無い場合にはGROUP BY 句の実行ステータスを継承します。
ORDER BY 句、LIMIT OFFSET 述語も同様です。
</p>

<p>
UNION、EXTRACT、INTERSECTが使われている場合
</p>

<p>
UNION、EXTRAT、INTERSECTが使っているクエリは左側のSELECT文と右側のSELECT文の最終実行ステータスに依存します。
左側と右側のSELECT文の最終実行ステータスが共に L 状態の時には、L 状態となります。
</p>
<p>
また、左側と右側のSELECT文の最終実行ステータスが共に P 状態、かつUNION ALLの場合には P 状態となります。
その他の組み合わせの場合には、S状態となります。
</p>

<h4>SELECTの最終実行ステータスの取得</h4>

<p>
実行ステータスがすべて L 状態の場合にはL状態、すべて P 状態の場合には、P 状態となります。
それ以外は、S 状態となります。
</p>
<p>
L 状態の場合には、pgpool.confのloadbalance_modeがtrueの場合には負荷分散され、
それ以外の場合にはMASTERに問い合わせを行います。
</p>
<p>
また、P 状態の場合には、パラレル実行エンジンを使って並列処理が行われます。
S 状態の場合には、次のフェーズであるクエリ書き換えを行います。
</p>

<h3 id="step_rewrite_query">クエリ書き換え</h3>

<p>
クエリの解析フェーズで取得した実行ステータスを使ってクエリの書き換えを行います。
例として P 状態の P1-table と L 状態の L1-table を使ったクエリで説明します・
</p>
<pre>
SELECT P1-table.col, L1-table.col FROM P1-table,L1-table where P1-table.col = L1-table.col order by P1-table.col;
</pre>
<p>
このクエリでは ORDER BY 句があるため S 状態となり、FROM句、WHERE句、TARGETLISTは P 状態となります。
このようなクエリでは以下のように書き換えられます。
</p>
<pre>
SELECT P1-table.col, L1-table.col FROM
　　　dblink(select pool_parallel(SELECT P1-table.col, L1-table.col FROM P1-table,L1-table where P1-table.col = L1-table.col))
      order by P1-table.col;
</pre>
<p>
ここでdblinkはpgpool-IIに問い合わせを送信します。
また、pool_parallelは引数のクエリをパラレル実行エンジンをにわたす関数です。
なお、上記はあくまでイメージであり実際に実行可能なクエリではありません。
</p>
<p>
上記の例のように、FROM句、WHERE句、TARGETLISTがすべて P 状態の場合には、
FROM句、WHERE句、TARGETLISTをまとめて並列処理を行います。

<p>
次の例を見てみます。
</p>
<pre>
SELECT L1-table.col FROM L1-table WHERE L1-table.col % 2 = 0 AND L1-table.col IN (SELECT P1-table FROM P1-table) ;
</pre>
<p>
この例では、FROM 句は L 状態、TARGETLISTも L 状態、WHERE句は P 状態のサブクエリを持っているため S 状態となります。
これは以下のように書き換えが行われます。
</p>
<pre>
SELECT L1-table.col FROM dblink(SELECT loadbalance(SELECT L1-table.col FROM L1-table WHERE L1-table.col % 2 = 0 AND TRUE))
    WHERE
        L1-table.col %2 = 0 AND 
      L1-table.col IN 
      (
          SELECT P1-Table FROM 
          dblink(select pool_parallel(SELECT P1-table FROM P1-table))
      ) ;
</pre>
<p>
ここで、pool_loadbalanceはクエリをいずれかのノードに送信する関数です。
</p>

<h4>集約によるクエリ書き換え</h4>

<p>
集計を行うクエリ(集約関数、GROUP BY )は各ノードに計算させ、システムDBで再集計を行うことにより、
システムDBの負荷を減らしパフォーマンスも向上します。
</p>
<p>
まず、最初にpgpool-IIが実際に行うクエリの書き換えを見てみます。
</p>
<p>
FROM 句が P 状態で count(*) を使ったクエリは、以下のように書き換えが行われます。
</p>

<pre>
select count(*) from P1-table;

-&gt; クエリ書き換え

SELECT
    sum(pool_c$1) as count
FROM
    dblink(select pool_parallel('select count(*) from  P1-table'))
                AS pool_$1g (pool_c$1 bigint);
</pre>

<p>
各ノードでcount(*) を計算した後に、システムDBで集計(sum)をすることによ
り、目的が達成できます。
</p>

<p>
上記のようなクエリ書き換えが行われる条件は以下の場合です。
</p>
<ol>
    <li>FROM 句がP 状態</li>
    <li>ターゲットリストに集約関数(count, sum, min, max,avgのみ対応),GROUP BYに指定したカラムが使われている</li>
    <li>WHERE 句がP 状態</li>
    <li>HAVING 句 に使われている集約関数(count, sum, min, max,avgのみ対応),
        FROM句で定義されているカラム,GROUP BYに指定したカラムのみ使われている。</li>
</ol>

<pre>
例)
 select P1-table.col,L1-table.col,count(*),avg(P1-table.col) from P1-table,L1-table wehre P1-table.col %2 = 0 group by P1-table.col,L1-table.coli having count(*) < 100
</pre>

<h3 id="caution_in_parallel_mode">パラレルモードの注意事項</h3>
<p>
パラレルモードでは、クエリの解析の際にカラム名とタイプが必要になります。
そのため、サブクエリのTARGETLISTに式、関数を使っている場合には別名と型名をキャストでつける必要があります。
式、関数に型のキャストがない場合には、text型として処理されますので注意してください。
</p>
<p>
なお、集約関数の場合でかつ集約によるクエリ書き換えが行われる場合には、countはbigint型、sumはnumeric型となります。
min,maxの場合には、引数が日付型の場合には日付型として計算され、それ以外はnumericとして計算されます。
avgはsum/countとして処理されます。
</p>

<h3 id="performance_parallel_mode">パラレルモードのパフォーマンスについて</h3>
<p>
<p>
SELECTの最終実行ステータスとパフォーマンスのおおよその目安は以下のとおりです。
</p>

<table border>
<tr><td>実行ステータス</td><td>パフォーマンス</td></tr>
<tr><td align = center>L</td><td>パラレルクエリを利用しないのでpgpool-IIのオーバーヘッドを除き、単体ノードとの性能劣化はない</td></tr>
<tr><td align = center>P</td><td>並列処理を行うので高速、特にシーケンシャルスキャンの場合には効果がでる。また、データを分割することでテーブルサイズ(/1台)が小さくなることによりキャッシュに乗りやすくなる </td></tr>
<tr><td align = center>S</td><td>集約によるクエリ書き換えが行われると高速</td></tr>
</td></tr>
</table>

</p>

<!-- ================================================================================ -->

<h1 id="tutorial">チュートリアル</h1>
<p>
pgpool-IIのチュートリアルは<a href="tutorial-ja.html">ここ<a/>にあります。是非ご覧下さい。
</p>

<!-- ================================================================================ -->

<h1>リリースノート<a name="release"></a></h1>

<h2><a name="release3.1.0"></a>3.1.0 (hatsuiboshi) 2011/09/08</h2>
<h3>概要</h3>
<p>
このバージョンは3.1系列の最初の版で、3.0系からの「メジャーバージョンアップ」にあたります。
</p>

<h3>互換性のない変更</h3>
<p>
<ul>
 <li>insert_lockのロック方法を変更しました。以前のinsert_lockは、シーケンステーブルに対して行ロックを行いましたが、現在は、pgpool_catalog.insert_lockテーブルに対して行ロックを行います。その理由は、シーケンステーブルに対するロックが内部エラーを引き起こすため、PostgreSQLのコア開発者がそれを許可しないことを決定したためです。したがって、pgpool-II経由でアクセスするすべてのデータベースにinsert_lockテーブルをあらかじめ作成しておく必要があります。もし、insert_lockテーブルが存在しない場合は、挿入対象のテーブルに対してロックを行います。これは、pgpool-II 2.2と2.3シリーズのinsert_lockと同じ動作です。また、過去のバージョンと互換性のあるinsert_lockを使用したい場合は、configureオプション(--enable-sequence-lock,--enable-table-lock)で設定できます(Kitagawa)
 <li>backend_socket_dirパラメータを廃止しました。その代わりに、backend_hostnameが'/'で始まるならば、それをUNIXドメインへのパスとみなします。backend_hostnameが空ならば、デフォルトのUNIXドメインパス(/tmp)が使われます。これは、libpqインタフェースの規約に従います。パッチはJehan-Guillaume (ioguix) de Rorthaisさんから頂きました。
 <li>フェイルオーバー時にpgpool_walrecrunning()を使用せず、プライマリノードへの昇格が完了するまで待つようになりました。関数を使用しない理由はプライマリノードを確実に見つけることができないためです。しかし、この修正にはプライマリノードが現れないときにrecovery_timeoutの間pgpool-IIが待ってしまう問題がまだ残っています(Kitagawa)
 <li>PostgreSQL DBノード情報を出力するpool_nodesに「ノードID」を追加しました(Jean-Paul Argudo)
 <li>シーケンス関数(nextval, setval)の扱いをblack/white_function_listの設定に完全に従うように変更しました。以前、それらは常に書き込み関数として扱われていました(Kitagawa)
</ul>
</p>

<h3>新機能</h3>
<p>
<ul>
 <li>syslogに対応しました。パッチはGilles Daroldさんから頂き、Guillaume Lelargeさんがレビューと編集をしました。
 <li>PostgreSQL 9.0で導入されたapplication_nameに対応しました。コネクションが再利用されたときに、スタートアップパケットのapplication_nameをバックエンドへ送信し、パラメータステータスをフロントエンドに返します(Tatsuo)
 <li>pgpool-II内部で使用するシステムカタログキャッシュの有効時間を、秒単位で指定できる設定項目relcache_expireが追加されました。これにより、ALTER TABLEによってテーブル定義が変更された際に、もはや有効でない結果を利用してしまうリスクが軽減されます。(Tatsuo)
 <li>follow_master_commandパラメータを追加しました。このパラメータには、マスタースレーブモードのストリーミングレプリケーション構成においてマスタノードがフェイルオーバーした後に実行されるコマンドを指定します。パッチはGilles Daroldさんから頂きました。
 <li>pcp_promote_nodeコマンドを追加しました。このコマンドはpgpool-IIに対して新しいマスタノードへの昇格を行います。これは、マスタースレーブモードのストリーミングレプリケーション構成のみで使用できます。パッチはGilles Daroldさんから頂きました。
 <li>pcp_pool_statusコマンドを追加しました。また、対応するC APIも追加されています。パッチはJehan-Guillaume (ioguix) de Rorthaisさんから頂きました。
 <li>バックエンドごとのパラメータ&quot;backend_flag&quot;を追加しました。これは、バックエンドごとの動作を制御します。今は&quot;ALLOW_TO_FAILOVER&quot;または&quot;DISALLOW_TO_FAILOVER&quot;が指定できます(Tatsuo)
 <li>health_check_passwordパラメータを追加しました(Nicolas Thauvin)
 <li>sr_check_period、sr_check_user、sr_check_passwordパラメータを追加しました。これらは、ストリーミングレプリケーションの遅延チェックとプライマリノードの決定に使用されます(Tatsuo)
 <li>pg_md5コマンドに--username(または-u)オプションを追加しました。これは、UNIXアカウントを持たないユーザの管理を可能にします。日本語ドキュメントはTatsuo Ishiiさんが修正しました(Nicolas Thauvin)
 <li>pgpool_adm関数をpgpool_adm/に追加しました。これらは、pcpコマンドのように動作するC言語で書かれたユーザ定義関数です(Jehan-Guillaume (ioguix) de Rorthais)
 <li>簡体字中国語版のドキュメントを追加しました(Huang Jian, Sun Peng)
 <li>関数をアンインストールするためのSQLファイルをsql/に追加しました(Nicolas Thauvin)
 <li>マスタースレーブモードにおいて、unloggedテーブルに対するSELECTは、常にマスター(primary)で実行されるようになりました(Kitagawa)
</ul>
</p>

<h3>バグ修正</h3>
<p>
<ul>
 <li>スタンバイノードでJDBCドライバのカーソルが使用できないバグを修正しました。この修正によって、マスタースレーブモードではトランザクションコマンドがすべてのノードに送られるようになります(Kitagawa)
 <li>空のクエリの処理に関するバグを修正しました。空のクエリはSELECTクエリと同じ扱いになります。この修正は、空のクエリのあとのロードバランスを可能にします(Kitagawa)
 <li>カラム定義が&quot;DEFAULT nextval(('&quot;x_seq&quot;'::text)::regclass)&quot;のようになっていてもinsert_lockが正しく動作するように修正しました(Kitagawa)
 <li>フェイルオーバー中はエラーメッセージを出力するようにpcp_attach_nodeコマンドを修正しました(Kitagawa)
 <li>拡張問い合わせプロトコルでpgpool-IIがクエリを解析できないときに出力されるログメッセージがクエリを表示するよう修正しました(Kitagawa)
 <li>pgpool-IIマニュアルのbackend_weightに関する説明を修正しました。それは、pgpool.confの再読み込みで変更できます(Tatsuo)
 <li>英語のチュートリアルドキュメント内の表現の改善と修正を行いました。修正の提案はHuang Jianさんによるものです(Tatsuo)
 <li>rawモードでノードを復帰させたときにノードの状態が更新されないバグを修正しました(Guillaume Lelarge)
 <li>ストリーミングレプリケーションモードにおけるレプリケーション遅延の計算が間違っていたのを修正しました(Tatsuo)
 <li>フェイルオーバーのログメッセージにおける誤った関数名&quot;notice_backend_error&quot;を、正しいもの&quot;degenerate_backend_set&quot;に置き換えました(Tatsuo)
 <li>pgpool.conf解析後の不要なログ出力を削除しました(Tatsuo)
 <li>バックエンドを新規追加した後に起こり得るpgpool/worker子プロセスのクラッシュを修正しました。修正はGurjeet Singhさんの提案によるものです(Tatsuo)
 <li>FOR SHARE/UPDATE句のあるサブクエリを含むSELECTがスレーブ(standby)に送られるバグを修正しました(Tatsuo)
 <li>PREPARE文でデフォルト値のタイムスタンプ書き換えに失敗するバグを修正しました。これは以前は動作していましたが、3.0で動作しなくなっていました(Kitagawa)
 <li>getopt_long()がない環境でpcpコマンドのコンパイルが失敗するのを修正しました(Tatsuo)
 <li>rawモード、enable_hbaが無効、バックエンドが2台以上の場合にpgpool子プロセスがクラッシュするのを修正しました(Kitagawa)
 <li>メモリリークをいくつか修正しました(Kitagawa)
</ul>
</p>

<h3>改良</h3>
<p>
<ul>
 <li>ストリーミングレプリケーション構成でのオンラインリカバリにおいて、リカバリ終了時に子プロセスを再起動しないようにしました。そのため、既存のセッションはオンラインリカバリ中も継続することができます(Tatsuo)
<li>ストリーミングレプリケーションモードにおいて、pcp_attache_nodeが既存のセッションを切断しなくなりました。ほかのモードでは依然としてセッションが切断されます(Tatsuo)。
 <li>PostgreSQL 9.0のパーサを移植しました。これによりPostgreSQL 9.0で新しく導入された暗黙のインデックス名を使用したCREATE INDEXが実行できるようになりました。パッチは石田さんから頂きました。
 <li>black_function_listとwhite_function_listパラメータに正規表現が使えるようになりました。パッチはGilles Daroldさんから頂き、Guillaume Lelargeさんがレビューしました。
 <li>読みやすいようにpgpool.confのサンプルファイルを再構成しました(Gleu)
 <li>pgpool-IIマニュアルのすべてのパラメータに&lsaquo;a name=&quot;...&quot;&rsaquo;タグを追加しました(Haruka Takatsuka)
 <li>pgpool-IIマニュアルのストリーミングレプリケーションにおけるオンラインリカバリの説明を改善しました(Tatsuo)
 <li>ストリーミングレプリケーションモードにおけるレプリケーション遅延をチェックするための関数を変更しました。現在、pgpoolはpg_last_xlog_receive_location()の代わりにpg_last_xlog_replay_location()を使用します。修正はAnton Yuzhaninovさんの提案によるものです(Tatsuo)
 <li>カラムのデフォルト値に任意の式を指定してもタイムスタンプ書き換えが動作するようにしました。以前は、now()が含まれているものを検知すると、単純にそれをnow()で置き換えてました。これは、デフォルト値の誤った書き換えを引き起こします。例えば、timezone('utc'::text, now())です。しかし、これは簡易プロトコルのみへの適用であることに注意してください。拡張プロトコル(例えばJava, PHP PDO)または、SQLの&quot;PREPARE&quot;にはまだ適用されていません(Tatsuo)
 <li>レプリケーション遅延のチェックに失敗したときに出力されるエラーメッセージを改良しました(Nicolas Thauvin)
 <li>エラーメッセージ&quot;do_md5: read_password_packet failed&quot;をデバッグレベルにしました(Kitagawa)
 <li>pgpool-regclass()をPostgreSQL 9.1でコンパイルできるようにしました(Tatsuo)
 <li>英語版と日本語版のpgpool-IIマニュアルを更新、同期しました(Tatsuo)
</ul>
</p>

<h2>3.0.4 (umiyameboshi) 2011/06/01</h2>
<h3>概要</h3>
<p>
このバージョンでは、3.0.3における様々なバグが修正されています。
</p>

<h3>互換性のない変更</h3>
<p>
<ul>
 <li>ストリーミングレプリケーションにおいて、delay_thresholdが0またはヘルスチェックが無効ならば、遅延チェックは実施されません。これはpgpool-IIマニュアル通りの動作ですが、これまではヘルスチェックが無効の場合も遅延チェックが実施されていました(Guillaume Lelarge)
</ul>
</p>

<h3>バグ修正</h3>
<p>
<ul>
 <li>pgpool-regclass()をPostgreSQL 8.0以降でコンパイルできるように修正しました。7.4はまだエラーが出ます(Tatsuo) 
 <li>ストリーミングレプリケーション構成で/*NO LOAD BALANCE*/コメントを使用したときにハングアップする可能性を修正しました(Kitagawa)
 <li>Flush(H)メッセージやCloseComplete(C)メッセージを受信したときのハングアップを修正しました(Kitagawa)
 <li>pgpool-IIがバックエンドに接続後、RedyForQuery(Z)メッセージを受信するタイミングによって起こり得るハングアップを修正しました(Kitagawa)
 <li>recovery_1st_stage_commandとrecovery_2nd_stage_commandパラメータの説明を追加しました(Tatsuo)
 <li>pgpool-II内部で使用するシステムカタログキャッシュのサイズを32から128に増やしました。これは&quot;unnamed prepared statement does not exist&quot;エラーを軽減する効果があります(Tatsuo, Kitagawa)
 <li>pcp_connect()関数で二重free()を行うバグを修正しました。パッチはJehan-Guillaume (ioguix) de Rorthaisさんから頂きました(Tatsuo)
 <li>PQfinish()関数を誤って使用しているstart_recoery()のバグを修正しました(Tatsuo)
 <li>クライアントのアイドル時間がclient_idle_limitに達したときに、フロントエンドに送信される正しくないエラーメッセージを修正しました(Tatsuo)
 <li>pool_statusの「backend status」変数の名前を正しく修正しました。スペースを'_'に置き換えました(Guillaume Lelarge)
 <li>md5認証方式を採用してデーモンとして実行したときのハングアップを修正しました。パッチは、Nicolas Thauvinさんから頂きました(Tatsuo)
 <li>拡張問い合わせプロトコルでSQL文が出力されるように、log_per_node_statementを修正しました。これは以前は動作していましたが、3.0で動作しなくなっていました(Kitagawa)
</ul>
</p>

<h3>改良</h3>
<p>
<ul>
 <li>サンプルの設定ファイルのblack_function_listにcurrval()とlastval()を追加しました。もしそれらがロードバランスされると、nextval()やsetval()の結果がスレーブに反映される前にcurrval()またはlastval()が呼ばれることがあります(Tatsuo)
</ul>
</p>

<h2><a name="release3.0.3"></a>3.0.3 (umiyameboshi) 2011/02/23</h2>
<h3>概要</h3>
<p>
このバージョンでは、3.0.1における様々なバグが修正されています(pgpool-II 3.0.2のリリースはパッケージングの問題でキャンセルされました)。
</p>

<h3>互換性のない変更</h3>
<p>
<ul>
 <li>ストリーミングレプリケーションモードを使用する場合に、PostgreSQLサーバにC関数「pgpool_walrecrunning()」をインストールすることが推奨されます(後述)。この場合、新しい変数「%P」がオンラインリカバリのスクリプトで利用できるようになります。この関数をインストールしない場合は、従来と同じ動作になります(Tatsuo)
 <li>rawモードでDBノードがひとつだけの場合、DBノードに問題が発生するとダウン状態になりますが、DBノードが復旧したらpgpoolの再起動なしにDBノードを使用できるようにしました。この変更は3.0に含まれていましたが、動作していませんでした(Tatsuo, Kitagawa)
</ul>
</p>

<h3>バグ修正</h3>
<p>
<ul>
 <li>パスワード認証における移植性を損なうコードを修正しました。これはFreeBSDユーザからのバグ報告に基づきます(Tatsuo)
 <li>insert_lockがユーザテーブルの全行をロックするバグを修正しました(Tatsuo, Kitagawa)
 <li>ユーザ名の長さが32バイトのときにpgpool子プロセスがクラッシュするパスワード認証のバグを修正しました(Tatsuo)
 <li>rawモードまたはバックエンドノード数が1のときに、pgpool子プロセスがクラッシュするmd5認証のバグを修正しました。パッチはRob Shepherdさんから頂きました(Tatsuo)
 <li>以前からあった配列と複合型に対するタイムスタンプ書き換えのバグを修正しました。パッチはAkio Ishidaさんから頂きました(Tatsuo)
 <li>debug_levelパラメータが動作しないバグを修正しました。パッチはGilles Daroldさんから頂きました(Tatsuo)
 <li>フェイルオーバー中に起こりうるpgpool子プロセスのクラッシュを修正しました(Kitagawa)
 <li>ユーザがスキーマ名の付いた関数を呼んだときにwhite/black_function_listが正しく動作するように修正しました(Tatsuo)
 <li>コネクションキャッシュによってDROP DATABASEが失敗するバグを修正しました(Kitagawa)
 <li>rawモードでフェイルオーバが失敗するバグを修正しました(Kitagawa)
 <li>1セッションで簡易問い合わせプロトコルと拡張問い合わせプロトコルの両方が使われたときに起こりうるpgpool子プロセスの終了を修正しました(Kitagawa)
 <li>拡張問い合わせプロトコルを使用中にエラーが発生すると起こりうるハングアップを修正しました(Kitagawa)
 <li>PG_TRY/CATCHを使用しないようにpgpool-regclass()を修正しました。PG_TRY/CATCHは、時々バックエンドが「PANIC:  ERRORDATA_STACK_SIZE exceeded.」というメッセージとともに終了するので安全でないように見えます(Tatsuo)
 <li>JDBCドライバがマスタノードに何度もBEGINを発行するロードバランスのバグを修正しました(Kitagawa)
 <li>failback_commandとfail_over_on_backend_errorが正しい値を表示するようにpool_statusを修正しました(Kitagawa)
 <li>pool_statusからrecovery_passwordとsystem_db_passwordを削除しました(Kitagawa)
 <li>ストリーミングレプリケーションモードでフェイルオーバを実行中に、バックエンドのログに「unexpected EOF on client connection」が出ないように修正しました(Tatsuo)
 <li>バックエンドがすべてダウンした場合に発生するpgpoolのクラッシュを修正しました(Tatsuo)
 <li>レプリケーション遅延チェックがバックエンドとの永続的な接続を行わないように修正しました。これは、レプリケーション遅延チェックの間でDBノードのダウンとアップが起きた場合に永続的な接続が不正になる可能性があるためです(Tatsuo)
 <li>英語ドキュメントを書き直してレビューしました(Marc Cousin, Gleu)
 <li>以下の条件を満たすとき SELECT クエリがマスタノードに送信されないバグを修正しました(Kitagawa)
 <ul>
  <li>マスタースレーブモードである
  <li>拡張問い合わせプロトコルを使用している
  <li>明示的にトランザクションを開始している
  <li>更新クエリを実行した後である
 </ul>
 <li>ストリーミングレプリケーションモード利用時のオンラインリカバリにおいて、以下のシナリオがうまく動作しない問題を修正しました。以下のシナリオでは、ノード0を最初のプライマリサーバ、ノード1を最初のスタンバイサーバとします。
      <p>
      <ol>
       <li>ノード0プライマリサーバがダウンし、ノード1スタンバイサーバが新しいプライマリサーバになる
       <li>ノード0の旧プライマリサーバは、オンラインリカバリで新スタンバイサーバになる
       <li>このときpgpool-IIは、ノード0の新スタンバイサーバを、プライマリサーバとみなしてしまう
      </ol>
      </p>
      これは、生きているノード番号の一番若いサーバをプライマリサーバと見なしていたためです。
      pgpool-II 3.0.3では、pgpool_walrecrunning()を使って、実際にそのノードがプライマリサーバかどうか判定するため、このような問題は起きません。
この機能をうまく使うために、オンラインリカバリのスクリプトで%P(古いプライマリノード番号)が利用できるようになっています。
なお、pgpool_walrecrunning()がインストールされていない場合は、上の問題は解消されず、3.0.1と同様の動作になります。
</ul>
</p>

<h3>改良</h3>
<p>
<ul>
 <li>ステータスファイルを読んでいるときに、特定のバックエンドがダウン状態ならばログを出力するようにしました(Tatsuo)
 <li>pgpoolが実行したクエリでエラーが発生した場合に、エラーメッセージを出力するようにしました(Tatsuo)
 <li>sqlディレクトリに主要なMakefileを追加しました(Tatsuo)
</ul>
</p>

<h2><a name="release3.0.2"></a>3.0.2(umiyameboshi) 2011/02/17</h2>
<h3>概要</h3>
<p>
このバージョンは問題があったために、リリースが取り消されました。
</p>

<h2><a name="release3.0.1"></a>3.0.1 (umiyameboshi) 2010/10/19</h2>
<h3>概要</h3>
<p>
このバージョンでは、3.0における様々なバグが修正されています。
</p>

<h3>バグ修正</h3>
<p>
<ul>
 <li>認証されるサーバが複数ある場合にクラッシュするmd5認証のバグを修正しました(Tatsuo)
 <li>拡張問い合わせプロトコルにおいて、構文エラーのクエリを実行したときに子プロセスがクラッシュするバグを修正しました(Kitagawa)
 <li>ポータル情報のハンドリングにおける子プロセスが終了するバグを修正しました(Kitagawa)
 <li>拡張問い合わせプロトコルにおいて、ひとつのノードに送信されたクエリがエラーを起こしたときにハングアップするバグを修正しました(Kitagawa)
 <li>英語ドキュメントの誤植を修正しました。Asaf Ohaionさんのパッチを取り込みました(Tatsuo)
</ul>
</p>

<h2><a name="release3.0"></a>3.0 (umiyameboshi) 2010/09/10</h2>
<h3>概要</h3>
<p>
このバージョンは3.0系列の最初の版で、2.2系や2.3系からの「メジャーバージョンアップ」にあたります。
PostgreSQL 9.0の新機能であるStreaming Replication/Hot Standby構成に対応するなど、多くの機能が追加されると共に、内部構造が整理されて見通しが良くなって保守性が向上しています。
</p>
<p>
マスタースレーブモード全般で多くの改善がなされています。
<ul>
 <li>明示的なトランザクション内のSELECTが負荷分散できるようになりました
 <li>不必要なDBノードにparse/bindメッセージが送られなくなりロック競合が減りました
 <li>不必要な内部トランザクションの起動がなくなり、オーバヘッドが軽減しています
 <li>一時テーブルを意識せずに安全に使えるようになりました
 <li>書き込みを伴う関数呼び出しを行なうSELECTをマスター(primay)でのみ実行するように制御できるようになりました
</ul>
</p>
<p>
レプリケーションモードにおいても、書き込みを伴う関数呼び出しを行なうSELECTを負荷分散するかどうかの制御できるようになるなどの改良が加えられています。
</p>

<h3>新機能</h3>
<p>
<ul>
 <li>PostgreSQL 9.0の新機能であるStreaming Replication/Hot Standby(SR+HS)構成に対応しました(Tatsuo, Kitagawa)。
pgpool-IIは基本的にはmaster/slave modeとして動作しますが、その際に "master_slave_sub_mode" という新しい設定項目に"stream"を設定することにより、SR+HS構成に最適な動作をします。
たとえば、更新クエリはPrimaryサーバにのみ送信し、SELECTはPrimaryとStandbyサーバに負荷分散することが可能です。
そのほか、Standbyサーバをオンラインリカバリで復旧したり、PrimaryとStandbyのレプリケーション同期を監視し、遅れが大きいようならPrimaryにのみSELECTを送信させるようにすることも可能です。
詳細は<a href="#stream">Streaming Replicationへの対応"</a>をご覧下さい。
</p>

<ul>
 <li>オンラインリカバリがStreaming Replication対応で動作しているmaster/slaveモードに対応しました(Tatsuo)

 <li>Streaming Replicationモード用の新しい設定項目 "delay_threshold" が追加され、レプリケーションの遅れが監視できるようになりました。
遅延が多い場合には、負荷分散しないようにすることができます(Tatsuo)

 <li>show pool_statusで、Streaming Replicationにおけるレプリケーションの遅延が確認できるようになりました(Tatsuo)

 <li>Streaming Replicationにおけるレプリケーションの遅延のログを制御する新しい設定項目"log_standby_delay"が追加されました(Tatsuo)

</ul>

 <li>insert_lockが有効で、テーブルにシリアル型が含まれている場合、テーブルロックではなく、該当シーケンスを行ロックするようにしました。
以前はテーブルロックをしていましたが、auto vacuumとロックが衝突したりして性能が低下する問題がありました(Tatsuo)

 <li>新しい"SHOW"コマンドが追加されました。すなわち、pool_nodes, pool_processes, pool_pools, pool_versionです(Guillaume Lelarge)

 <li>pcp_proc_infoコマンドの出力結果に、PostgreSQLバックエンドプロセスのプロセスIDとフロントエンドからの接続があるかどうかが追加されました(Tatsuo)

 <li>関数呼び出しを伴うSELECTを制御する設定項目white_function_listとback_function_listが追加されました(Tatsuo)

 <li>マスタースレーブモードにおいて、システムカタログを検索するSELECTは、整合性を保つために常にマスター(primary)で実行されるようになりました(Tatsuo)

 <li>マスタースレーブモードにおいて、一時テーブルを検索するSELECTは、整合性を保つために常にマスター(primary)で実行されるようになりました(Tatsuo)

 <li>マスタスレーブモードで、明示的なトランザクション内で実行されない更新クエリにおいて、自動的にトランザクションを開始することを止めました。これは不必要でした。これによって、パフォーマンスが向上しています(Tatsuo)

 <li>マスタスレーブモードで、明示的なトランザクション内で実行されるSELECTコマンドが負荷分散できるようになりました(Tatsuo, Kitagawa)

 <li>マスタスレーブモードで、必要なDBノードにのみコマンドが送られるようになりました。
これにより、たとえばパースコマンドが不必要なDBノードにおいてもロックを取ってしまうようなことがなくなりました(Tatsuo, Kitagawa)

 <li>pgpoolの起動時に、ステータスファイルを無視するオプションが追加されました(Tatsuo)

 <li>PostgreSQL 9.0のVACUUMの新しい書式をpgpool-IIのパーサがサポートしました(Tatsuo)

 <li>フェイルオーバ/フェイルバックコマンドで、"%H"という特殊変数が利用できるようになりました。
これは、新しいマスターノードのホスト名を表します(Tatsuo)

 <li>failover_if_affected_tuples_mismatch という設定項目が追加されました(Tatsuo)
従来、レプリケーションモードでINSERT/UPDATE/DELETEの結果行数が異なると、トランザクションをアボートしてセッションを強制切断していました。
failover_if_affected_tuples_mismatch を trueに設定すると、この現象が起きたときに、不一致のあったDBノードを切り放して縮退運転に入るようになります。

 <li>レプリケーションモードでDBノード間でINSERT/UPDATE/DELETEの結果行数の不一致が検出された際に、各DBノードにおける結果行数がログに記録されるようになりました(Tatsuo)

 <li>レプリケーションモードとマスタスレーブモードで、md5認証がサポートされました(Tatsuo)

 <li>オンラインリカバリで、強制的にフロントエンドへの接続を切断して直ちにセカンドステージに入ることができるようになりました。そのためには、client_idle_limit_in_recovery に -1 を設定します(Tatsuo)

 <li>RAWモードにおいて、DBノードが1個だけしか存在しない状態でDBがエラーを起したためにDBノードを切り放したあとでDBノードが回復した場合に、pgpool-IIを再起動することになしにDBノードを利用できるようになりました(Tatsuo)

 <li>pcpコマンドにおいて、ロングオプションがサポートされました(Guillaume Lelarge)

 <li>debug_level という設定項目が追加され、pgpool.confの再読み込みによってデバッグメッセージの出力をオン／オフできるようになりました(Tatsuo)

 <li>pgpool.confで、postgresql.confと同じ真偽値表現が利用できるようになりました。従来は、true/false, 1/0しか使えませんでした(Kitagawa)

 <li>オンラインリカバリのセカンドステージをより安全に実行するために、C言語関数pgpool_switch_xlogを追加しました(Kitagawa)

 <li>異なるスキーマに同じ名前のテーブルが存在する場合に起きる不具合を回避するために、C言語関数pgpool_regclassを追加しました(Tatsuo)

</ul>
</p>

<h3>互換性のない変更</h3>
<p>
<ul>
<li>replicate_selectとload_balance_modeを共にtrueに設定した場合、トランザクションブロックの外側で実行されるSELECT文は、replicate_selectに従うようになりました。以前は、load_balance_modeに従うようになっていました。もしクライアントがこの動作を利用している場合は、replicate_selectをfalseにしてback_function_listを設定することで同じ動作を実現できます。</li>
</ul>
</p>

<p>
<h3>バグ修正</h3>
</p>
<p>
<ul>

 <li>型が時刻データ以外の列の場合、デフォルト値にnow()が含まれていても書き換えを行なわないようにしました。
今までは無条件に書き換えを行なっていたため、書き換えの結果、INSERT文などがエラーになっていました(Tatsuo)

 <li>タイムスタンプの書き換え処理対象となるテーブルのスキーマが無視されないようにしました。
ただし、この機能を有効にするためには、付属のユーザ定義関数"pgpool_regclass"のインストールが必要です。
この関数がインストールされていない場合は、依然としてスキーマが無視されてしまいます(Tatsuo)

 <li>pcpコマンドのタイムアウトの扱いにおけるバグが修正されました(Tatsuo)

 <li>SSLが有効な状態で、大量のデータ通信が起るとハングする問題が修正されました(Tatsuo)

 <li>DBノードが1個だけしか存在しない状態でDBがエラーを起したた際に、間違ったDBノードがフェイルオーバするバグを修正しました(Tatsuo)

 <li>オンラインリカバリ時のpostmasterの起動チェックにおけるバグを修正しました。
今まではpostmasterへの最初の接続が失敗すると、接続を無限に繰り返すようになっていました(Tatsuo)

</ul>
</p>

<h2><a name="release2.3.3"></a>2.3.3 (tomiteboshi) 2010/04/23</h2>
<h3>概要</h3>
<p>このバージョンでは、2.3.2.2 以前の色々なバグが修正されています。</p>

<h3>互換性のない変更</h3>
<ul>
<li>このバージョンから、pgpool が以前より多くの共有メモリを使うようになったので注意してください。
これによる問題が pgpool の起動時に発生した場合は、pgpool のログを見てください。
"could not create shared memory segment: Cannot allocate memory" といったメッセージがあれば、システムの共有メモリを増やしてください。</li>
<li>パラレルモードが、レプリケーションモードかロードバランスモードが有効でないと使えないようになりました。
pgpool-II ではずっと、レプリケーションモードかロードバランスモードが有効でないときパラレルモードは正しく動作していませんでした。(Kitagawa)</li>
<li>insert_lock のデフォルト値を false に変更しました。これは、マスタ・スレーブモードでは true にしても無意味なためです。
Fujii Masao さんの指摘により修正しました。(Tatsuo)</li>
</ul>

<h3>新しく追加したドキュメント</h3>
<ul>
<li>README.online-recovery を追加しました。このドキュメントには、オンラインリカバリの内部的なことが書いてあります。</li>
</ul>

<h3>バグ修正</h3>
<ul>
<li>子プロセスが segfault を起こす pgpool-II 1.0 から長い間存在したバグを修正しました。
これは、親プロセスが shmem サイズの計算を間違えていたことに起因します。バグ解析(Kitagawa)、パッチ作成(Tatsuo)</li>

<li>ドキュメントにパラレルモード用の以下の制約を追記しました。(Kitagawa)
  <ul>
  <li>- NATURAL JOIN は使えません。</li>
  <li>- USING 句が、クエリ書き換え処理によって ON 句に変換されます。</li>
  </ul>
</li>

<li>パラレルモードのとき、USING 句を含む JOIN 構文の書き換えで発生する可能性があったクラッシュを修正しました。(Kitagawa)<br>
  この修正により、以下のような JOIN 構文が使えるようになります。<br>
  例：<pre>
SELECT * FROM a JOIN b USING (aid) JOIN c USING (cid);
SELECT * FROM a JOIN b USING (aid) JOIN c USING (cid) JOIN d USING</pre>
</li>

<li>パラレルクエリで、分散キー列の前に current_time を含む INSERT 文のパースができるように修正しました。</li>

<li>SimpleForwardToBackend() を修正しました。
これにより、拡張プロトコルを使ったクライアントが bind エラーのようなエラーを発生させたときに、
pgpool がバックエンドの応答を待ち続けなくなります。
このバグは、マスタ・スレーブモード、raw モード、コネクションプールモードで発生していました。
これを修正したことによって、コマンドがエラーになったあと、エラーを回復させるために SYNC メッセージを送るようになります。(Kitagawa)</li>

<li>select() を実行中の pgpool 子プロセスが、SIGINT/SIGQUIT シグナルを無視するように修正しました。
シグナルが送られても pgpool は select() を再実行しようとするので、結果的にシグナルが無視されます。(Tatsuo)</li>

<li>connect_inet_domain_socket_by_port/connect_unix_domain_socket_by_port が SIGTERM/SIGINT/SIGQUIT シグナルを
受け取っていないかチェックするように修正しました。 Daniel Codina さんからのバグ報告に基づきます。(Tatsuo)</li>

<li>"kind mismatch" というエラーメッセージを生成する際にクラッシュする可能性があったので、これを修正しました。
以前は問題なかったのですが、2.3.2でエンバグしました。(Tatsuo)</li>

<li>ヘルスチェックにおけるバグを修正しました。
コードが抜けたなどでネットワーク障害が発生したときに、connect() を呼んでいる間はヘルスチェックが行なわれていませんでした。
これは、connect() が ALARM シグナルによって割り込まれた際に、connect_unix_domain_socket()/connect_inet_domain_socket() が再試行していたためです。
この修正では、上記の関数に対して再試行をコントロールするような引数を追加しています。
これは、Daniel Codina さんのバグ報告と分析に基づく修正です。(Tatsuo)</li>

<li>2.3.2.2 で、SimpleForwardToBackend でのタイムスタンプの書き換えにおいてエンバグしてい
たので、これを修正しました。これは、バグトラック #1010771 にある Peter Pramberge さんらの報告に基づきます。(Tatsuo)</li>

<li>パラレルクエリにおける "*" の書き換えを修正しました。sho さんから提供いただいたパッチを取り込みました。(Kitagawa)</li>

<li>connect_inet_domain_socket_by_port() でエラーメッセージを出力する際に、
strerror() ではなく hstrerror() を使うように修正しました。 (Tatsuo)</li>
</ul>

<h2><a name="release2.3.2.2"></a>2.3.2.2 (tomiteboshi) 2010/02/22</h2>
<h3>概要</h3>
<p>
このバージョンでは、2.3.xにおける様々なバグを修正しています。
とくにタイムスタンプの書き換え時のクラッシュを含む致命的なバグが修正されているので、
すべての2.3ユーザは早急にアップグレードすることをお勧めします。
</p>

<h3>バグ修正</h3>
<p>
<ul>
 <li>タイムスタンプデータを含む拡張プロトコル問い合わせで、"message: invalid string in message"のエラーを出してトランザクションが終了してしまうバグを修正しました(Tatsuo)
 <li>タイムスタンプデータを含む拡張プロトコル問い合わせで、bind時にNULLを含むパラメータが存在するとpgpoolがクラッシュするバグを修正しました(Tatsuo)
 <li>pgpool_status上ですべてのノードがダウンのときにはこれを無効とし、「all node down症候群」が起きないようにしました(Tatsuo)
</ul>
</p>

<h2><a name="release2.3.2.1"></a>2.3.2.1 (tomiteboshi) 2010/02/11</h2>
<h3>概要</h3>
<p>
このバージョンでは、2.3.xにおいて、エラーとなるようなSQLを実行するとpgpoolへのセッションが切断されるバグを修正しています(Akio Ishida)。
</p>

<h2><a name="release2.3.2"></a>2.3.2 (tomiteboshi) 2010/02/07</h2>
<h3>概要</h3>
<p>
このバージョンでは、2.3.1の色々なバグが修正されています。
特に、タイムスタンプの書き換え機能のバグが修正されているので、2.3, 2.3.1ユーザはなるべく早く2.3.2にアップグレードすることをお勧めします。
</p>
<p>
また、2.3.2ではSSLサポート、ラージオブジェクトのレプリケーション機能が追加されています。
</p>

<h3>改良点</h3>
<p>
<ul>
 <li>フロントエンドとpgpool-II、pgpool-IIとPostgreSQLの間のSSL通信がサポートされました(Sean Finney)
 <li>ラージオブジェクトのレプリケーションがサポートされました(Tatsuo)
 <li>ヘルスチェックとオンラインリカバリの際に可能であればpostgresデータベースを使うようにしました。
      postgresデータベースが存在しない場合はtemplate1が使われます(以前の動作と同じ)。
      これにより、DROP DATABASEなどのコマンドがオンラインリカバリ中でも使えるようになりました(Tatsuo)
 <li>問い合わせのパース処理でエラーが起きたときに、SQL文をログに出力するようにしました。
      エンコーディングエラーなどが発生した際にはPostgreSQLのログにもSQL文が記録されないため、これは有効です(Tatsuo)
 <li>kind mismatchエラーが発生し、その原因がDEALLOCATEコマンドだった場合にDEALLOCATEが削除しようとしたPREPARED文の元になったSQL文をログに出力するようにしました(Tatsuo)
</ul>
</p>

<h3>バグ修正</h3>
<p>
<ul>
 <li>たまにタイムスタンプを書き換えた問い合わせがマスタ以外のDBノードに不正なパケットを送ってしまう問題を修正しました(Tatsuo)
 <li>V2プロトコルでタイムスタンプの書き換え処理がエラーになるのを修正しました(Toshihiro Kitagawa)
 <li>master/slaveモード、かつトランザクション内で発行されるBind、Describe、Closeメッセージはマスタだけに送るようにしました(Tatsuo)
 <li>2.3でsmart shutdownによりすぐに停止しなくなったバグを修正しました(Toshihiro Kitagawa)
 <li>フロントエンドからの不正なコマンドを受け付けないようにしました(Xavier Noguer)
 <li>移植性を高めるために、fprintfの引数に%dzを使用するようにしました(Tatsuo)
 <li>コンパイラワーニングを修正しました(Tatsuo)
 <li>master/slaveモードの際に、DEALLOCATEをすべてのノードに送らないようにして、kind mismatchエラーを防ぐようにしました(Tatsuo)
</ul>
</p>

<h2><a name="release2.3.1"></a>2.3.1 (tomiteboshi) 2009/12/18</h2>
<h3>概要</h3>
<p>
このバージョンでは、2.3の色々なバグが修正されています。
特に、ある条件でDBに不正な数値が書き込まれるバグが修正されており、以下の示す条件に合致する使い方をしている2.3ユーザは至急バージョンアップすることをお勧めします。
</p>

<h3>バグ修正と改良点</h3>
<p>
<ul>
 <li>以下のすべての条件に合致する場合、DBに不正な値が書き込まれるバグを修正しました(Tatsuo)
      <p>
      <ol>
       <li>レプリケーションモードで動作
       <li>64bit OS
       <li>INSERTまたはUPDATEにおいて、now(), CURRENT_TIMESTAMP, CURRENT_DATE, CURRENT_TIMEを直接含むか、テーブルのデフォルト値に含んでいる
       <li>更にそのSQL内に32bit(10進で-2147483648から2147483647)の範囲を超える整数定数が含まれている
      </ol>
      以上を満たすSQLの例:
      <pre>
      INSERT INTO t1(id, regdate) VALUES(98887776655, NOW());
      </pre>
      この例では、98887776655が32bit値にカットされて書き込まれます。
      </p>

  <li>18以上のDBノードを使用している場合に、show pool_statusでクラッシュするバグを修正しました。
このバグはshow pool_statusが実装されてからずっと存在していたものです。

  <li>"kind mismatch"メッセージが出た際に、kindがERRORまたはNOTICEならば、そのメッセージを表示するようにしました。これにより、PostgreSQLのログを見なくてもkind mismatchエラーの原因を容易に調べることができるようになりました(Tatsuo)
 </ul>
</p>

<h2><a name="release2.3"></a>2.3 (tomiteboshi) 2009/12/07</h2>
<h3>概要</h3>
<p>
このバージョンでは、レプリケーション機能に改良が加えられ、時刻データ(CURRENT_TIMESTAMP, CURRENT_DATE, now()など)を正しく扱うことができるようになりました。
また、同時接続数が1(num_init_childrenが1)のときのレプリケーション性能向上しています。
また、pgpool-II再起動時に前回のDBノードのダウン状態を記録し、不用意に復旧ノードにデータを書き込んでデータの不整合が起きることを防ぐことができるようになりました。
そのほか、クエリログが改良されてDBノード単位の状況が把握しやすくなり、またフェイルオーバの挙動が細かく制御できるようになりました。
なお、pgpool-II 2.3には、pgpool-II 2.2.1から2.2.6までのすべてのバグ修正、改良が含まれています。
</p>

<h3>pgpool-II 2.2.からの非互換性</h3>
<ul>
<li>[logdir]の下にpgpool_statusというファイルが作られるので、pgpoolの実行ユーザが読み書きできる権限を与えておいてください。
</ul>

<h3>改良点</h3>
<ul>
<li>レプリケーションにおいて、時刻データ(CURRENT_TIMESTAMP, CURRENT_DATE, now()など)を正しく扱うことができるようになりました。特にアプリケーションに変更を加えることなく、INSERT/UPDATE文、テーブルのデフォルト値にこれらの時刻関数を含むケースでも正しくレプリケーションできます(いくつか制限事項があります。詳細は<a href="#restriction">制限事項</a>を参照してください)。(Akio Ishida)
<li>SQLパーサをPostgreSQL 8.4のものにバージョンアップしました(Akio Ishida)
<li>同時接続数が1(num_init_childrenが1)のときのレプリケーション性能が20%から100%向上しました(Tatsuo)
<li>新しいディレクティブlog_per_node_statementが追加されました(Tatsuo)
log_statementと似ていますが、DBノード単位でログが出力されるので、レプリケーションや負荷分散の確認が容易です。
また、バックエンドのプロセスIDも表示されるので、バックエンドのログと併せての解析が容易になっています。
<li>新しいディレクティブfail_over_on_backend_errorが追加され、フェイルオーバの挙動がより細かく制御できるようになりました(Tatsuo)
<li>pgpool-II停止時にダウンしたDBノードの情報をステータスファイルに記録し、pgpool-IIを起動したときにその情報をリストアできるようにしました(Tatsuo)
ステータスファイルは [logdir]/pgpoo_status というファイルに書かれます。
<li>EXPLAINと、問い合わせがSELECTのときのEXPLAIN ANALYZEが負荷分散されるようになりました。
これによって、DBノードの間で大幅に問い合わせプランが異るために、kind mismatchエラーが起きるのを防ぐことができます(Tatsuo)
<li>日本語ドキュメントの体裁を改良しました(Tatsuo)
<li>レプリケーションモード、マスタースレーブモード用のデフォルトpgpoo.conf.sampleが別途追加されました(Tatsuo)
<li>時刻データのテストが追加されました(Akio Ishida)
</ul>

</p>

<h2>2.2.6 (urukiboshi) 2009/12/01</h2>
<h3>概要</h3>
<p>
このバージョンでは、ロードバランスの重みパラメータweightの扱いが改善され、
また一時テーブルがマスター／スレーブモードで利用できるようになりました。
もちろんいつものように2.2.5以前の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
<li>DECLARE, CLOSE, FETCH, MOVEがロードバランスの対象にならなくなりました。
もしデータが更新され、トランザクションがコミットされた後にCLOSEが発行されるとデータの一貫性がなくなるからです
(つまり、holdできるカーソルの場合のことを言っています)(Tatsuo)
<li>マスター／スレーブモードにおいて、拡張プロトコルのParseをマスター上でのみ実行するようにしました。
以前はすべてのノードでParseが実行されていたのですが、これだと不必要なロックがスレーブでも取られてしまいます(Tatsuo)
<li>uninstallの前にすべてのランレベルからinitスクリプトを削除するようにしました(Devrim)
<li>認証に失敗したときに適切なエラーメッセージを出すようにしました(Glyn Astill)
<li>ソケットへの書き込みに失敗したときにフロントエンド用なのかバックエンド用なのかわかるようにしました(Tatsuo)
<li>フロントエンド用のソケットに書き込み失敗したときにいちいちエラーを出さないようにしました(Tatsuo)
<li>マスター／スレーブモードで一時テーブルが使えるようになりました。
INSERT/UPDATE/DELETEは自動的にマスタのみに送られます。SELECTに関しては明示的にクエリの前に
/*NO LOAD BALANCE*/というコメントを付けなければなりません(Tatsuo)
</ul>
</p>

<h2>2.2.5 (urukiboshi) 2009/10/4</h2>
<h3>概要</h3>
<p>
このバージョンでは、2.2.4以前の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
<li>コネクション数のカウントのミスにより、オンラインリカバリが終わらなくなるバグを修正しました(Tatsuo)
<li>内部的にロックを発行する際にもフロントエンドが異常終了したことを検出してSQLコマンドをキャンセルするようにしました(Tatsuo)
<li>接続の終了処理で無限ループに陥ることがあるバグを修正しました(Xavier Noguer, Tatsuo)
<li>拡張プロトコルのパース処理でkind mismatch errorが起きた際に正しいSQL文を表示するようにしました(Tatsuo)
<li>ドキュメントを改善しました(Tatsuo)
</ul>
</p>

<h2>2.2.4 (urukiboshi) 2009/8/24</h2>
<h3>概要</h3>
<p>
このバージョンでは、2.2.3以前の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
 <li>pgpool-II 2.2.2で入ってしまったバグを修正しました。フロントエンドがアボートするタイミングによっては、以後内部状態がリセットされず、次のセッションでDMLやDDLがマスターノードのみ送られ、ノード間でデータの不一致が生じることがありました(Tatsuo)
 <li>pgpool-II 2.2.3でバージョン2プロトコルのクライアントが動かなくなってしまっていたのを修正しました。
      また、時間のかかるクエリを待っている間にフロントエンドが異常終了したことを検知する間隔を1秒から30秒に変更しました。このチェックは、2.2.4ではプロトコルバージョンが3のときのみ有効です(Tatsuo)
 <li>子プロセスを起動する前にシグナルのブロックやハンドラの設定を行なうようにしました。
これは、pgpool-IIを起動した直後にフェイルオーバなどの事象が発生して子プロセスから親プロセスにシグナルが送られると、pgpool-IIの親プロセスが死んでしまうことがあるからです(Tatsuo)
</ul>
</p>

<h2>2.2.3 (urukiboshi) 2009/8/11</h2>
<h3>概要</h3>
<p>
このバージョンでは、2.2.2以前の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
 <li>バックエンドに新しいコネクションを張る際に、バックエンドの一つが障害を起しているケースで、後処理の中でpgpool-IIの子プロセスが落ちることがあるバグを修正しました(Tatsuo)
 <li>パラレルクエリのバグを修正しました(Yoshiharu Mori)
 <li>拡張プロトコルの場合にもエラーメッセージの中で最後に使用したクエリが表示できるようになりました(Akio Ishida)
 <li>kind mismatch errorメッセージの作成で、メッセージ内容が壊れることがあるバグを修正しました(Tatsuo, Akio Ishida)
 <li>バックエンドへの接続記述子の参照タイミングによってはpgpool-IIの子プロセスが落ちることがあるバグを修正しました(Tatsuo)。
 <li>pool_errorやpool_logの引数が間違っていた個所を修正しました(Akio Ishida)。
 <li>statement_timeoutのタイムアウトによるエラー処理を改良しました。実際にはタイムアウトまでにstatement_timeoutで設定した時間の倍かかっていたのを直しました。また、masterだけがstatement_timeoutを返した場合にも対応できるようにしました。以前はkind mismatchエラーになっていました(Tatsuo)。
(master以外がstatement_timeoutを返さないケースではkind mismatchエラーになります)。

 <li>health checkをより強化し、postmasterがSIGSTOPで止ってしまっている場合も障害検知できるようにしました。

 <li>バックエンドにSQLを投げ、その応答を待っている間にクライアントがpgpoolに対するコネクションを切断したことが検出できるようになりました。
たとえば、WebアプリケーションではDBに対してリクエストを投げて、応答がないとキャンセルするようなことが頻繁に起ります。
この場合、今まではpgpoolやPostgreSQLのプロセスが残ってしまい、同時接続数が枯渇したり、ロックを取ったままのトランザクションが残るなどしてシステム全体に影響を与えることがありました。
今回の修正により、こうした状況が検出できるようになっただけでなく、SQLの応答待ちの間にクライアントがコネクションを切断した際には、SQLコマンドのキャンセルをpgpoolが行なって、ロック待ちなどのバックエンドプロセスが残るのを防ぐことができるようになりました(Tatsuo)。

<li>引数なしのCLUSTERコマンドはトランザクションの中では実行できないので、自動トランザクションをスタートしないようにしました(Tatsuo)。

<li>複数のプリペアドステートメントを使っている際に、セッションの終りでその一部だけが解放されるバグを修正しました(Akio Ishida)
。
<li>sql/pgpool-recovery/pgpool-recovery.cがPostgreSQL 8.4でコンパイルできるようにしました(Tatsuo)。

<li>拡張プロトコルを使っている場合に、クライアントとpgpoolの間でお互いに待ち状態になってしまうことがあるバグを修正しました(Gavin Sherry)。

<li>COPY FROMを実行中にクライアントが処理を中断した場合に、バックエンドプロセスが残ってしまうバグを修正しました(Tatsuo)。

</ul>

<h2>2.2.2 (urukiboshi) 2009/5/5</h2>
<h3>概要</h3>
<p>
このバージョンでは、2.2.1以前の色々なバグが修正されています。
とりわけ、pgpoolがクライアントとの間でデータのやり取りをしている最中に、pgpoolのクライアントが終了(X)パケットをpgpoolに送信せずに終了した場合に起る可能性があります。
このバグは過去のすべてのpgpoolに存在しています。
</p>
<h3>バグ修正</h3>
<ul>
  <li>フロントエンドにpgpoolがデータを送信する際のエラーを無視するようにしました。これによって、バックエンドとの間で必要な処理が中断されないようになり、バックエンドの間でデータの一貫性がなくなる問題が回避されるようになりました(Tatsuo)。

  <li>マスタースレーブモードに関する2.2.1の修正の際に生じたバグを修正しました。プリペアドステートメントを使い回すとハングアップする可能性がありました(Toshihiro)。

  <li>SQLコマンドのPREPAREとプロトコルレベルのEXECUTEが混在するとバックエンドがクラッシュするバグを修正しました。このバグが、2.2で持ち込まれたものです(Tatsuo)。

  <li>コネクションのリセット用の問合わせを実行中にエラーが起きた場合に、PostgreSQLのログに"unexpected EOF on client connection"が記録される問題を修正しました(Tatsuo)。
</ul>

<h2>2.2.1 (urukiboshi) 2009/4/25</h2>
<h3>概要</h3>
<p>
このバージョンでは、2.2の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
  <li>master/slaveモードで、DEALLOCATEが失敗することがある問題を修正しました。
       これは、最初のPREPAREがslaveで実行されないことによるものです(Toshihiro)

  <li>pgpool.specなどを2.2対応にしました(Devrim)

  <li>Version 2プロトコルではinsert_lockが無視されるようにしました(Tatsuo)

  <li>パラメータ変更メッセージがバックエンドから届く度にログが出力されるのを止めました(Tatsuo)

  <li>ドキュメントで追加し忘れたファイルを登録しました(Tatsuo)
</ul>

<h2>2.2 (urukiboshi) 2009/2/28</h2>
<h3>概要</h3>
<p>
このバージョンでは、SERIALデータの扱いとオンラインリカバリに改良が行なわれています。
また、トランザクション分離レベルがシリアライザブルの場合に、DBノード間でデータの一貫性がなくなる可能性がある問題、クエリのキャンセルができない問題が修正されました。
</p>

<h3>新機能</h3>
<p>
<ul>
<li>insert_lockが有効な場合、SERIAL型を持つテーブルだけがロックされるようになりました(Tatsuo)。
<li>設定項目client_idle_limit_in_recoveryが追加されました。
     オンラインリカバリの第2ステージでクライアントがアイドルのまま居座ることによって、
     オンラインリカバリが進行しなくなることを防ぐことができます(Tatsuo)。
<li>設定項目pid_file_nameが追加されました。これは、pgpool-IIのpidファイルを指定します。
     これにより、logdirは使用されなくなりました(Tatsuo)。
<li>DECLARE, FETCH, CLOSEで負荷分散されるようになりました(Tatsuo)。
<li>pcpコマンドにデバッグオプション(-d)が追加されました(Jun Kuriyama)。
<li>"kind mismatch"エラーの際に、原因となったクエリを表示するようにしました(Tatsuo)。
</ul>
</p>

<h3>互換性</h3>
<ul>
  <li>フェイルオーバ時に必ずpgpoolの子プロセスを再起動するようにしました。
       この結果、フェイルオーバ時には必ずpgpoolへのセッションが一端切れることになります。
       こうしないと、ネットワークケーブル抜けなどの際に、
       TCP/IPのレイヤで再送が行なわれ、長い時間そのままになってしまうことが
       あるからです(Tatsuo)。
  <li>設定項目logdirは使われなくなりました。代りに、pid_file_nameを使ってください(Tatsuo)。

  <li>insert_lockのデフォルト値がtrueになりました(Tatsuo)。
</ul>

<h3>バグ修正</h3>
<ul>
  <li> pgpoolがデーモンモードで起動される際に、すべてのファイルディスクリプタを
       閉じるようにしました。こうしないと、pgpoolAdminから起動された際に
       apacheのソケットファイルを引き継いでしまい、80番ポートが
       専有されてしまいます(Akio Ishida)。
  <li> トランザクションをシリアライズできないエラーが発生したときに、
       すべてのDBノードのトランザクションをアボートするようにしました。
       こうしないと、DBノードの間でデータの不整合が起きることがあります(Tatsuo)。
       例を示します(Mはマスタ、Sはスレーブを示します)。
       <pre>
       M:S1:BEGIN;
       M:S2:BEGIN;
       S:S1:BEGIN;
       S:S2:BEGIN;
       M:S1:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       M:S2:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       S:S1:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       S:S2:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       M:S1:UPDATE t1 SET i = i + 1;
       S:S1:UPDATE t1 SET i = i + 1;
       M:S2:UPDATE t1 SET i = i + 1; <-- blocked
       S:S1:COMMIT;
       M:S1:COMMIT;
       M:S2:ERROR:  could not serialize access due to concurrent update
       S:S2:UPDATE t1 SET i = i + 1; <-- success in UPDATE and data becomes inconsistent!
       </pre>

 <li> rawモードでMD5認証が使えるようにしました。ドキュメント上では使えるはずでした(Tatsuo)。

 <li> "SET TRANSACTION ISOLATION LEVEL must be called before any query"の
       エラーが発生した場合に"kind mimatch"エラーになることを防ぐようにしました(Tatsuo)。
       以下のシナリオで問題が発生します。
       <pre>
       M:S1:BEGIN;
       S:S1:BEGIN;
       M:S1:SELECT 1; <-- only sent to MASTER
       M:S1:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       S:S1:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       M: <-- error
       S: <-- ok since no previous SELECT is sent. kind mismatch error occurs!
       </pre>

<li>FreeBSDにおいて、psでのprocess statusの表示で余計なスペースが含まれてしまうのを修正しました(Jun Kuriyama)

<li>BEGIN;を2度続けるとkind mismatch errorが発生するのを修正しました(Tatsuo)

<li>PostgreSQLがたくさんのDEBUGメッセージを出力する場合に、誤ってエラーと見なすバグを修正しました(Tatsuo)

<li>クエリのキャンセルが動くようになりました(Tatsuo)

<li>オンラインリカバリの後クライアントからの接続を受け付けるタイミングが早すぎるバグを修正しました。
このバグにより、ノードデータの貫性が保たれない可能性がありました(Tatsuo)

<li>SELECT, INSERT, UPDATE, DELETE以外のコマンドでも必要ならばトランザクションブロックの内側で実行するようにしました。
これにより、エラー発生の際にロールバックしてノードの整合性を保つことができます(Tatsuo)

<li>オンラインリカバリ後、pgpool-IIの子プロセスがクラッシュすることがあるバグを修正しました。
これは、オンラインリカバリの後、新しくアタッチされたノードに接続がないのに、そのノードに子プロセスが終了時に終了メッセージをバックエンドに送信しようとして起っていました(Tatsuo)

<li>PostgreSQLがpostgresql.confを再読み込みした際にpgpoolがエラーを検出してしまうバグを修正しました。
これは、PostgreSQLが（たぶん）ドキュメントに書かれていないタイミングで「パラメータ変更」パケットを送信してくるために起り、修正はそのことに対応したものです(Tatsuo)

</ul>

<h2>2.1 (inamiboshi) 2008/7/25</h2>
<h3>新機能</h3>
<ul>
  <li> failover_command と failback_command に、新しいマスタノード ID
  を表す '%m' をサポートしました。(Yoshiyuki)
  <li> failover_command と failback_command に、古いマスタノード ID を
  表す '%M' をサポートしました。(Yoshiyuki)
  <li> リカバリのタイムアウト時間を指定する recovery_timeout パラメー
  タを追加しました。(Taiki)
  <li> pg_md5 コマンドに -p オプションを追加しました。(Volkan Yazici,
  Taiki)
  <li> pgpool -v を実行するとバージョン番号を表示し、終了するようにし
  ました。(Yoshiyuki)
</ul>

<h3>互換性</h3>
<ul>
  <li> pgpool_recovery と pgpool_remote_start 関数はスーパーユーザのみ実行
  できるように権限チェックを強化しました。(Yoshiyuki)
  <li> raw モードでスタンバイノードにはコネクションプールを作成しない
  ようにしました。(Yoshiyuki)
  <li> replication_timeout パラメータを削除しました。(Yoshiyuki)
  <li> PCP クライアントコマンドのタイムアウトを無効にしました。(Taiki)
  <li> replicate_select = false の場合に、COPY TO STDOUT をレプリケー
  ションさせないようにしました。(Yoshiyuki)
</ul>

<h3>修正</h3>
<h4> 全般 </h4>
<ul>
  <li> CloseComplete メッセージを受けとるとクラッシュする不具合を修正
  しました。(Yoshiyuki)
  <li> メッセージ転送処理を効率よくしました。(Yoshiyuki)
  <li> Solaris 10 でコンパイルできるようにしました。(Yoshiyuki)
  <li> ヘルスチェックとリカバリのログ出力を改良しました。(Tatsuo)
  <li> 様々なメモリリークを修正しました。(Yoshiyuki)
  <li> "failed to read kind from frontend" というエラーメッセージを
  ERRORレベルから LOG レベルに下げました。(Yoshiyuki)
  <li> raw モードでフェイルオーバに失敗する不具合を修正しました。
  (Taiki)
  <li> 不正なノードを追加・切り離しを行うとゾンビプロセスが発生する不
  具合を修正しました。(Yoshiyuki)
  <li> health_check_timeout が正しく動作しない不具合を修正しました。
  (Kenichi Sawada)
  <li> FreeBSD で ps コマンドの出力が正しくない不具合を修正しました。
  (ISHIDA Akio)
  <li> Unix domain ソケットが残っている場合のエラーメッセージを強化し
  ました。(Jun Kuriyama)
  <li> 認証に失敗した場合のエラーメッセージを強化しました。(Tatsuo)
</ul>

<h4>レプリケーション</h4>
<ul>
  <li> replicate_select を設定しても、常に false の挙動になる不具合を
  修正しました。(Tatsuo)
  <li> 拡張問い合わせプロトコルを使っていると、トランザクションを誤ってロー
  ルバックしてしまう不具合を修正しました。(Yoshiyuki)
  <li> 非同期クエリを使っていると pgpool が不安定になる不具合を修正し
  ました。(Yoshiyuki)
  <li> 拡張問合せプロトコルを使うと /* REPLICATION */などのヒント句が消えて
  しまう不具合を修正しました。(Yoshiyuki)
  <li> DEALLOCATE ALL を実行するとクラッシュする不具合を修正しました。
  (Yoshiyuki)
  <li> immediate shutdown するとハングアップする不具合を修正しました。
  (Yoshiyuki)
  <li> 高負荷時にオンラインリカバリを実施すると、リカバリプロセスがハ
  ングアップする可能性のある不具合を修正しました。(Yoshiyuki)
  <li> 拡張問合せプロトコルを使って SELECT を実行した際に、トランザク
  ションブロック内でクエリがエラーになると、pgpool がハングアップする
  可能性のある不具合を修正しました。(Yoshiyuki)
</ul>

<h4>マスタースレーブ</h4>
<ul>
  <li> トランザクションブロック内で、SET, PREPARE, DEALLOCATE を実行す
  ると、プロセスがダウンする不具合を修正しました。(Yoshiyuki)
  <li> マスタースレーブモードでロードバランスが正しく動作していない不
  具合を修正しました。(Yoshiyuki)
</ul>

<h4>パラレルクエリ</h4>
<ul>
  <li> INSERT に失敗する不具合を修正しました。(Yoshiharu)
  <li> FROM 句に AS が含まれると構文エラーになる不具合を修正しました。(sho)
  <li> クエリを複数回実行するとハングアップする不具合を修正しました。(Yoshiharu)
  <li> JOIN に失敗する不具合を修正しました。(Yoshiharu)
  <li> DISTINCT構文 の解析に失敗する不具合を修正しました。(Yoshiharu)
</ul>

<hr>

<h2>2.0.1 (hikitsuboshi) 2007/11/21</h2>
<ul>
  <li> UPDATE もしくは DELETE を実行するとプロセスがダウンする不具合を
       修正しました。(Yoshiyuki) 
  <li> master_slave を true に設定している場合に、SQL 構文エラーを検知
       した時にマスタにのみそのクエリを送信するようにしました。(Yoshiyuki)
</ul>

<hr>

<h2>2.0 (hikitsuboshi) 2007/11/16</h2>
<h3>互換性</h3>
<ul>
  <li> ignore_leading_white_space のデフォルト値を true にしました。
  (Yoshiyuki)
  <li> replicate_strict を廃止しました。常に replicate_strict が true
  の挙動になります。(Yoshiyuki)
</ul>

<h3>全般</h3>
<ul>
  <li> pgpool.conf をリロードできるようにしました。リロード時に分散ルー
  ルも同時にリロードします。(Yoshiyuki)
  <li> SQL パーサを PostgreSQL 8.3 に対応しました。(Yoshiyuki)
  <li> ノードを切り離した際にユーザが設定したコマンドを実行できるよう
  に、pgpool.conf に failover_command というパラメータを追加しました。
  (Yoshiyuki)
  <li> ノードを復帰した際にユーザが設定したコマンドを実行できるように、
  pgpool.conf に failback_command というパラメータを追加しました。
  (Yoshiyuki)
  <li> pgpool.conf に client_idle_limit というパラメータを追加しました。
  このパラメータではクライアントからのクエリの最大待ち時間を設定するこ
  とができます。(Tatsuo)
</ul>

<h3>レプリケーション</h3>
<ul>
  <li> トランザクションブロックに囲まれていないクエリをレプリケーショ
  ンさせる場合、内部的にトランザクションを開始させるようにしました。
  (Yoshiyuki)
  <li> レプリケーションを高速化させるようにしました。(Yoshiyuki)
  <li> ノードを再同期させて復帰させる、オンラインリカバリ機能を実装し
  ました。(Yoshiyuki)
  <li> INSERT, UPDATE, DELETE した行数がすべて一致しなかった場合に、ト
  ランザクションをアボートさせるようにしました。(Yoshiyuki)
<pre>
   x=# update t set a = a + 1;
   ERROR:  pgpool detected difference of the number of update tuples
   HINT:  check data consistency between master and other db node
</pre>
  <li> 複数のバックエンドから異なる結果が返ってきた場合に、同じ結果が
  多数返ってきた結果を信頼する多数決方式を実装しました。(Yoshiyuki)
  <li> V2 問合せプロトコルでロードバランスできるようにしました。(Yoshiyuki)
</ul>

<h3>パラレルクエリ</h3>
<ul>
  <li> パラレルモードで部分レプリケーションをサポートしました。(Yoshiharu)
</ul>

<hr>

<h2>1.3 (sohiboshi) 2007/10/23</h2>
<ul>
  <li> 新しく authentication_timeout というパラメータを追加しました。(Yoshiyuki)
    <ul>
     <li>このパラメータでは認証時間のタイムアウトを設定します。 
     <li>デフォルト値は 60 (1 分)です。
   </ul>
  <li> スタートアップパケットの長さが 10000 バイト越えている場合には、接続を切断するようにしました。(Yoshiyuki)
  <li> DEALLOCATE を実行するとまれに不正なメモリアクセスが発生する不具
       合を修正しました。(Yoshiyuki)
  <li> トランザクション内で SELECT を実行した後に SELECT を正しくロードバラ
       ンスできない不具合を修正しました。(Yoshiyuki)
       <ul>
    <li> この不具合は 1.2 で混入した不具合です。
       </ul>
  <li> 64bit 環境でクエリキャッシュ機能を有効にすると、クラッシュする可能性のある不具合を修正しました(Yoshiyuki)
</ul>

<hr>

<h2>1.2.1 (tomoboshi) 2007/09/28</h2>
<ul>
  <li> 拡張問合せプロトコルの Parse メッセージの処理でデッドロックが発
  生する可能性がある不具合を修正しました。(Yoshiyuki)

  <li> Prepared statement を管理する領域がメモリリークしている不具合を
  修正しました。(Yoshiyuki)

  <li> 一部の OS でコンパイルエラーになる不具合を修正しました。(Yoshiyuki)

  <li>master/slave モード内で SET, PREPARE, DEALLOCATE 文をレプリケーションさせるようにしました。(Yoshiyuki)
</ul>

<hr>

<h2>1.2 (tomoboshi) 2007/08/01</h2>
<ul>
  <li> pgpool.conf に replicate_select という新規パラメータを追加しま
  した。デフォルト値は false です。(Yoshiyuki)
  <ul>
    <li> true に設定した場合は、ロードバランスされない SELECT 文をレプ
    リケーションします(pgpool-II 1.0 の挙動)。false の場合はマスタにの
    み SELECT を送信します。
  </ul>

  <li> シグナル処理を安全に行うようにしました。(Yoshiyuki)
  <ul>
    <li>まれにゾンビプロセスが残ってしまったり、不安定になることがありました。
  </ul>
  
  <li> トランザクション中に SELECT 文がエラーになると、ハングアップし
  てしまう不具合を修正しました。(Yoshiyuki)
  <ul>
    <li> この不具合は 1.1 に入った不具合です。
  </ul>

  <li> PREPARE/EXECUTE が master/slave モードで正しく動作しない不具合
  を修正しました。(Yoshiyuki)

  <li> デッドロックを検知すると、kind mismatch error が発生する不具合
  を修正しました。(Yoshiyuki)

  <li> 拡張問い合わせプロトコルを使ったドライバを使用した場合に、構文
        解析時に警告が発生する SQL 文を実行するとハングアップもしくは
        プロセスがクラッシュする不具合を修正しました。(Yoshiyuki)

  <li> コネクションキャッシュが一杯になるとメモリリークが発生する不具
  合を修正しました。(Yoshiyuki)

  <li> セッションが残った状態で PostgreSQL を fast shutdown もしくは
  immediate shutdown すると、残ったセッションがハングアップする不具合
  を修正しました。(Yoshiyuki)

  <li> ロードバランス先を接続開始時に決定し、同じセッション内ではすべ
  て同じノードにクエリを送信するようにしました。(Yoshiyuki)

  <li> connection_life_time を設定している場合にバッファオーバランが発
  生する可能性がある不具合を修正しました。(Yoshiyuki)

</ul>

<hr>

<h2>1.1.1 (amiboshi) 2007/06/15</h2>
<ul>
  <li> load_balance_mode を有効にしていると、"kind mismatch" エラーが
  発生してしまう不具合を修正しました。これは 1.1 で入った不具合です。
  (Yoshiyuki)
  <li> プロトコルバージョン 2 を使ったドライバでレプリケーション使用す
  ると、pgpool がハングアップする不具合を修正しました(Yoshiyuki)
  <li> 拡張問合せプロトコルを使用すると、まれにデッドロックが発生する
  不具合を修正しました(Yoshiyuki)
</ul>

<hr>

<h2>1.1 (amiboshi) 2007/05/25</h2>
<ul>
  <li> HBA 認証をサポートしました(Taiki)
  <li> log_connections をサポートしました(Taiki)
  <li> log_hostname をサポートしました(Taiki)
  <li> ps コマンドで pgpool の状態がわかるようにしました(Taiki)
  <li> MacOS X でコンパイルエラーになる不具合を修正しました(Yoshiyuki)
  <li> 拡張問い合わせプロトコルを使ったクエリをロードバランスできるよ
  うにしました(Yoshiyuki)
  <li> レプリケーション設定時、SELECT は master にのみ送信するようにし
  ました(Yoshiyuki)
    <ul>
      <li> もし SELECT をレプリケーションさせる場合は /*REPLICATION*/
      のように SELECT の前にコメントを付ける必要があります
    </ul>
  <li> レプリケーション設定時、SELECT nextval() および SELECT setval()
  を自動的にレプリケーションさせるようにしました(Yoshiyuki)
  <li> バックエンドへ接続中にシグナルに割り込まれると、フェイルオーバ
  してしまう不具合を修正しました(Yoshiyuki)
  <li> PAM 認証のサンプルファイル pgpool.pam を
  $PREFIX/share/pgpool-II/ にインストールするようにしました(Taiki)
  <li> 巨大な SQL を実行しようとした場合に pgpool が無限ループに入る不
  具合を修正しました(Yoshiyuki) 
</ul>

<hr>

<h2>1.0.2 (suboshi) 2007/02/13</h2>
<ul>
  <li> 巨大な SQL を実行しようとした場合に pgpool が無限ループに入る不
  具合を修正しました(Yoshiyuki) 
  <li> 拡張問合せプロトコルを使った場合にまれに pgpool が止まってしま
  う不具合を修正しました(Yoshiyuki) 
  <li> フェイルオーバ、フェイルバック時のログ出力を改善しました
  (Tatsuo)
  <li> SHOW pool_status の結果にバックエンドステータス情報を追加しまし
  た(Tatsuo)
  <li> レプリケーション時に UPDATE/DELETE の件数が実際の件数とは異なっ
  た結果を返す不具合を修正しました(Tatsuo)
  <li> 古い gcc を使うと libpq のリンクに失敗する不具合を修正しました
  (Yoshiyuki)
  <li> PHP:PDO や DBD-Pg を使った場合に、自動 DEALLOCATE が失敗してし
  まう不具合を修正しました(Yoshiyuki)
  <li> SELECT FOR UPDATE, SELECT INTO をロードバランスさせないようにし
  ました。また、SELECT の前にコメントがある場合もロードバランスさせな
  いようにしました。これは pgpool-I との互換性のためです。(Yoshiyuki)
  <li> configure 時の libpq のデフォルトパスを pg_config コマンドを使っ
  て取得するようにしました。なお、--with-pgsql 関連のオプションは次の
  バージョンでは廃止予定です(Yoshiyuki)
  <li> コネクションプール再利用時に、ソケットが壊れている場合は再接続
  するようにしました(Yoshiyuki)
  <li> PostgreSQL 7.4.x の libpq を使ってビルドしようとすると、
  configure スクリプトでエラーとなってしまう不具合を修正しました
  (Yoshiyuki)
</ul>

</div>

<div class="copyright" style="clear: both">
<hr>
<copyright>
Copyright &copy; 2003 &ndash; 2012 pgpool Global Development Group
</copyright>
</div>

</body>
</html>
