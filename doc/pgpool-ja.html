<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<link rel="stylesheet" href="./pgpool-ja.css" type="text/css">
<title>pgpool-II ユーザマニュアル</title>
</head>
<body>

<!-- hhmts start -->
Last modified: Fri May 16 16:46:37 JST 2014
<!-- hhmts end -->

<body bgcolor="#ffffff">
<a name="top"></a>
<table border="0" cellpadding="2" cellspacing="1">
  <tr>

    <td colspan="2" valign="top"><div class="header_text">Welcome to pgpool -II page</div></td>
  </tr>
  <tr>
    <td valign="top" style="border-right:1px dotted #cccccc;">
    <br />

    <div id="navcontainer">
      <ul id="navlist">
        <li id="active"><a href="#Whatis" id="current">pgpool-IIとは</a></li>
        <li><a href="#platform">pgpool-IIの稼働環境</a></li>
        <li><a href="#install">pgpool-IIのインストール</a></li>
        <li><a href="#config">pgpool-IIの設定</a></li>
        <li><a href="#common">共通設定項目</a></li>
        <li><a href="#connection_pool_mode">コネクションプールモード</a></li>
        <li><a href="#replication_mode">レプリケーションモード</a></li>
        <li><a href="#master_slave_mode">マスタースレーブモード</a></li>
        <li><a href="#stream">Streaming Replicationへの対応</a></li>
        <li><a href="#start">pgpool-IIの起動と停止</a></li>
        <li><a href="#reload">pgpool-IIの設定ファイルの再読み込み</a></li>
        <li><a href="#show-commands">SHOWコマンド</a></li>
        <li><a href="#online-recovery">オンラインリカバリ</a></li>
        <li><a href="#backup">バックアップ</a></li>
        <li><a href="#deploy">pgpool-IIの配置について</a></li>
        <li><a href="#troubleshooting">トラブルシューティング</a></li>
        <li><a href="#restriction">制限事項</a></li>
        <li><a href="#reference">リファレンス</a></li>
        <li><a href="#internal">内部情報</a></li>
        <li><a href="#release">リリースノート</a></li>
      </ul>
    </div>
    <br />

    <div class="header_small" align="center">
    [<a href="pgpool-en.html">English page</a>]
    </div>

    </td>

    <td valign="top" style="border-left:1px dotted #cccccc;">

<h1>pgpool-IIとは<a name="whatis"></a></h1>
<p>pgpool-IIはPostgreSQL専用のミドルウェアで、PostgreSQLのデータベースクライアントと
PostgreSQLサーバの間に割り込む形で動作し、PostgrSQLに以下のような機能を追加します。</p>

<ul>

<li>コネクションプーリング
<p>PostgreSQLへの接続を保存しておき、再利用することによってPostgreSQLへの接続オーバヘッドを低減し、
システム全体のスループットを向上することができます。</p>
</li>

<li>レプリケーション
<p>pgpool-IIは複数のPostgreSQLサーバを管理することができます。
レプリケーション機能を使用することにより、物理的に2台以上のDBサーバにリアルタイムでデータを保存することができ、
万が一どれかのDBサーバに障害が発生しても運用を継続することができます。</p>
</li>

<li>負荷分散
<p>レプリケーションまたマスタースレーブモードで運用している場合、どのサーバに問い合わせても同じ結果が返ってきます。
多数の検索リクエストをそれぞれのサーバで分担して負荷を軽減させ、システム全体の性能を向上させることができます。
最良の場合にはサーバ台数に比例した性能向上が見込めます。
特に多数のユーザが大量の問い合わせを投げるような環境で威力を発揮します。</p>
</li>

<li>接続数の制限
<p>PostgreSQLに接続可能なセッション数には上限があり、それを超えて接続することはできません。
かと言って、同時セッション数をむやみに多くすると、メモリーなどのリソースが多く消費されて
パフォーマンスに影響があります。pgpool-IIでもクライアントからの接続数には上限がありますが、
それを超えてもただちにエラーになることはなく、一定の間待たされるようになっています。
したがって、pgpool-IIはPostgreSQLへの接続要求を実質的にキューイングし、
PostgreSQLへの過大な接続数を制限することが可能です。</p>
</li>

<li>パラレルクエリ
<p>複数のサーバにデータを分割して受け持たせ、それぞれのサーバに同時に検索問い合わせを投げて、
問い合わせの処理時間を短縮するパラレルクエリが利用できます。
特に大規模なデータベースに対して検索を実行するときに威力を発揮します。</p>
</li>

</ul>

<p>pgpool-IIはPostgreSQLバックエンドとフロントエンドの通信プロトコルを理解してその間を中継します。
すなわち、PostgreSQLのデータベースアプリケーションからはPostgreSQLサーバに、
PostgreSQLからはデータベースアプリケーションに見えるように設計されています。
そのため、PostgreSQLそのものはもちろん、アプリケーションの開発言語によらず、
PostgreSQLのデータベースアプリケーションにほとんど手を加えることなく、pgpool-IIの機能が利用できます。</p>

<p><strong>一部のSQLには<a href="#restriction">制限事項</a>があります。</strong></p>



<h1>pgpool-IIの稼働環境<a name="platform"></a></h1>
<p>pgpool-IIは、Linuxをはじめ、SolarisやFreeBSDなどのほとんどのUNIX環境で動作します。Windowsでは動きません。</p>

<p>対応するPostgreSQLのバージョンは、PostgreSQLの6.4以降です。
ただしパラレルクエリモードを使用するときはPostgreSQL 7.4以降をお使いください。
また、PostgreSQL 7.4より前のバージョンでは、使用できる機能に制限事項があります。</p>

<p>pgpool-II配下で利用するPostgreSQLサーバのメジャーバージョンは一致していなければなりません。
また、オンラインリカバリ機能を利用するときは、OSやハードウェアアーキテクチャを同じものにしなければなりません。</p>



<h1>pgpool-IIのインストール<a name="install"></a></h1>

<p>Linux用のRPMパッケージは、CentOS、Fedora用などが提供されています。
該当リポジトリをチェックしてみてください。</p>

<p>pgpool-II のソースコードは<a href="http://pgfoundry.org/projects/pgpool/">pgpool開発ページ</a>
からダウンロードできます。</p>

<p>pgpool-IIのソースコードからのインストールには、gcc 2.9以上、およびGNU makeが必要です。
また、pgpool-IIはlibpq(PostgreSQL付属のクライアントライブラリ)を使用するので、
ビルドを行うマシン上にlibpqがインストールされていることが必要です。</p>

<dl>
<dt>configureの実行</dt>
<dd>
    <p>ソースコードのtar ballを展開したら、configureを実行します。</p>
    <pre>./configure</pre>

    <p>configureに指定できるオプションは以下です。</p>
    <ul>
    <li><code>--prefix=path</code><br/>
    pgpool-II本体や関連ファイルをインストールするトップディレクトリを指定します。
    デフォルトは/usr/localです。</li>

    <li><code>--with-pgsql=path</code><br/>
    PostgreSQLのクライアントライブラリなどがインストールされているトップディ
    レクトリを指定します。デフォルトは<code>pg_config</code>コマンドで取得できるパスです。</li>

    <li><code>--with-openssl</code><br/>
    pgpool-IIをOpenSSLサポート付で作成します。
    デフォルトではOpenSSLサポートは無効です。</li>

    <li><code>--enable-sequence-lock</code><br/>
    pgpool-II 3.0シリーズ(3.0.4まで)互換のinsert_lockを使用します。
    pgpool-IIは、シーケンステーブルの行に対してロックを行います。
    これは、2011年06月より後にリリースされたPostgreSQL 8.2以降では使用できません。</li>

    <li><code>--enable-table-lock</code><br/>
    pgpool-II 2.2と2.3シリーズ互換のinsert_lockを使用します。
    pgpool-IIは、挿入対象のテーブルに対してロックを行います。
    これは、ロックがVACUUMと競合するため非推奨です。</li>
    </ul>
</dd>

<dt>makeの実行</dt>
<dd>
    <pre>
make
make install
    </pre>
</dd>

<dt>pgpool_regclassのインストール</dt>
<dd>
    <p>PostgreSQL 8.0以降を使用している場合は、pgpool-IIが内部で使用する
    C関数pgpool_regclassをインストールします。
    この関数がインストールされていなくてもpgpool-IIは動作しますが、
    違うスキーマで同じテーブル名を定義していて、SQL文の中でスキーマ名を省略している場合に、
    不具合が生じることがあります(一時テーブルを除く)。
    したがって、可能ならばpgpool_regclassをインストールすることをお勧めします。</p>

<pre>
# cd pgpool-II-x.x.x/sql/pgpool-regclass
# make
# make install
# psql -f pgpool-regclass.sql template1
</pre>

    <p>pgpool-regclass.sqlの実行は、pgpool-II経由で利用するデータベース毎に必要になります。
    ただし、"psql -f pgpool-regclass.sql template1"を実行後に作成されたデータベースでは
    自動的にpgpool-regclass.sqlの内容が反映されているので、新たにpgpool-regclass.sqlを実行する必要はありません。
    </p>
</dd>

<dt>pgpool_walrecunningのインストール</dt>
<dd>
    <p>PostgreSQL 9.0以降を使用していて、ストリーミングレプリケーションを利用したい場合は、
    C関数pgpool_walrecrunningをインストールします。
    このインストールは、pgpool-IIがアクセスする予定のすべてのPostgreSQLサーバで実施してください。</p>
<pre>
cd pgpool-II-x.x.x/sql/pgpool-walrecrunning
make
make install
psql -f pgpool-walrecrunning.sql template1
</pre>
    <p>pgpool-walrecrunning.sqlの実行は、pgpool-II経由で利用するデータベース毎に必要になります。
    ただし、"psql -f pgpool-walrecrunning.sql template1"を実行後に作成されたデータベースでは
    自動的にpgpool-walrecrunning.sqlの内容が反映されているので、
    新たにpgpool-walrecrunning.sqlを実行する必要はありません。
    </p>
</dd>

<dt>insert_lockテーブルの作成</dt>
<dd>
    <p>レプリケーションモードでinsert_lockを利用したい場合は、
    排他制御用のテーブルpgpool_catalog.insert_lockを作成します。
    insert_lockテーブルが存在しなくても今のところinsert_lockは動作しますが、その場合は、
    挿入対象のテーブルに対してロックが行われます。
    これはpgpool-II 2.2と2.3シリーズの動作と同じです。
    挿入対象のテーブルに対するロックは、VACUUMと競合してINSERT処理が長時間が待たされる可能性があります。
    したがって、insert_lockテーブルを作成することをお勧めします。
    テーブルの作成は、pgpool-IIがアクセスする予定のすべてのPostgreSQLサーバで実施してください。</p>
<pre>
cd pgpool-II-x.x.x/sql
psql -f insert_lock.sql template1
</pre>
    <p>insert_lock.sqlの実行は、pgpool-II経由で利用するデータベース毎に必要になります。
    ただし、&quot;psql -f insert_lock.sql template1&quot;を実行後に作成されたデータベースでは
    自動的にinsert_lock.sqlの内容が反映されているので、新たにinsert_lock.sqlを実行する必要はありません。</p>
</dd>

</dl>
<p>以上でインストールが完了します(GNU makeが必要なので、SolarisやFreeBSDなどでは
makeをgmakeに読み替えてください)。</p>



<h1>pgpool-IIの設定<a name="config"></a></h1>

<p>pgpool-IIの設定ファイルはデフォルトでは/usr/local/etc/pgpool.confおよび
/usr/local/etc/pcp.confです。pgpool-IIは動作モードによって使用できる機能と、
必要な設定項目が異なります。</p>

<table border width="800">
<tr>
<th>使用できる機能/モード</th>
<th>rawモード(*3)</th>
<th>レプリケーションモード</th>
<th>マスタスレーブモード</th>
<th>パラレルクエリモード</th>
</tr>

<tr>
<td>コネクションプーリング</td>
<td align="center">×</td>
<td align="center">○</td>
<td align="center">○</td>
<td align="center">○</td>
</tr>

<tr>
<td>レプリケーション</td>
<td align="center">×</td>
<td align="center">○</td>
<td align="center">×</td>
<td align="center">△(*1)</td>
</tr>

<tr>
<td>負荷分散</td>
<td align="center">×</td>
<td align="center">○</td>
<td align="center">○</td>
<td align="center">△(*1)</td>
</tr>

<tr>
<td>フェイルオーバ</td>
<td align="center">○</td>
<td align="center">○</td>
<td align="center">○</td>
<td align="center">×</td>
</tr>

<tr>
<td>オンラインリカバリ</td>
<td align="center">×</td>
<td align="center">○</td>
<td align="center">△(*2)</td>
<td align="center">×</td>
</tr>

<tr>
<td>パラレルクエリ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">○</td>
</tr>

<tr>
<td>サーバ台数</td>
<td align="center">1以上</td>
<td align="center">2以上</td>
<td align="center">2以上</td>
<td align="center">2以上</td>
</tr>

<tr>
<td>システムDB</td>
<td align="center">不要</td>
<td align="center">不要</td>
<td align="center">不要</td>
<td align="center">必要</td>
</tr>

</table>

<ul>
<li>(*1)パラレルクエリモードでは、レプリケーションまたは負荷分散を有効にする必要があります。
    ただし、分割して保存しているテーブルに対しては、レプリケーションならびに負荷分散の機能は使用されません。</li>
<li>(*2)マスタースレーブモードでは、Streaming Replicationと併用するときにのみオンラインリカバリが可能です。</li>
<li>(*3)単にpgpool-IIを経由して接続するだけのモードです。
    レプリケーションモードもマスタースレーブモードも有効にしていないときの動作です。
    ostgreSQLサーバへの接続セッション数を制限したり、2台以上のPostgreSQLサーバを用意して
    フェイルオーバ動作をさせたいときに利用します。</li>
</ul>



<h1>pcp.confの設定</h1>
<p>どの動作モードでも、pcp.confの設定は必要です。pgpool-IIには管理者がpgpool-IIの
停止や情報取得などの管理操作を行うためのインターフェイスが用意されています。
そのインターフェイスを利用するためにはユーザ認証が必要になるので、そのユーザ名とパスワードをpcp.confに登録します。
pgpool-IIをインストールすると、$prefix/etc/pcp.conf.sampleができるので、
それを$prefix/etc/pcp.confという名前でコピーします。
</p>
<pre>
cp $prefix/etc/pcp.conf.sample $prefix/etc/pcp.conf
</pre>

<p>pcp.confでは空白行や#で始まる行はコメントと見なされます。ユーザとパスワードは、</p>
<pre>
ユーザ名:[md5暗号化したパスワード]
</pre>
<p>
のように指定します。[md5暗号化したパスワード]は、$prefix/bin/pg_md5コマンドで作成できます。</p>
<pre>
./pg_md5 foo
acbd18db4cc2f85cedef654fccc4a4d8
</pre>

<p>パスワードを引数に渡したくない場合は pg_md5 -p を実行してください。</p>
<pre>
./pg_md5 -p
password: &lt;パスワードを入力&gt;
</pre>

<p>pcp.confは、pgpool-IIを動作させるユーザIDで読み取り可能になっていなければなりません。</p>



<h1>pgpool.confの設定</h1>
<h2>サンプルファイル</h2>
<p>pgpool-IIをインストールすると、インストール先ディレクトリ(デフォルトでは/usr/local)/etc/pgpool.conf.sample
ができるので、それをインストール先ディレクトリ/etc/pgpool.confという名前でコピーします。</p>
<pre>
cp インストール先ディレクトリ/etc/pgpool.conf.sample $prefix/etc/pgpool.conf
</pre>
<p>また、各動作モード用のサンプルpgpool.confが用意されています。こちらもご利用下さい。</p>

<p>
<table border>
<tr>
<th>動作モード</th>
<th>サンプルファイル名</th>
</tr>

<tr>
<td>レプリケーションモード</td>
<td>pgpool.conf.sample-replication</td>
</tr>

<tr>
<td>マスタースレーブモード(Slony-I)</td>
<td>pgpool.conf.sample-master-slave</td>
</tr>

<tr>
<td>マスタースレーブモード(Streaming replication)</td>
<td>pgpool.conf.sample-stream</td>
</tr>
</table>
</p>

<h2>コメントの扱い</h2>
<p>pgpool.confでは空白行や#で始まる行はコメントと見なされます。</p>



<h1><a name="common"></a>共通設定項目</h1>
<p>各動作モードで共通する設定項目を説明します。</p>

<dl>
<dt>listen_addresses</dt>
<dd>
    <p>pgpool-IIがTCP/IPコネクションを受け付けるアドレスをホスト名またはIPアドレスで指定します。
    「*」を指定するとすべてのIPインタフェースからのコネクションを受け付けます。
    「''」を指定するとTCP/IPコネクションを受け付けません。
    デフォルト値は「localhost」です。
    UNIXドメインソケット経由のコネクションは常に受け付けます。
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
</dd>

<dt>port</dt>
<dd>
    <p>pgpool-IIがコネクションを受け付けるポート番号です。デフォルト値は9999です。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>socket_dir</dt>
<dd>
    <p>pgpool-IIがコネクションを受け付けるUNIXドメインソケットを置くディレクトリです。
    デフォルト値は'/tmp'です。
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
</dd>

<dt>pcp_port</dt>
<dd>
    <p>pcpが使用するポート番号です。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>pcp_socket_dir</dt>
<dd>
    <p>pcpがコネクションを受け付けるUNIXドメインソケットを置くディレクトリです。
    デフォルト値は'/tmp'です。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>backend_socket_dir</dt>
<dd>
    <p>UNIXドメインソケット経由でpgpool-IIがPostgreSQLと接続する際に使用する
    PostgreSQLのUNIXドメインソケットが置かれているディレクトリ。
    デフォルト値は/tmpです。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>num_init_children</dt>
<dd>
    <p>preforkするpgpool-IIのサーバプロセスの数です。デフォルト値は32になっています。
    これが、pgpool-IIに対してクライアントが同時に接続できる上限の数になります。
    これを超えた場合は、そのクライアントは、pgpool-IIのどれからのプロセスへのフロントエンドの接続が終了するまで
    待たされます(PostgreSQLと違ってエラーになりません)。
    待たされる数の上限は、2 * num_init_children です。
    待ち行列は、OS内部に作られ、「listenキュー」と呼ばれます。listenキューの長さは「バックログ」と呼ばれます。
    システムによってはバックログの上限が設定されており、2 * num_init_children がこれを越える場合はシステム側の設定変更が必要になります。
        さもないと高負荷時にlistenキューが溢れ、pgpool-IIへの接続が失敗したり、システム内で行われるリトライにより著しく性能が低下することがあります。
        listenキューが溢れているかどうかは、"netstat -s"で確認できます。"TcpExt"のパートで、
        </p>
        <p>
        <pre>
535 times the listen queue of a socket overflowed
        </pre>
        </p>
        <p>
        のようなメッセージが出ていればlistenキューが溢れています。listenキュー溢れを防ぐためにバックログを大きくするには、Linuxでは以下のようにします(root権限が必要です)。
        </p>
        <p>
        <pre>
# sysctl net.core.somaxconn
net.core.somaxconn = 128
# sysctl -w net.core.somaxconn = 256
        </pre>
        </p>
        <p>
        もちろん、/etc/sysctl.confに以下のように書いても構いません。
        </p>
        <p>
        <pre>
net.core.somaxconn = 256
        </pre>
    </p>
    <p>
    基本的に後述のmax_pool * num_init_children分だけPostgreSQLへのコネクションが張られますが、
    他に以下の考慮が必要です。
    </p>
    <ul>
    <li>問い合わせのキャンセルを行うと通常のコネクションとは別に新たなコネクションが張られます。
    したがって、すべてのコネクションが使用中の場合は問い合わせのキャンセルができなくなってしまうので、
    ご注意下さい。
    問い合わせのキャンセルを必ず保証したい場合は、想定されるコネクション数の倍の値を
    設定することをおすすめします。</li>
    <li>一般ユーザでPostgreSQLに接続できるのは、max_connections - superuser_reserved_connections 分だけです。</li>
    </ul>

    <p>以上をまとめると、</p>
<pre>
max_pool*num_init_children &lt;= (max_connections - superuser_reserved_connections) (クエリのキャンセルを考慮しない場合)
max_pool*num_init_children*2 &lt;= (max_connections - superuser_reserved_connections) (クエリのキャンセルを考慮する場合)
</pre>
    <p>のどちらかを満たすように設定してください。</p>
    <p>このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>child_life_time</dt>
<dd>
    <p>pgpool-IIの子プロセスの寿命です。
    アイドル状態になってからchild_life_time秒経過すると、一旦終了して新しいプロセスを起動します。
    メモリーリークその他の障害に備えた予防措置です。
    child_life_timeのデフォルト値は300秒、すなわち5分です。
    0を指定するとこの機能は働きません（すなわち起動しっ放し）。
    なお、まだ一度もコネクションを受け付けていないプロセスにはchild_life_timeは適用されません。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>child_max_connections</dt>
<dd>
    <p>各pgpool-II子プロセスへの接続回数がこの設定値を超えると、その子プロセスを終了します。
    child_life_timeやconnection_life_timeが効かないくらい忙しいサーバで、
    PostgreSQLバックエンドが肥大化するのを防ぐのに有効です。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>client_idle_limit</dt>
<dd>
    <p>前回クライアントから来たクエリから、client_idle_limit 秒越えても次のクエリが届かない場合は、
    クライアントへの接続を強制的に切断し、クライアントからの次のコネクションを待つようにします。
    デフォルト値は 0(無効)です。
    このパラメータは、オンラインリカバリのセカンドステージでは無視されます。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>authentication_timeout</dt>
<dd>
    <p>認証処理のタイムアウト時間を秒単位で指定します。0 を指定するとタイムアウトを無効にします。
    authentication_timeout のデフォルト値は 60です。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>logdir</dt>
<dd>
    <p>pgpool-IIの各種ログファイルを格納するディレクトリです。
    この下にDBノードの状態を記録するpgpool_statusファイルが書かれます。</p>
</dd>

<dt>pid_file_name</dt>
<dd>
    <p>pgpool-IIのpid file(プロセスIDを格納したファイル)のフルパス名です。
    デフォルト値は'/var/run/pgpool/pgpool.pid'です。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>print_timestamp</dt>
<dd>
    <p>trueならばpgpool-IIのログにタイムスタンプを追加します。デフォルトはtrueです。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>connection_cache</dt>
<dd>
    <p>trueならPostgreSQLへのコネクションをキャッシュします。デフォルトはtrueです。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>health_check_timeout</dt>
<dd>
    <p>pgpool-IIはサーバ障害やネットワーク障害を検知するために、定期的にバックエンドに接続を試みます。
    これを「ヘルスチェック」と言います。障害が検知されると、フェイルオーバや縮退運転を試みます。</p>
    <p>この パラメータは、ネットワークケーブルが抜けた際などにヘルスチェックが長時間待たされるのを防ぐための
    タイムアウト値を秒単位で指定します。デフォルトは20秒です。0を指定するとタイムアウト処理をしません。</p>
    <p>なお、ヘルスチェックを有効にすると、ヘルスチェックのための余分の接続が1つ必要になりますので、
    PostgreSQLのpostgresql.confの設定項目のmax_connectionsを少くとも1増やすようにしてください。</p>
    <p>このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>health_check_period</dt>
<dd>
    <p>ヘルスチェックを行う間隔を秒単位で指定します。0を指定するとヘルスチェックを行いません。
    デフォルトは0です(つまりヘルスチェックを行いません)。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>health_check_user</dt>
<dd>
    <p>ヘルスチェックを行うためのPostgreSQLユーザ名です。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>failover_command</dt>
<dd>
    <p>ノードが切り離された時に実行するコマンドを指定します。特殊文字を指定すると、
    pgpool が必要な情報に置き換えてコマンドを実行します。</p>

    <center>
    <table border>
    <tr><td>文字</td><td>意味</td></tr>
    <tr><td>%d</td><td>切り離されたノード番号</td></tr>
    <tr><td>%h</td><td>切り離されたノードのホスト名</td></tr>
    <tr><td>%H</td><td>新しいマスターのホスト名</td></tr>
    <tr><td>%p</td><td>切り離されたノードのポート番号</td></tr>
    <tr><td>%D</td><td>切り離されたノードのデータベースクラスタパス
    </td></tr>
    <tr><td>%M</td><td>古いマスターのノード番号</td></tr>
    <tr><td>%m</td><td>新しいマスターのノード番号</td></tr>
    <tr><td>%P</td><td>古いプライマリノード番号</td></tr>
    <tr><td>%%</td><td>'%'文字</td></tr>
    </table>
    </center>

    <p>このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
    <p>フェイルオーバー時には、pgpoolはまず子プロセスを切断します(結果として、すべてのセッションが切断されます)。
    次に、pgpoolはフェイルオーバコマンドを実行し、その完了を待ちます。
    そのあとで新しいpgpoolの子プロセスが起動され、クライアントからの接続を受け付けられる状態になります。</p>
</dd>

<dt>failback_command</dt>
<dd>
    <p>ノードが復帰した時に実行するコマンドを指定します。特殊文字を指定すると、
    pgpool が必要な情報に置き換えてコマンドを実行します。</p>

    <center>
    <table border>
    <tr><td>文字</td><td>意味</td></tr>
    <tr><td>%d</td><td>復帰したノード番号</td></tr>
    <tr><td>%h</td><td>復帰したノードのホスト名</td></tr>
    <tr><td>%p</td><td>復帰したノードのポート番号</td></tr>
    <tr><td>%D</td><td>復帰したノードのデータベースクラスタパス
    </td></tr>
    <tr><td>%M</td><td>古いマスターのノード番号</td></tr>
    <tr><td>%m</td><td>新しいマスターのノード番号</td></tr>
    <tr><td>%H</td><td>新しいマスターのホスト名</td></tr>
    <tr><td>%P</td><td>古いプライマリノード番号</td></tr>
    <tr><td>%%</td><td>'%'文字</td></tr>
    </table>
    </center>

    <p>このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>fail_over_on_backend_error</dt>
<dd>
    <p>trueならば、バックエンドのソケットへの書き込みに失敗するとフェイルオーバします。
   これはpgpool-II 2.2.xまでの挙動と同じです。
    falseにすると、フェイルオーバせず、単にエラーがレポートされてセッションが切断されます。
    このパラメータをfalseにする場合には、health checkを有効にすることをお勧めします。
    なお、このパラメータがfalseの場合でも、クライアントがpgpoolに接続する際に
    バックエンドへの接続に失敗した場合、あるいはバックエンドがシャットダウンされたことを
    pgpool-IIが検知した場合にはフェイルオーバが起きることに注意してください。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>ignore_leading_white_space</dt>
<dd>
    <p>trueならば、load balanceの際にSQL文行頭の空白を無視します(全角スペースは無視されません)。
    これは、DBI/DBD:Pgのように、勝手に行頭にホワイトスペースを追加するようなAPIを使い、
    ロードバランスしたいときに有効です。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>log_statement</dt>
<dd>
    <p>trueならばSQL文をログ出力します。
    この役目はPostgreSQLのlog_statementオプションと似ていて、デバッグオプションがないときでも
    問い合わせをログ出力して調べることができるので便利です。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>log_per_node_statement</dt>
<dd>
    <p>log_statementと似ていますが、DBノード単位でログが出力されるので、
    レプリケーションや負荷分散の確認が容易です。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>log_hostname</dt>
<dd>
    <p>trueならば、psコマンドでの状態表示時にIPアドレスではなく、ホスト名を表示します。
    また、log_connectionsが有効な場合にはログにホスト名を出力します。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>log_connections</dt>
<dd>
    <p>trueならば、全てのクライアント接続をログへ出力します。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>enable_pool_hba</dt>
<dd>
    <p>trueならば、pool_hba.confに従ってクライアント認証を行います。
    詳細は<a href="#hba">クライアント認証(HBA)のためのpool_hba.conf設定方法</a>を参照してください。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。
   </p>
</dd>

<dt>pool_passwd</dt>
<dd>
    <p>
    md5 認証で用いる認証ファイルのファイル名を指定します。
    デフォルト値は "pool_passwd" です。
    空文字列（""）を指定すると 認証ファイルの読込は無効になります。
    詳細は<a href="#md5">認証・アクセス制御方式</a>を参照してください。
    このパラメータを変更した時には pgpool-II を再起動してください。
    </p>
</dd>

<dt>backend_hostname</dt>
<dd>
    <p>使用するPostgreSQLサーバのホスト名を指定します。
    空文字を指定するとUNIXドメインソケットで接続します。
    実際には、"backend_hostname"の後に0, 1, 2...と数字を付加して使用する複数のPostgreSQLを区別します。
    この数字のことを「DBノードID」と呼びます。
    DBノードID == 0のPostgreSQLは、特別に「マスターDB」と呼ばれます。
    なお、複数のDBノードを運用している場合、条件によってはマスターDBがダウンしても
    運用を続けることができます。
    この場合は、稼働中かつDBノードIDがもっとも若いものが新しいマスターDBになります。</p>

    <p>1台しかPostgreSQLを使用しない場合は、"backend_hostname0"としてください。</p>

    <p>backend_hostname は新しく追加した行を設定ファイル再読み込みで追加することができます。
    すでにある情報を途中で変更することはできません。変更する場合には pgpool-II を再起動してください。</p>
</dd>

<dt>backend_port</dt>
<dd>
    <p>使用するPostgreSQLサーバのポート番号を指定します。
    実際には、"backend_port"の後に0, 1, 2...とDBノードIDを付加して使用する複数のPostgreSQLを区別します。
    1台しかPostgreSQLを使用しない場合は、"backend_port0"としてください。</p>

    <p>backend_port は新しく追加した行を設定ファイル再読み込みで追加することができます。
    すでにある情報を途中で変更することはできません。変更する場合には pgpool-II を再起動してください。</p>
</dd>

<dt>backend_weight</dt>
<dd>
    <p>使用するPostgreSQLサーバに対する負荷分散の比率を0以上の整数または浮動小数点で指定します。
    "backend_weight"の後には、DBノードIDを付加して使用する複数のPostgreSQLを区別します。
    1台しかPostgreSQLを使用しない場合は、"backend_weight0"としてください。
    負荷分散を使用しない場合は、「1」を設定してください。</p>

    <p>backend_weight は新しく追加した行を設定ファイル再読み込みで追加することができます。
    pgpool-II 2.2.6/2.3以降では、設定ファイルの再読込でbackend_weight値を変更できます。
    新しく接続したクライアントセッションから、この新しいweight値が反映されます。</p>
</dd>

<dt>backend_data_directory</dt>
<dd>
    <p>使用する PostgreSQL サーバのデータベースクラスタのパスを指定します。
    実際には、"backend_data_directory"の後にDBノードIDを付加して使用する複数のPostgreSQLを区別します。
    このパラメータはオンラインリカバリの際に使用します。
    オンラインリカバリを使用しない場合には設定する必要はありません。</p>

    <p>backend_data_directory は新しく追加した行を設定ファイル再読み込みで追加することができます。
    すでにある情報を途中で変更することはできません。変更する場合には pgpool-II を再起動してください。</p>
</dd>

<dt><a name="ssl">ssl</a></dt>
<dd>
  <p>trueならばpgpool-IIとフロントエンド、pgpool-IIとバックエンドの間のSSL接続が可能になります。
  なお、pgpool-IIとフロントエンドの接続にSSLが利用できるためには、
  <code>ssl_key</code>と<code>ssl_cert</code>が設定されてなければなりません。</p>

  <p>デフォルトではSSLサポートはオフになっています。
  SSLサポートを有効にするためには、configure時にOpenSSLサポートを有効にする必要があります。
  詳細は<a href="#install">インストール</a>の項目をご覧下さい。</p>

  <p>sslを有効に設定したら、pgpoolの再起動をしてください。</p>
</dd>

<dt>ssl_key</dt>
<dd>
    <p>フロントエンドとの接続に使用するプライベートキーファイルのフルパスを指定します。</p>

    <p>ssl_keyのデフォルト値はありません。
    ssl_keyの設定がない場合は、フロントエンドとの接続でSSLが使用されなくなります。</p>
</dd>

<dt>ssl_cert</dt>
<dd>
    <p>フロントエンドとの接続に使用する公開x509証明書のフルパスを指定します。</p>

    <p>ssl_certのデフォルト値はありません。
    ssl_certの設定がない場合は、フロントエンドとの接続でSSLが使用されなくなります。</p>
</dd>

<dt>ssl_ca_cert</dt>
<dd>
    <p>
    1 つ以上の CA ルート証明書を格納している PEM 形式ファイルのパスを指定します。
    このファイルはバックエンドサーバ証明書の検証に用いられます。
    このオプションは OpenSSL の <code>verify(1)</code> コマンドにおける <code>-CAfile</code> オプションと同様の機能を提供します。
    </p>

    <p>
    デフォルトでは値が設定されておらず検証は行われません。
    このオプションが設定されていない場合においても、<code>ssl_ca_cert_dir</code> オプション
    が設定されている場合には検証が行われます。
    </p>
</dd>

<dt>ssl_ca_cert_dir</dt>
<dd>
    <p>
    PEM 形式の CA 証明書ファイルを格納しているディレクトリのパスを指定します。
    これらのファイルはバックエンドサーバ認証の検証に用いられます。
    このオプションは OpenSSL の <code>verify(1)</code> コマンドにおける <code>-CApath</code> オプションと同様の機能を提供します。
    </p>

    <p>
    デフォルトでは値が設定されておらず検証は行われません。
    このオプションが設定されていない場合においても、<code>ssl_ca_cert</code> オプション
    が設定されている場合には検証が行われます。
    </p>
</dd>

<dt>debug_level</dt>
<dd>
    <p>デバッグメッセージの詳細レベル。0でデバッグメッセージの出力なし。
    1以上でデバッグメッセージを出力します。
    数字が大きければより詳細なメッセージが出力されるようになります(3.0では今のところメッセージの詳細度は変りません)。
    デフォルト値は0です。</p>
</dd>

</dl>

<h2>SSL証明書の生成</h2>
<p>証明書の扱いについてはこのマニュアルの範囲外です。
PostgreSQLドキュメント<a href="http://www.postgresql.jp/document/pg842doc/html/ssl-tcp.html">SSLによる安全なTCP/IP接続</a>の章に自分で認証する証明書を作成するコマンドの例があります。</p>

<h2>rawモードにおけるフェイルオーバ動作について</h2>
<p>rawモードにおいて、2台以上のPostgreSQLサーバを指定すると、フェイルオーバが可能です。
フェイルオーバでは、正常時にはbackend_hostname0で指定したPostgreSQLのみを使用し、
ほかのサーバにはアクセスしません。
backend_hostname0のサーバがダウンすると、次にbackend_hostname1で指定したサーバにアクセスをこころみ、
成功すればそれを使用します。
以下、backend_hostname2...でも同様になります。</p>

<h1><a name="connection_pool_mode"></a>コネクションプールモード</h1>
<p>rawモードに加え、コネクションプーリングが利用できるようになります。
設定項目は、rawモードでの設定項目の他に以下を設定します。</p>

<dl>
<dt>max_pool</dt>
<dd>
    <p>pgpool-IIの各サーバプロセスがキープするPostgreSQLへの最大コネクション数です。
    pgpool-IIは、ユーザ名、データベースが同じならばコネクションを再利用しますが、
    そうでなければ新たにPostgreSQLへのコネクションを確立しようとします。
    したがって、ここでは想定される[ユーザ名:データベース名]のペアの種類の数だけを
    max_poolに指定しておく必要があります。
    もしmax_poolを使いきってしまった場合は一番古いコネクションを切断し、そのスロットが再利用されます。</p>

    <p>ax_poolのデフォルト値は4です。</p>

    <p>なお、pgpool-II全体としては、num_init_children*max_pool 分だけ
    PostgreSQLへのコネクションが張られる点に注意してください。</p>

    <p>このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>connection_life_time</dt>
<dd>
    <p>コネクションプール中のコネクションの有効期間を秒単位で指定します。
    0を指定すると有効期間は無限になります。connection_life_timeのデフォルト値は0です。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>reset_query_list</dt>
<dd>
    <p>セッションが終了するときにコネクションを初期化するためのSQLコマンドを「;」で区切って列挙します。
    デフォルトは以下のようになっていますが、任意のSQL文を追加しても構いません。</p>
<pre>
   reset_query_list = 'ABORT; DISCARD ALL'
</pre>

    <p>PostgreSQLのバージョンによって使用できるSQLコマンドが違います。
    各バージョンごとのお勧め設定は以下です(ただし、"ABORT"は必ずコマンドに含めてください)。</p>

    <p>
    <table border>
    <tr><th>PostgreSQLバージョン</th><th>reset_query_listの推奨設定値</th></tr>
    <tr><td>7.1以前</td><td>ABORT</td></tr>
    <tr><td>7.2から8.2</td><td>ABORT; RESET ALL; SET SESSION AUTHORIZATION DEFAULT</td></tr>
    <tr><td>8.3以降</td><td>ABORT; DISCARD ALL</td></tr>
    </table>
    </p>

    <ul>
    <li>「ABORT」は、PostgreSQL 7.4以上ではトランザクションブロックの中にいい場合には発行されません。</li>
    </ul>

    <p>このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>
</dl>

<h2>コネクションプールモードにおけるフェイルオーバ動作について</h2>
<p>rawモードと同様の動作をします。</p>

<h1><a name="replication_mode"></a>レプリケーションモード</h1>
<p>レプリケーションを有効にするモードです(設定ファイルの雛形はpgpool.conf-replication)。
rawモード、コネクションプールモードに加え、以下を設定します。</p>

<dl>
<dt>replication_mode</dt>
<dd>
    <p>レプリケーションモードで動作させる場合はtrueを指定してください。デフォルト値はfalseです。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>load_balance_mode</dt>
<dd>
    <p>trueを指定するとレプリケーションモードまたはマスタースレーブモードの際に、
    SELECT文をロードバランスして検索性能を向上させることができます。デフォルト値はfalseです。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>replication_stop_on_mismatch</dt>
<dd>
    <p>各DBノードから送られてくるパケットの種類が不一致になった場合に、
    DBノードを切り放して縮退運転に入ります。</p>

    <p>良くあるケースとしては、replicate_selectが指定されていてSELECTが各DBノードで実行されているときに、
    検索結果行数が一致しないなど、があります(これに限定されるものではありません。
    たとえばあるDBノードでUPDATEが成功したのに、他のDBノードでは失敗した場合が一例です)。
    ただし、pgpoolはパケットの中身まではチェックしていないので、
    SELECT結果のデータ内容が異なっていても、縮退は起きないことに注意してください。</p>

    <p>縮退対象のDBノードは「多数決」で少数派になったものが対象になります。
    もし多数決で同票になった場合は、マスタDBノード(DBノード番号がもっともわかいもの)を含むグループが優先され、
    それ以外のグループに所属するDBノードが切り放しの対象になります。
    このオプションがfalseの場合は、該当のセッションを強制的に終了するだけに留めます。
    デフォルト値はfalseです。</p>
</dd>

<dt>failover_if_affected_tuples_mismatch</dt>
<dd>
    <p>各DBノードで実行されたINSERT/UPDATE/DELETEの結果行数が不一致になった場合に、
    DBノードを切り放して縮退運転に入ります。</p>

    <p>縮退対象のDBノードは「多数決」で少数派になったものが対象になります。
    もし多数決で同票になった場合は、マスタDBノード(DBノード番号がもっともわかいもの)を含むグループが優先され、
    それ以外のグループに所属するDBノードが切り放しの対象になります。</p>

    <p>このオプションがfalseの場合は、該当のセッションを強制的に終了するだけに留めます。
    デフォルト値はfalseです。</p>
</dd>

<a name="white_function_list"></a>
<dt>white_function_list</dt>
<dd>
    <p>データベースに対して<strong>更新を行なわない関数名</strong>をコンマ区切りで指定します。
    このリストに含まれない関数呼び出しを含むSELECTは、負荷分散の対象とはならず、
    レプリケーションモードにおいてはすべてのDBノードで実行されます。
    (マスタースレーブモードにおいては、マスター(primary)DBノードにのみ送信されます)。</p>
</dd>

<a name="black_function_list"></a>
<dt>black_function_list</dt>
<dd>
    <p>データベースに対して<strong>更新を行なう関数名</strong>をコンマ区切りで指定します。
    このリストに含まれる関数呼び出しを含むSELECTは、負荷分散の対象とはならず、
    レプリケーションモードにおいてはすべてのDBノードで実行されます。
    このリストに含まれない関数呼び出しを含むSELECTは、負荷分散の対象となります。</p>

    <p>white_function_listとblack_function_listの両方を空以外にすることはできません。
    どちらか一方のみに関数名を指定します。</p>

    <p>pgpool-II 3.0より前のバージョンでは、固定でnextvalとsetvalが書き込みを行なう関数として認識されていました。
    それと同じ動作を行なわせるには、以下のようにwhite_function_listとblack_function_listを指定します。
    currvalとlastvalは、書き込みを行う関数ではありませんが、black_function_listに登録しておかないと、
    負荷分散され、nextvalなしに呼び出されてしまってエラーになってしまうので、
    black_function_listに登録しておく方が良いでしょう。</p>

<pre>
white_function_list = ''
black_function_list = 'nextval,setval,currval,lastval'
</pre>
</dd>

<a name="replicate_select"></a>
<dt>replicate_select</dt>
<dd>
    <p>true を設定すると、レプリケーションモードでは SELECT 文をレプリケーションします。
    これは pgpool-II 1.0 までの挙動と同じになります。
    false を設定すると SELECT 文をマスタのみに送信します。デフォルト値は false です。</p>
    <p>replicate_select、load_balance_mode、SELECT問合わせが
    明示的なトランザクションブロックの内側にあるかどうかで、レプリケーションモードの動作が変化します。
    詳細を表に示します。</p>

    <p>
    <table border>

    <tr>
    <td>SELECTが明示的なトランザクションブロックの内側にある</td>
    <td>Y</td>
    <td>Y</td>
    <td>Y</td>
    <td>N</td>
    <td>N</td>
    <td>N</td>
    <td>Y</td>
    <td>N</td>
    </tr>

    <tr>
    <td>replicate_selectがtrue</td>
    <td>Y</td>
    <td>Y</td>
    <td>N</td>
    <td>N</td>
    <td>Y</td>
    <td>Y</td>
    <td>N</td>
    <td>N</td>
    </tr>

    <tr>
    <td>load_balance_modeがtrue</td>
    <td>Y</td>
    <td>N</td>
    <td>N</td>
    <td>N</td>
    <td>Y</td>
    <td>N</td>
    <td>Y</td>
    <td>Y</td>
    </tr>

    <tr>
    <td>結果(R:レプリケーション, M: マスタのみに送信, L: ロードバランスされる)</td>
    <td>R</td>
    <td>R</td>
    <td>M</td>
    <td>M</td>
    <td>R</td>
    <td>R</td>
    <td>M</td>
    <td>L</td>
    </tr>
    </table>
    </p>
</dd>

<dt>insert_lock</dt>
<dd>
    <p>SERIAL型を使っているテーブルをレプリケーションすると、SERIAL型の列の値が
    DBノードの間で一致しなくなることがあります。
    この問題は、該当テーブルを明示的にロックすることで回避できます
    (もちろんトランザクションの並列実行性は犠牲になりますが)。しかし、そのためには、</p>

<pre>
   INSERT INTO ...
</pre>

    <p>を</p>

<pre>
   BEGIN;
   LOCK TABLE ...
   INSERT INTO ...
   COMMIT;
</pre>
    <p>に書き換えなければなりません。
    insert_lockをtrueにすると自動的にトランザクションの開始、テーブルロック、トランザクションの終了を
    行ってくれるので、こうした手間を省くことができます
    （すでにトランザクションが開始されている場合はLOCK TABLE...だけが実行されます）。</p>

    <p>pgpool-II 2.2以降は、テーブルがSERIAL列を持つかどうか自動判別するため、
    SERIAL列がなければ決してテーブルをロックしません。</p>

    <p>pgpool-II 3.0.4までの3.0シリーズは、対応するシーケンステーブルに対して行ロックをかけることで
    排他制御を行ないます。
    それ以前のバージョンと比べると、VACUUM(autovacuumを含む)とのロック競合がなくなるメリットがあります。
    しかし、これは他の問題を引き起こします。
    トランザクション周回が起きた後、シーケンステーブルに対する行ロックはPostgreSQLの内部エラー
    (詳細には、トランザクション状態を保持するpg_clogへのアクセスエラー)を起こします。
    これを防ぐため、PostgreSQLのコア開発者はシーケンステーブルに対する行ロックを許可しないことを決定しました。
    これはもちろんpgpool-IIを動作不能にします
    (修正されたPostgreSQLはバージョン9.0.5, 8.4.9, 8.3.16そして8.2.22としてリリースされるでしょう)。</p>

    <p>pgpool-II 3.0.5以降では、新しいPostgreSQLがシーケンステーブルに対するロックを許可しなくなったため、
    pgpool_catalog.insert_lockテーブルに対して行ロックをかけることで排他制御を行ないます。
    したがって、pgpool-II経由でアクセスするすべてのデータベースに
    insert_lockテーブルをあらかじめ作成しておく必要があります。
    詳細は<a href="#install">insert_lockテーブルの作成</a>の項目をご覧ください。
    もし、insert_lockテーブルが存在しない場合は、挿入対象のテーブルに対してロックを行います。
    これは、pgpool-II 2.2と2.3シリーズのinsert_lockと同じ動作です。
    また、過去のバージョンと互換性のあるinsert_lockを使用したい場合は、configureスクリプトで設定できます。
    詳細は<a href="#install">configureの実行</a>の項目をご覧下さい。</p>

    <p>なお、あまり必要ないかも知れませんが、コメントを利用して、この挙動を細かく制御することもできます。</p>

    <ol>
    <li>insert_lockをtrueにして、INSERT文の先頭に/*NO INSERT LOCK*/コメントを追加する。
    このコメントがあると、テーブルロックは行われません(pgpool-II 3.0以降でも同様)。</li>

    <li>insert_lockをfalseにして、INSERT文の先頭に/*INSERT LOCK*/コメントを追加する。
    このコメントがあると、このINSERT文に対してのみテーブルロックが行われます(pgpool-II 3.0以降でも同様)。</li>
    </ol>

    <p>insert_lockのデフォルト値はtrueです。</p>

    <p>なお、insert_lockを有効にしてregression testを実行すると、少くとも
    PostgreSQL 8.0ではtransactions, privileges, rules, alter_tableがfailします。
    ruleでは、viewに対してLOCKをしようとしてしまうこと、ほかのものは</p>
<pre>
   ! ERROR:  current transaction is aborted, commands ignored until end of transaction block
</pre>

    <p>というようなメッセージが出てしまうためです。
    たとえば、transactions では、存在しないテーブルに対してINSERTを行うテストが含まれており、
    pgpoolが最初に存在しないテーブルに対してLOCKを行う結果、
    エラーになってトランザクションがアボート状態になり、続くINSERTで上記エラーが出てしまいます。</p>

    <p>このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>recovery_user</dt>
<dd>
    <p>オンラインリカバリを行うための PostgreSQL ユーザ名です。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>recovery_password</dt>
<dd>
    <p>オンラインリカバリを行うための PostgreSQL ユーザパスワードです。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>recovery_1st_stage_command</dt>
<dd>
<<<<<<< HEAD
    <p>オンラインリカバリ中に起動するコマンド名を指定します。
    このスクリプトはPostgreSQLのマスタサーバ(プライマリサーバ)が起動します。
    コマンドファイルはセキュリティ上の観点からデータベースクラスタ以下にあるコマンドやスクリプトのみを呼び出します。
    例えば、recovery_1st_stage_command = 'sync-command' と設定してある場合、
    $PGDATA/sync-command を起動しようとします。</p>

    <p>recovery_1st_stage_command は次の3つの引数を受けとります。</p>
=======
<p>
  オンラインリカバリ中に起動するコマンド名を指定します。
  このスクリプトはPostgreSQLのマスタサーバ(プライマリサーバ)が起動します。
  コマンドファイルはセキュリティ上の観点からデータベースクラスタ以下にあるコマンドやスクリプトのみを呼び出します。
  例えば、recovery_1st_stage_command = 'sync-command' と設定してある場
  合、$PGDATA/sync-command を起動しようとします。
</p>
<p>
recovery_1st_stage_command は次の3つの引数を受けとります。
</p>
<ol>
<li>マスタ(プライマリ)データベースクラスタへのパス</li>
<li>リカバリ対象のPostgreSQLのホスト名</li>
<li>リカバリ対象のデータベースクラスタへのパス</li>
</ol>
</p>
<p>
  recovery_1st_stage_command を実行している間は pgpool ではクライアン
  トからの接続を<b>制限しません</b>。参照や更新を行うことができます。
</p>
<p>
<font color="red">
注意:
</font>
recovery_1st_stage_command は、PostgreSQLから見ると、一つのSQLとして実行されます。PostgreSQLの statement_timeout を無効にするか、statement_timeout が recovery_1st_stage_command の実行時間よりも十分長くないと、コマンドの実行がPostgreSQLにより途中でキャンセルされてしまいます。
この場合の典型的な症状は、recovery_1st_stage_command の中で呼び出されるコマンド(たとえば rsync)がシグナル2を受け取って中断する、というものです。
</p>

<p>
このパラメータを変更した時には設定ファイルを再読み込みしてください。
</p>

<dt><a name="RECOVERY_2ND_STAGE_COMMAND"></a>recovery_2nd_stage_command</dt>
<dd>
<p>
  2 回目のオンラインリカバリ中に起動するコマンド名を指定します。
  このスクリプトはPostgreSQLのマスタサーバ(プライマリサーバ)が起動します。
  コマンドファイルはセキュリティ上の観点からデータベースクラスタ以下にあるコマンドやスクリプトのみを呼び出します。
  例えば、recovery_2nd_stage_command = 'sync-command' と設定してある場
  合、$PGDATA/sync-command を起動しようとします。
</p>
<p>
recovery_2nd_stage_command は次の3つの引数を受けとります。
</p>
<ol>
<li>マスタ(プライマリ)データベースクラスタへのパス</li>
<li>リカバリ対象のPostgreSQLのホスト名</li>
<li>リカバリ対象のデータベースクラスタへのパス</li>
</ol>
</p>
<p>
  recovery_2nd_stage_command を実行している間は pgpool ではクライアン
  トから接続、参照、更新処理を一切<b>受け付けません</b>。また、バッチ
  処理などによって接続しているクライアントが長時間存在している場合には
  コマンドを起動しません。新たな接続を制限し、現在の接続数が 0 になった時点
  でコマンドを起動します。
</p>
<p>
<font color="red">
注意:
</font>
recovery_2nd_stage_command は、PostgreSQLから見ると、一つのSQLとして実行されます。PostgreSQLの statement_timeout を無効にするか、statement_timeout が recovery_2nd_stage_command の実行時間よりも十分長くないと、コマンドの実行がPostgreSQLにより途中でキャンセルされてしまいます。
この場合の典型的な症状は、recovery_2nd_stage_command の中で呼び出されるコマンド(たとえば rsync)がシグナル2を受け取って中断する、というものです。
</p>

<p>
このパラメータを変更した時には設定ファイルを再読み込みしてください。
</p>
>>>>>>> e1671be... Add cautions that recovery commands are killed by statement_timeout of PostgreSQL.

    <ol>
    <li>マスタ(プライマリ)データベースクラスタへのパス</li>
    <li>リカバリ対象のPostgreSQLのホスト名</li>
    <li>リカバリ対象のデータベースクラスタへのパス</li>
    </ol>

    <p>recovery_1st_stage_command を実行している間は pgpool ではクライアントからの接続を<b>制限しません</b>。
    参照や更新を行うことができます。</p>

    <p>このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>recovery_2nd_stage_command</dt>
<dd>
    <p>2 回目のオンラインリカバリ中に起動するコマンド名を指定します。
    このスクリプトはPostgreSQLのマスタサーバ(プライマリサーバ)が起動します。
    コマンドファイルはセキュリティ上の観点からデータベースクラスタ以下にあるコマンドやスクリプトのみを呼び出します。
    例えば、recovery_2nd_stage_command = 'sync-command' と設定してある場合、
    $PGDATA/sync-command を起動しようとします。</p>

    <p>recovery_2nd_stage_command は次の3つの引数を受けとります。</p>

    <ol>
    <li>マスタ(プライマリ)データベースクラスタへのパス</li>
    <li>リカバリ対象のPostgreSQLのホスト名</li>
    <li>リカバリ対象のデータベースクラスタへのパス</li>
    </ol>

    <p>recovery_2nd_stage_command を実行している間は pgpool では
    クライアントから接続、参照、更新処理を一切<b>受け付けません</b>。
    また、バッチ処理などによって接続しているクライアントが長時間存在している場合にはコマンドを起動しません。
    新たな接続を制限し、現在の接続数が 0 になった時点でコマンドを起動します。</p>

    <p>このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>recovery_timeout</dt>
<dd>
    <p>pgpoolは、オンラインリカバリの際にすべてのクライアントが接続を終了するまで待ちます。
    recovery_timeoutでその最大待ち時間を指定します。単位は秒です。
    待ち時間がrecovery_timeoutを越えると、オンラインリカバリは中止され、通常の状態に戻ります。</p>

    <p>アイドル状態のクライアントが自分から切断するのを待ちたくない場合は、
    client_idle_limit_in_recoveryを利用することもできます。</p>

    <p>recovery_timeoutは、この他、オンラインリカバリの最後にリカバリ対象のDBノードで
    postmasterを起動する際の待ち時間にも利用されます。</p>

    <p>recovery_timeoutのデフォルト値は90秒です。
    recovery_timeoutを0としてもタイムアウトが無効になるわけではなく、
    単に即座にタイムアウトするだけですので注意してください。
    このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>client_idle_limit_in_recovery</dt>
<dd>
    <p>client_idle_limitと似ていますが、このパラメータはリカバリのセカンドステージでのみ効力があります。
    前回クライアントから来たクエリから、client_idle_limit_in_recovery 秒越えても次のクエリが届かない場合は、
    クライアントへの接続を強制的に切断し、リカバリのセカンドステージの進行が妨害されるのを防ぎます。</p>

    <p>-1を指定すると、直ちにクライアントへの接続を切断してセカンドステージに入ります。
    デフォルト値は 0(無効)です。</p>

    <p>クライアントが忙しく、アイドル状態にならない場合はclient_idle_limit_in_recoveryを設定しても
    セカンドステージに移行できません。
    この場合、client_idle_limit_in_recoveryに-1を設定すると、クライアントがビジーであってもただちに
    クライアントへの接続を切断し、セカンドステージに移行することができます。</p>

    <p>このパラメータを変更した時には設定ファイルを再読み込みしてください。</p>
</dd>

<dt>lobj_lock_table</dt>
<dd>
    <p>ラージオブジェクトのレプリケーションを行いたいときにロック管理に使うためのテーブル名を指定します。
    このテーブルが指定されていて、ラージオブジェクトの作成要求がクライアントから送信され、
    かつその要求の中にラージオブジェクトのIDの明示的な指定が含まれていない場合
    (つまり、lo_creatでラージオブジェクトを作成する場合)、
    pgpool-IIは、排他制御のためにこのテーブルをロックした後、
    ラージオブジェクトを格納するシステムカタログpg_largeobjectのラージオブジェクトに格納されている
    IDの最大値を取りだし、その値+1のIDを使ってlo_create()を呼び出してラージオブジェクトの作成を行います
    (lo_create()を持たないバージョン8.1より前のPostgreSQLではこの処理は行われません)。
    この方法により、すべてのDBノードで同じIDを持つラージオブジェクトが作成されることが保証されます。</p>

    <p>このような処理の対象となるラージオブジェクトの操作は、PostgreSQLのC言語用のAPI(libpq)で言うと、
    lo_creat()です。
    2010年2月時点の我々の調査では、以下の言語のラージオブジェクト作成APIは、すべてlo_creat()を呼び出すか、
    またはlo_creat()と同じ通信プロトコルを使っているので、pgpool-IIの上記の操作の対象になり、
    ラージオブジェクトのレプリケーションが安全に行われるようになります。</p>

    <ul>
    <li>Java(JDBCドライバ)</li>
    <li>PHP(pg_lo_create関数、またはPDOなどの該当API)</li>
    <li>psqlから\lo_importを呼び出す場合</li>
    </ul>

    <p>上記以外であっても、ラージオブジェクトの作成APIでラージオブジェクトの
    IDを引数として渡すようになっていないものは間違いなくlo_creat()を使っており、
    pgpool-IIの上記の操作の対象になると考えて良いでしょう。</p>

    <p>pgpool-IIの上記処理の対象とならないようなラージオブジェクトの作成処理は以下のものです。</p>

    <ul>
    <li>libpqのlo_create()を使用している</li>
    <li>C言語以外のAPIで、lo_create()を使用しているもの</li>
    <li>バックエンド関数のlo_importをSELECTで呼び出す場合</li>
    <li>バックエンド関数のlo_creatをSELECTで呼び出す場合</li>
    </ul>

    <p>lobj_lock_tableで指定するテーブルはどのような定義のものでも構いませんが、
    あらかじめ作成済でかつすべてのユーザが書き込み可能でなければなりません。
    そのようなテーブルを作る例を示します。</p>

<pre>
CREATE TABLE public.my_lock_table ();
GRANT ALL ON public.my_lock_table TO PUBLIC;
</pre>

    <p>この操作はpgpool-II経由で接続するすべてのデータベースに対して、あらかじめ実施しておかなければなりません。
    しかし、この操作をtemplate1データベースに対して一度行っておけば、
    以後作成されるデータベースにはこのテーブルが含まれるようになるので、管理の手間が省けます。</p>

    <p>lobj_lock_tableに指定するテーブル名が空文字の場合は、ラージオブジェクトに関する上記の処理は行いません
    (したがって、ラージオブジェクトのレプリケーションは保証されません)。
    lobj_lock_tableのデフォルト値は空文字です。</p>
</dd>

</dl>

<h2>ロードバランスの条件について</h2>
<p>load_balance_mode = true を設定した場合、以下の条件のすべてを満たした時に
SELECTなどの問い合わせがロードバランスされます。</p>

<ul>
<li>PostgreSQLのバージョンが7.4以降である</li>
<li>問い合わせが明示的なトランクザションブロックの内側にない(つまり、BEGINを発行していない)</li>
<li>SELECT文(WITH付も含む。black_listまたはwhite_listで指定された書き込みを含むSELECTを除く)
またはCOPY TO STDOUT, EXPLAIN, EXPLAIN ANALYZE SELECT... のいずれかである</li>
<li>SELECT INTO 文ではない</li>
<li>SELECT FOR UPDATE/SELECT FOR SHARE文ではない</li>
<li>クエリ文字列が SELECTまたはWITH で始まる(ignore_leading_white_space = trueの場合は空白は無視します)</li>
</ul>

<p>(<a href="#replicate_select">replicate_selectの項目</a>も参考にしてください)
また、<a href="where_to_send_queries.pdf">詳細な判定条件をフローチャートにしたもの</a>もご覧下さい。</p>

<p>なお、</p>

<pre>
/*REPLICATION*/ SELECT ...
</pre>

<p>とすることによって、本来負荷分散されたり、マスタのみに送信されるべき問合わせが
すべてのバックエンドに送信される（レプリケーションされる）ようになります。
副作用がある関数を含む問合わせに対してはこのテクニックが利用できます。</p>

<p><font color="red">
注意: JDBC ドライバなどのように、ドライバ内で autocommit の有効・無効のオプションがある場合、
autocommit を無効にすると、ドライバが内部で BEGIN コマンドを実行する関係上、
正しくロードバランスされない可能性があります。
クエリをロードバランスさせたい場合は autocommit を有効にしてください。
たとえばJDBCであれば setAutoCommit(true) を実行してください。
</font></p>

<h2>レプリケーションモードにおける縮退運転について</h2>
<p>PostgreSQLサーバのうち、1台がダウンすると、そのサーバを切り離して縮退運転に入ります。
1台でもサーバが生き残っていれば、システムとしての運用を継続できます。</p>

<h2>レプリケーションモード固有のエラーについて</h2>
<p>pgpoolはレプリケーション時に UPDATE、DELETE の更新件数がすべてのノードが同じでない場合、
failover_if_affected_tuples_mismatch が falseならば、意図的に構文エラーを起すSQLを送信することによって、
トランザクションをアボートさせます。
trueならば、フェイルオーバが起きます。その際、以下のようなエラーメッセージが表示されます。</p>

<pre>
   =# UPDATE t SET a = a + 1;
   ERROR: pgpool detected difference of the number of update tuples Possible last query was: "update t1 set i = 1;"
   HINT: check data consistency between master and other db node
</pre>

<p>ログには更に以下のように、更新行数が記録されます(この場合はDBノード0が0行、DBノード1が1行)。</p>

<pre>
2010-07-22 13:23:25 LOG:   pid 5490: SimpleForwardToFrontend: Number of affected tuples are: 0 1
2010-07-22 13:23:25 LOG:   pid 5490: ReadyForQuery: Degenerate backends: 1
2010-07-22 13:23:25 LOG:   pid 5490: ReadyForQuery: Number of affected tuples are: 0 1
</pre>



<h1><a name="master_slave_mode"></a>マスタースレーブモード</h1>
<p>master/slaveモードは、Slony-IやStreaming Replicationのような、
master/slave式のレプリケーションソフトにレプリケーションをまかせるモードです。
</p>
<p>
なお、スレーブの数は1である必要はありません。
実際には127個までのスレーブを持つことができます(スレーブの数は0でも構いません)。
</p>
<p>
このモードで使うためには、レプリケーションモードと同じように、DBノードのホスト情報をセットし、
master_slave_modeとload_balance_modeをtrueにします。
このとき、問い合わせによってマスターDBだけに問い合わせが送られる場合と、
DBノードの間でロードバランスされて問い合わせが送られる場合があります。
ロードバランスの条件はレプリケーションモードと同じです。</p>

<p>マスタスレーブモードでは、一時テーブルの作成、更新、検索はマスタノードでのみ実行されます。</p>

<p>マスタースレーブモードでは、pgpool.confのreplication_modeをfalseに、master_slave_modeを
trueにします(同時にtrueにはできません)。
また、'master_slave_sub_mode'を指定します。これは、'slony'(デフォルト)か、'stream'です。
'slony'はSlony-Iを利用する時に指定します。
'stream'は、PostgreSQL組み込みのStreaming Replicationを利用するときに指定します。
Slony-Iを使う場合の設定ファイルの雛形はpgpool.conf.sample-master-slaveです。
Streaming Replicationを使う場合の雛形はpgpool.conf.sample-streamです。</p>

<p>このパラメータを変更した時には pgpool-II を再起動してください。</p>

<p>マスタースレーブモードでも、DB書き込みを行なう関数の呼び出しを含むSELECTを
負荷分散の対象から外す指定をwhite_function_listとblack_function_listで行なうことができます。
詳細は<a href="#white_function_list">white_function_list</a>の項をご覧下さい。</p>




<h1><a name="stream">Streaming Replicationへの対応</a></h1>
<p>前述のように、マスタスレーブモードで、'master_slave_sub mode'に'stream'を指定すると、
PostgreSQL 9.0から利用可能になったStreaming Replicationに対応します
(pgpool-IIでは、今のところ、Streaming ReplicationとHot Standbyを併用することを前提にしています)。
このモードでは、以下の設定項目も利用できます。</p>

<ul>
<li>delay_threshold
    <p>スタンバイサーバへのレプリケーションの遅延許容度をバイト単位で指定します。
    pgpool-IIは、ヘルスチェックの際に、スタンバイサーバの遅延がこの値を超えた場合には、
    負荷分散が有効であってもそのDBノードにSELECTを送信せず、プライマリサーバに送るようにします。
    delay_thresholdが0の場合は、遅延のチェックを行ないません。
    また、delay_thresholdが指定されていても、ヘルスチェックが無効ならば、やはりこの機能は働きません。
    デフォルト値は0です。
    このパラメータは設定ファイルの再読込によって変更できます。</p>
</li>

<li>log_standby_delay
    <p>レプリケーションの遅延状況をログする条件を指定します。
    'none'を指定すると、ログを出力しません。
    'always'ならヘルスチェックを実行するたびに必ず出力します。
    'if_over_threshold'を指定すると、delay_thresholdを超えたときだけログが出力されます。
    デフォルト値は'none'です。
    このパラメータは設定ファイルの再読込によって変更できます。
    </p>

    <p>なお、レプリケーションの遅延状況は show pool_status コマンドでも確認できます。
    項目名は"standby_delay#"です(#はDBノードIDです)。</p>
</li>
</ul>

<h2>Streaming Replicationでのフェイルオーバ</h2>
<p>Streaming replicationを利用したマスタスレーブモードでは、PrimaryやStandbyノードが停止した場合に、
レプリケーションモードと同じように自動フェイルオーバを行なわせることができます。
特に何も設定しなくても、停止したノードを自動的に切り放すことができますが、Streaming replicationでは、
「トリガファイル」を作成することにより、Standbyノードを、リカバリモードから更新問い合わせを受け付ける
通常のPostgreSQLの動作モードに自動変更することができます。
これを利用して、フェイルオーバコマンドを併用して、Primaryノードがダウンしたときに、
Standbyノードが自動的にとって代るような設定を行なうことができます。</p>

<p><strong>注意: 複数のStandbyノードを利用している場合、この設定を行なうときは、
delay_thresholdを設定して、他のStandbyに振り分けられたSELECTが
古いデータを取得しないようにしておくことをお勧めします。
また、1台目のStandbyノードがPrimaryにとって代ったのちにダウンしてしまったケースで、
2台目のStandbyが更に取って代わるとデータに不整合がおきるので、
そのような設定は行なわないようにしてください。</strong></p>

<p>フェイルオーバの設定手順を示します。</p>

<ol>
<li>フェイルオーバ用のスクリプトを適当な場所(ここでは/usr/local/pgsql/bin)に配置して、実行権限を与えておきます。
<pre>
$ cd /usr/loca/pgsql/bin
$ cat failover_stream.sh
#! /bin/sh
# Failover command for streming replication.
# This script assumes that DB node 0 is primary, and 1 is standby.
#
# If standby goes down, does nothing. If primary goes down, create a
# trigger file so that standby take over primary node.
#
# Arguments: $1: failed node id. $2: new master hostname. $3: path to
# trigger file.

failed_node=$1
new_master=$2
trigger_file=$3

# Do nothing if standby goes down.
if [ $failed_node = 1 ]; then
    exit 0;
fi

# Create trigger file.
/usr/bin/ssh -T $new_master /bin/touch $trigger_file

exit 0;

chmod 755 failover_stream.sh
</pre>
</li>

<li>pgpool.confの、failover_commmandを設定します。
<pre>
failover_command = '/usr/local/src/pgsql/9.0-beta/bin/failover_stream.sh %d %H /tmp/trigger_file0'
</pre>
</li>

<li>standbyノードのrecovery.confを設定します。
    <a href="recovery.conf.sample">recovery.confのサンプル</a>は PostgreSQLのインストールディレクトリ下の
    "share/recovery.conf.sample"にあります。
    これをstanndbyノードのデータベースクラスタ下に"recovery.conf"としてコピーしておきます。
    そして、以下の項目を設定します。
<pre>
standby_mode = 'on'
primary_conninfo = 'host=primary_hostのホスト名 user=postgres'
trigger_file = '/tmp/trigger_file0'
</pre>
</li>

<li>primaryノードのpostgresql.confを設定します。
    以下は例ですので、必ず実際に合わせて調整してください。
<pre>
wal_level = hot_standby
max_wal_senders = 1
</pre>
</li>

<li>primaryノードのpg_hba.confを設定します。
以下は例ですので、必ず実際に合わせて調整してください。
<pre>
host    replication    postgres        192.168.0.10/32        trust
</pre>
</li>
</ol>

<p>primaryとstandbyのPostgreSQLを起動すれば、Streaming replicationが開始されます。
そして、primaryノードがダウンしたときに、自動的にstandbyノードが通常のPostgreSQLとして立ち上がり、
更新問い合わせを受け付けるようになります。</p>

<h2>Streaming Replicationでのオンラインリカバリ</h2>
<p>Streaming replicationを利用したマスタスレーブモードでは、
レプリケーションモードと同じようにオンラインリカバリが利用できます。
primaryサーバをマスタとし、standbyサーバをリカバリします。
primaryサーバが動作しているのがこの方法の前提条件ですので、
primaryサーバが停止している状態ではオンラインリカバリはできません。
primaryサーガ停止している状態からの復旧は、すべてのDBノードとpgpool-IIを停止させて
手動で実施しなければなりません。</p>

<ol>
<li>リカバリ処理を実行するユーザ recovery_user を設定します。通常、postgresユーザとなります。
    <pre>recovery_user = 'postgres'</pre>
</li>

<li>recovery_password を設定します。これは、recovery_user がDBにログインするときに使うパスワードです。
    <pre>recovery_password = 't-ishii'</pre>
</li>

<li>recovery_1st_stage_command を設定します。
    ここで指定するファイルは、primaryサーバからベースバックアップを取得し、
    standbyサーバにリストアするものでなければなりません。
    recovery_1st_stage_command は、primaryのPostgreSQLから、recovery_userの権限で起動され、
    その時に引数を受けとります。
    詳細は、<a href="#RECOVERY_1ST_STAGE_COMMAND">recovery_1st_stage_command</a>の設定項目をご覧ください。
    このスクリプトファイルは、primaryのデータベースクラスタ下に配置し、実行権限を与えておきます。
    サンプルとして、primary/standbyそれぞれ一台構成の場合のスクリプト
    <a href="basebackup.sh">(basebackup.sh)</a>を示します。
    このスクリプトでは、recovery_user がパスワードなしでリカバリ対象のstandbyノードに
    ログインできることを前提にしているので、あらかじめsshの設定を行なっておく必要があります。
    <pre>recovery_1st_stage_command = 'basebackup.sh'</pre>
</li>

<li>recovery_2nd_stage_command は、空のままで構いません。
    <pre>recovery_2nd_stage_command = ''</pre>
</li>

<li>オンラインリカバリを実施するための PostgreSQL の C 言語関数やSQL関数を各DBノードにインストールします。
<pre>
# cd pgpool-II-x.x.x/sql/pgpool-recovery
# make
# make install
# psql -f pgpool-recovery.sql template1
</pre>
</li>

<li>オンラインリカバリが終了したあと、pgpool-IIは、停止していたDBノードのPostgreSQLを起動します。
    そのためのスクリプトを、各DBノードのDBクラスタにインストールします。
    <a href="pgpool_remote_start">スクリプトのサンプル</a>がソースコードの"sample"ディレクトリに含まれているので、
    それを利用してください。
    このサンプルの中では、PostgreSQLの起動をpg_ctlコマンドで行っており、pg_ctlコマンドへのパスが記述されています。
    デフォルトでは/usr/local/pgsql/bin/pg_ctlとなっているので、お使いの環境に合わせて修正してください。
    なお、このスクリプトはsshを使用しますので、少くとも、primaryのDBノードから、
    standbyのDBノードに対して、recovery_userでパスワードなしでsshが利用できることが必要です。
    必要なら ばあらかじめ設定しておいてください。
</li>
</ol>

<p>以上でオンラインリカバリの設定が終了しました。
standbyノードを停止した状態で、pcp_recovery_nodeを利用するか、
pgpoolAdminの「リカバリ」ボタンでオンラインリカバリが出来るようになったはずです。
うまくいかない場合は、pgpool-IIのログ、primaryサーバ、standbyサーバのログを確認してください。</p>

<p>参考までに、ストリーミングレプリケーションでのオンラインリカバリの内部処理の流れを説明します。</p>

<ol>
<li>pgpool-IIは、primaryサーバにユーザ: recovery_user,
    パスワード: recovery_password でtemplate1データベースに接続します。</li>

<li>primaryサーバで、pgpool_recovery関数を実行します。</li>

<li>pgpool_recovery関数は、recovery_1st_stage_command で指定されたスクリプトを実行します。
    なお、PostgreSQLは、データベースクラスタディレクトリ中で関数を実行します。
    よって、pgpool_recovery関数もprimaryサーバのデータベースクラスタディレクトリ中で
    関数を実行されることに注意してください。</li>

<li>primaryサーバで、pgpool_remote_start関数を実行します。
    この関数は、primaryサーバのデータベースクラスタディレクトリ中にある
    pgpool_remote_startという名前のスクリプトを起動し、ここからssh経由で
    リカバリ対象のstandbyサーバのPostgreSQLをpg_ctlコマンドを使って起動します。
    起動はバックグラウンドで行われ、起動できたかどうかは次のステップで確認されます。</li>

<li>pgpool-IIから、standbyサーバのPostgreSQLのpostgresデータベース
    (postgresデータベースがない場合はtemplate1データベース)に、
    ユーザ: recovery_user, パスワード: recovery_password でtemplate1データベースに接続を試みます。
    リトライは、<a href="#RECOVERY_TIMEOUT">recovery_timeout</a>秒間行われます。
    PostgreSQLの起動に成功したら、次のステップに移ります。</li>

<li><a href="#FAILBACK_COMMAND">failback_command</a>が空でない場合は、
    pgpool-IIの親プロセスは指定されたスクリプトを起動します。</li>

<li>failback_commandが終了したら、pgpool-IIの子プロセスをすべて再起動します。</li>
</ol>

<h2>Streaming Replicationでのクエリ振り分け</h2>
<p>Streaming replicationとHot Standbyを利用している環境では、primaryノードに送ってよい問い合わせ、
standbyに送ってもよい問い合わせ、両方に送らなければならない問い合わせを厳密に管理する必要があります。
pgpool-IIのStreaming Replicationモードは、こうした振り分けを自動的に行ないます。
ここでは、そのロジックについて説明します。</p>

<p>まず、問い合わせの種類によって以下のように分けられます。</p>

<ul>
<li>Primaryノードにしか送られない問い合わせ
      <ul>
       <li>INSERT, UPDATE, DELETE, COPY FROM, TRUNCATE, CREATE, DROP, ALTER, COMMENT</li>
       <li>SELECT ... FOR SHARE | UPDATE</li>
       <li>トランザクションの分離レベルがシリアライザブルの場合のSELECT</li>
       <li>ROW EXCLUSIVE MODEよりも強いLOCK</li>
       <li>トランザクションコマンドの一部</li>
            <ul>
             <li>BEGIN READ WRITE, START TRANSACTION READ WRITE
             <li>SET TRANSACTION READ WRITE, SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE
             <li>SET transaction_read_only = off
            </ul>
       </li>
       <li>二相コミット関連のコマンド。PREPARE TRANSACTION, COMMIT PREPARED, ROLLBACK PREPARED</li>
       <li>LISTEN, UNLISTEN, NOTIFY</li>
       <li>VACUUM</li>
       <li>シーケンス関連の関数(nextvalやsetvalなど)の呼び出し</li>
       <li>ラージオブジェクトの生成</li>
      </ul>
</li>

<li>Primary/Standbyどちらにも送ることのできる問い合わせ。
    負荷分散設定が有効ならば、standbyノードにも送信されます。
    ただし、レプリケーションの遅延上限(delay_threshold)が設定されていて、
    レプリケーションの遅延がdelay_thresholdを上回っている場合は問い合わせはPrimaryに送られます。
      <ul>
       <li>上記以外のSELECT</li>
       <li>COPY TO</li>
       <li>DECLARE, FETCH, CLOSE</li>
       <li>SHOW</li>
      </ul>
</li>

<li>Primary/Standbyどちらにも送られる問い合わせ
      <ul>
       <li>SET</li>
       <li>DISCARD</li>
       <li>DEALLOCATE ALL</li>
      </ul>
<li>Primary/Standbyどちらにも送ることのできる問い合わせ。
</ul>

<p>明示的なトランザクションでは、以下のようになります。</p>
<ul>
<li>BEGINなどのトランザクション開始コマンドは、Primaryサーバに送られます。</li>

<li>続くSELECTなど、Primary/Standbyどちらにも送ることのできる問い合わせは、
    Primaryのトランザクション内でそのまま実行されるか、Standbyサーバで実行されます。</li>

<li>INSERTなど、Standbyに送ることのできない問い合わせが現われた場合は、Primaryサーバで実行されます。
    以後、SELECTなど、本来Standbyに送信しても構わないコマンドもPrimaryサーバで実行されます。
    これは、トランザクションの中で実行されたINSERTなどの問い合わせの結果を
    SELECTが直ちに参照できるようにするためです。
    この状態は、トランザクションが閉じるか、アボートするまで続きます。</li>
</ul>

<p>問い合わせが、拡張問い合わせモードで実行される場合は、問い合わせのparse段階で、
問い合わせが負荷分散可能かどうかで送信先が決まります。その際の判断ルールは、通常のSQLと同じです。
たとえば問い合わせがINSERTならば、Primaryサーバで実行される、という具合です。
parseに続くbind, describe, executeも同じDBノードで実行されます。</p>

<p>[注: SELECTが負荷分散されて Standby ノードで parseが実行されてから更新クエリが来た場合は、
そのSELECTはPrimaryノードで実行されなければなりません。
そのため、同じSELECTが再度Primaryノードでパースされることになります。]</p>

<p>最後に、pgpool-IIのパーサが構文エラーと判断した問い合わせはPrimaryノードだけに送られます。</p>

<h1>パラレルモード</h1>
<p>パラレルクエリ機能が利用できるモードです。テーブルを分割させ、各ノードにデータを持たせることができます。
またレプリケーションや負荷分散機能も同時に使うことができます。</p>

<p>パラレルモードでは、pgpool.confのreplication_modeまたはloadbalance_modeにtrueを設定し、
master_slave をfalseにし、parallel_mode をtrueにします。
このパラメータを変更した時には pgpool-II を再起動してください。</p>

<p><b>システムDBの設定</b></p>

<p>パラレルモードを利用するためには、システムDBを設定する必要があります。
システムDBはデータを各PostgreSQLサーバで分割するためのルールをPostgreSQLのテーブルの形で保持します。
システムDBはpgpoolが動作するホストと同じホストに置く必要はありません。
システムDBの設定はpgpool.confで行います。</p>

<dl>
<dt>system_db_hostname</dt>
<dd>
    <p>システムDBが動いているホスト名です。空文字を指定すると、UNIXドメインソケットで接続します。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>system_db_port</dt>
<dd>
    <p>システムDBのポート番号です。このパラメータを変更した時には pgpool-IIを再起動してください。</p>
</dd>

<dt>system_dbname</dt>
<dd>
    <p>システムDBは専用のデータベースに設置します。そのデータベース名を指定します。
    このデータベースはあらかじめ存在しなければなりません。ここでは、
    "pgpool"というデータベース名にするものとします。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>system_db_schema</dt>
<dd>
    <p>システムDBは専用のスキーマに設置します。そのスキーマ名を指定します。
    このスキーマはあらかじめ存在しなければなりません。ここでは、
    "pgpool_catalog"というスキーマにするものとします。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>system_db_user</dt>
<dd>
    <p>システムDBに接続するときのユーザ名です。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

<dt>system_db_password</dt>
<dd>
    <p>システムDBに接続するときのパスワードです。パスワードを設定していない場合は空文字にしておきます。
    このパラメータを変更した時には pgpool-II を再起動してください。</p>
</dd>

</dl>

<h2><p>システムDBの初期設定</p></h2>
<p>システムDBにスキーマとテーブルを作成します。初期設定用のスクリプトが
$prefix/share/system_db.sqlにあるのでそれを利用します。
ただし、このスクリプトではスキーマ名が"pgpool_catalog"となっているので、
違うスキーマを使う場合は適当に書き換えてください。
また、データベース名として"pgpool"以外を使う場合は以下を適当に読み替えてください。</p>

<p>psql -f $prefix/share/system_db.sql pgpool</p>

<h2>dblinkのインストール</h2>
<p>パラレルモードではdblinkを使います。dblinkはPostgreSQLソースファイル($POSTGRES_SRC)</p>

<pre>$(POSTGRES_SRC)/contrib/dblink</pre>

<p>にあります。$POSTGRES_SRC/contrib/dblink/README.dblinkを参考にシステムDBにdblinkをインストールしてください。
また、pgpoolデータベースに関数の登録が必要です。</p>

<pre>psql pgpool &lt; $POSTGRES_SRC/contrib/dblink/dblink.sql</pre>

<h2>コネクション数の設定</h2>
<p>パラレルモードでは、クエリによりシステムDBからdblink経由でpgpoolに接続するので、
想定される同時接続数以上のコネクションが必要になる場合があります。
そのため、pgpool.confのnum_init_childrenには同時接続数より十分大きい値を設定して下さい。</p>

<p>目安として以下の式でnum_init_childrenを設定してください。</p>

<pre>num_init_children = 想定される同時接続数 * ( 1 + クエリの中で使われているテーブルの最大数)</pre>

<h2>データ分割ルールの登録</h2>
<p>データ分割を行うテーブルに対しては、テーブル情報をあらかじめ pgpool_catalog.dist_def
というテーブルに登録しておきます。</p>

<pre>
CREATE TABLE pgpool_catalog.dist_def(
    dbname TEXT,    -- DB名
    schema_name TEXT,    --schema名
    table_name TEXT,    -- テーブル名
    col_name TEXT NOT NULL CHECK (col_name = ANY (col_list)),    -- 分散キー列名
    col_list TEXT[] NOT NULL,    -- tableの属性名
    type_list TEXT[] NOT NULL,    -- 属性のタイプ名
    dist_def_func TEXT NOT NULL,    -- 分散先のDBノードを決定する関数名
    PRIMARY KEY (dbname,schema_name,table_name)
);
</pre>

<h4>レプリケーションテーブルのルール登録</h4>
<p>一つのSQL文にJOIN等でデータ分割ルールに登録したテーブルと共にレプリケーションを行う
テーブルを指定する場合には、レプリケーションを行うテーブルの情報をあらかじめ、
pgpool_catalog.replicate_def というテーブルに登録しておきます。</p>

<pre>
CREATE TABLE pgpool_catalog.replicate_def(
    dbname TEXT,    -- DB名
    schema_name TEXT,    --schema名
    table_name TEXT,    -- テーブル名
    col_list TEXT[] NOT NULL,    -- tableの属性名
    type_list TEXT[] NOT NULL,    -- 属性のタイプ名
    PRIMARY KEY (dbname,schema_name,table_name)
);
</pre>

<p>pgbenchのテーブルを分割するルールの例を示します。</p>

<p>この例では、accountsテーブルに対しては分割を行い、branchesテーブルとtellersテーブルに対しては
レプリケーションを行うことにします。
また、accountsテーブルとbanchesテーブルはbidで結合されることを想定し
branchesテーブルはレプリケーションテーブルのルール登録を行います。

もし、accountsテーブル、branchesテーブルとtellersテーブルの３つの
テーブルの結合が行われる場合には、あらかじめtellersテーブルに対しても
レプリケーションテーブルのルール登録を行う必要があります。</p>

<pre>
INSERT INTO pgpool_catalog.dist_def VALUES (
    'pgpool',
    'public',
    'accounts',
    'aid',
    ARRAY['aid','bid','abalance','filler'],
    ARRAY['integer','integer','integer','character(84)'],
    'pgpool_catalog.dist_def_accounts'
);

INSERT INTO pgpool_catalog.replicate_def VALUES (
    'pgpool',
    'public',
    'branches',
    ARRAY['bid','bbalance','filler'],
    ARRAY['integer','integer','character(84)']
);
</pre>

<p>ここで、pgpool_catalog.dist_def_accountsは、引数として分割キーの値を受け取り、
どのPostgreSQLサーバ(「DBノード」と呼びます)を0からの番号で返す関数です。
ここでは、3台のDBノードにデータを分割する関数の例を示します。</p>

<pre>
CREATE OR REPLACE FUNCTION pgpool_catalog.dist_def_accounts (val ANYELEMENT) RETURNS INTEGER AS '
  SELECT CASE WHEN $1 &gt;= 1 and $1 &lt;= 30000 THEN 0
          WHEN $1 &gt; 30000 and $1 &lt;= 60000 THEN 1
          ELSE 2
  END' LANGUAGE SQL;
</pre>




<h1><a name="hba"></a>クライアント認証(HBA)のための pool_hba.conf 設定方法</h1>
<p> PostgreSQLのpg_hba.confと同じようにpgpoolでもpool_hba.confファイルを使った
クライアント認証がサポートされています。</p>

<p>pgpoolをインストールするとデフォルトインストール先の設定ファイルディレクトリ
"/usr/local/etc"にpool_hba.conf.sampleが一緒にインストールされます。
このpool_hba.conf.sampleファイルをpool_hba.confとしてコピーし、必要であれば編集してください。
デフォルトではpool_hbaによる認証は無効になっています。</p>

<p>pool_hba.confのフォーマットはpg_hba.confのものとほとんど同じです。</p>
<pre>
     local      DATABASE  USER  METHOD  [OPTION]
     host       DATABASE  USER  CIDR-ADDRESS  METHOD  [OPTION]
</pre>

<p>各フィールドで設定できる値の詳細は"pool_hba.conf.sample"を参照してください。</p>

<p>以下はpool_hbaの制限事項です。</p>

<ul>
<<<<<<< HEAD
<li>"hostssl"接続タイプはサポートされません
    <p>pool_hba.confに"hostssl"は指定することはできませんが、pgpool-IIは2.3以降でSSLをサポートしています。
    詳細は<a href="#ssl">SSL</a>を参照してください。
    </p>
</li>

<li>DATABASEフィールド値として"samegroup"はサポートされません</li>
    <p>pgpoolはバックエンドサーバにあるユーザ情報を事前に知る事ができないため、
=======
    <li>DATABASEフィールド値として"samegroup"はサポートされません</li>
    <p>
    pgpoolはバックエンドサーバにあるユーザ情報を事前に知る事ができないため、
>>>>>>> fb819b2... Remove old restriction description which is no longer true.
    データベース名はpool_hba.confにある値のみと比較されます。
    なのでグループに関する認証はpool_hbaで行うことができません。</p>
</li>

<li>USERフィールド値として"+"を使ったグループ指定はサポートされません</li>
    <p>上記の"samegroup"と同じ理由で、ユーザ名はpool_hba.confにある値のみと比較されます。
    グループに関する認証はpool_hbaで行うことはできません。</p>
</li>

<li>IPv6アドレス/マスク表記法はサポートされません</li>
    <p>現在pgpoolはIPv6をサポートしていません。</p>
</li>

<li>"trust", "reject", "pam", "md5"以外のメソッドはサポートされません</li>
    <p>これも上記の"samegroup"と同じ理由によるものです。
    pgpoolはバックエンドのユーザ/パスワード情報を持っていないので、
    バックエンドに保存されているパスワードを使った認証を行うことができません。</p>

    <p>md5に関しては、pool_passwdというパスワードファイルを併用することによって利用できます。
    詳細は<a href="#md5">認証・アクセス制御方式</a>を参照してください。</p>
</li>
</ul>

<p>ここで説明された機能、制限はクライアントとpgpool間で行われるクライアント認証についてだということに
注意してください。
クラインアントはpgpoolのクライアント認証に成功したとしても、
PostgreSQLによるクライアント認証に成功しないと接続状態となりません。
pool_hbaにとってはクライアントに指定されたユーザ名やデータベース名
(例. psql -U testuser testdb)が実際にバックエンド上に存在するかどうかは問題ではありません。
それがpool_hba.confの値とマッチするかどうかでチェックが行われます。</p>

<p>pgpoolが稼働するホスト上のユーザ情報を使ったPAM認証を利用することができます。
pgpoolをPAMサポート付きでビルドするにはconfigureオプションに"--with-pam"を指定してください。</p>
<pre>./configure --with-pam</pre>

<p>実際にPAM認証を有効にするには、pool_hba.confで"pam"メソッドを設定するのに加え、
pgpoolのサービス設定ファイルをシステムのPAM設定ディレクトリ
（通常は /etc/pam.d） に作成する必要があります。
サービス設定ファイルの例はインストールディレクトリの"share/pgpool.pam"を参考にしてください。</p>

<h2>クエリキャッシュの設定方法</h2>

<p>pgpool-IIでは、すべてのモードでクエリキャッシュを利用することができます。
利用する場合には、pgpool.confの設定を以下のように設定します。</p>

<pre>enable_query_cache = true</pre>

<p>また、システムDBに以下のテーブルを作成してください。</p>
<pre>
CREATE TABLE pgpool_catalog.query_cache (
  hash TEXT,
  query TEXT,
  value bytea,
  dbname TEXT,
  create_time TIMESTAMP WITH TIME ZONE,
  PRIMARY KEY(hash, dbname)
);
</pre>
<p>ただし、この例ではスキーマ名が"pgpool_catalog"となっているので、
違うスキーマを使う場合は適当に書き換えてください。</p>




<h1>pgpool-IIの起動と停止<a name="start"></a></h1>
<p>以上で設定が終わったので、各DBノードを起動し、必要ならばシステムDBも起動してからpgpool-IIを起動します。</p>
<pre>pgpool [-c][-f config_file][-a hba_file][-F pcp_config_file][-n][-D][-d]</pre>

<p>
<table>
<tr><td>-c</td><td>クエリキャッシュを消去します</td></tr>
<tr><td>-f config_file</td><td>pgpool-IIの設定ファイルを指定します</td></tr>
<tr><td>-a hba_file</td><td>HBA認証設定ファイルを指定します</td></tr>
<tr><td>-F pcp_config_file</td><td>pcpの設定ファイルを指定します</td></tr>
<tr><td>-n</td><td>デーモンモードで起動しません(制御端末を切り離しません</td></tr>
<tr><td>-D</td><td>pgpool_statusを削除し、以前の状態を復元しません</td></tr>
<tr><td>-d</td><td>デバッグモードで起動します</td></tr>
</table>
</p>

<p>pgpool-IIの停止は後述のpcpコマンドでもできますが、pgpool-IIコマンドを使うこともできます。</p>
<pre>pgpool [-f config_file][-F pcp_config_file] [-m {s[mart]|f[ast]|i[mmediate]}] stop</pre>

<p>
<table>
<tr><td>-m s[mart]</td><td>接続中のクライアントが接続を終わるのを待ってから停止します(デフォルト)</td></tr>
<tr><td>-m f[ast]</td><td>接続中のクライアントが接続を終わるのを待たずに直ちに停止します</td></tr>
<tr><td>-m i[mmediate]</td><td>-m fと同じ動作です</td></tr>
</table>
</p>

<p>pgpoolが停止すると、[logdir]/pgpool_statusというファイルにバックエンドの状態を書き込みます。
次回pgpoolが起動したときにこのファイルが存在すると、バックエンドの状態をそこから復元します。
これによって、</p>

<ol>
<li>バックエンドが停止してフェイルオーバ</li>
<li>pgpool経由で正常なDBを更新</li>
<li>pgpoolを停止</li>
<li>停止していたDBを再起動</li>
<li>pgpoolを再起動</li>
</ol>

<p>というシーケンスで、不整合のあるDBからレプリケーション状態に移行することを防ぐことができます。</p>

<p>もしもDBの状態に不整合がなくなっている、あるいはpgpool.confを書き換えて設定を変えてしまった、
というときはpgpool_statusを削除すればバックエンドの状態の復元を行いません。</p>



<h1>pgpool-IIの設定ファイルの再読み込み<a name="reload"></a></h1>
<p>pgpool-IIの設定ファイルは、pgpool-IIを再起動することなく読み直すことができます。</p>
<pre>pgpool [-f config_file][-a hba_file][-F pcp_config_file] reload</pre>

<p>
<table>
<tr><td>-f config_file</td><td>pgpool-IIの設定ファイルを指定します</tr>
<tr><td>-a hba_file</td><td>HBA認証設定ファイルを指定します</tr>
<tr><td>-F pcp_config_file</td><td>pcpの設定ファイルを指定します</tr>
</table>
</p>

<p>設定項目によっては、再読み込みを行なっても反映されないものがあるので、ご注意下さい。
また、設定の変更はすでに接続中のセッションには反映されません。
次回、クライアントがpgpool-IIに接続したときから反映されます。</p>




<h1><a name="show-commands"></a>SHOWコマンド</h1>
<h2>概要</h2>
<p>pgpool-IIでは、SHOWコマンドを使って情報を参照することができます。
SHOWはSQLコマンドですが、pgpool-IIは一部のSHOWコマンドを独自に解釈して、pgpool-IIが管理する情報を返却します。
以下のようなものがあります。</p>

<ul>
  <li>pool_status 構成情報</li>
  <li>pool_nodes DBノード情報</li>
  <li>pool_processes pgpool-IIプロセスの内部情報</li>
  <li>pool_pools コネクションプール情報</li>
  <li>pool_version pgpool-IIのバージョン</li>
</ul>

<p>"pool_status" SQL は以前からありますが、他のSQLはpgpool-II 3.0から追加されました。</p>

<h2>pool_status</h2>
<p>"SHOW pool_status" は設定パラメータの名前と値、説明を表示します。出力の一部を示します。</p>
<pre>
benchs2=# show pool_status;
             item              |              value              |                           description
-------------------------------+---------------------------------+------------------------------------------------------------------
 listen_addresses              | 127.0.0.1                       | host name(s) or IP address(es) to listen to
 port                          | 9999                            | pgpool accepting port number
 socket_dir                    | /tmp                            | pgpool socket directory
 num_init_children             | 5                               | # of children initially pre-forked
 child_life_time               | 300                             | if idle for this seconds, child exits
</pre>

<h2>pool_nodes</h2>
<p>"SHOW pool_nodes"は、DBノードのリストを表示します。
ホスト名、ポート番号、状態、重み(ロードバランスモードで運用しているときにのみ意味があります)が表示されます。
状態(status)の意味については、<a href="#pcp_node_info">pcp_node_infoリファレンス</a>で説明されています。</p>

<pre>
benchs2=# show pool_nodes;
  hostname   | port | status |     lb_weight
-------------+------+--------+-------------------
 127.0.0.1   | 5432 | 2      | 1073741823.500000
 192.168.1.7 | 5432 | 3      | 1073741823.500000
(2 lignes)
</pre>

<h2>pool_processes</h2>
<p>"SHOW pool_processes"は、接続待ち、あるいは接続中pgpool-IIの子プロセスの状態を表示します。</p>
<p>6つのカラムがあります。</p>
<ul>
<li>pool_pid はpgpool-IIプロセスのプロセスIDです。</li>
<li>start_timeはこのプロセスが起動された時刻です(1970年1月1日からの経過秒で表示されます)。</li>
<li>databaseはこのプロセスが接続しているデータベース名です。</li>
<li>usernameはこのプロセスの接続で使用しているユーザ名です。</li>
<li>create_time isはこの接続が作成された時刻です。</li>
<li>pool_counter はこの接続が使用された回数です。</li>
</ul>

<p>返却行数は常にnum_init_childrenになります。
また、データベース名などが表示されるのは、そのプロセスにフロントエンドからの接続がある場合に限ります。</p>
<pre>
benchs2=# show pool_processes;
 pool_pid | start_time | database  | username  | create_time | pool_counter
----------+------------+-----------+-----------+-------------+--------------
 4318     | 1281433036 |           |           |             |
 4319     | 1281433036 |           |           |             |
 4320     | 1281433036 | benchs2   | guillaume | 1281433038  | 1
 4321     | 1281433036 |           |           |             |
 4322     | 1281433036 |           |           |             |
(5 lines)
</pre>

<h2>pool_pools</h2>
<p>"SHOW pool_pools"は、pgpool-IIのコネクションプールの状態を表示します。</p>
<p>11のカラムがあります。</p>

<ul>
<li>start_timeはこのプロセスが起動された時刻です(1970年1月1日からの経過秒で表示されます)。</li>
<li>pool_pid はpgpool-IIプロセスのプロセスIDです。</li>
<li>pool_id はコネクションプールIDです。(0からmax_pool-1の値です)</li>
<li>backend_id はPostgreSQLバックエンドの識別子です(0からバックエンド数-1の値です)</li>
<li>databaseはこのプロセスが接続しているデータベース名です。</li>
<li>usernameはこのプロセスの接続で使用しているユーザ名です。</li>
<li>create_time isはこの接続が作成された時刻です。</li>
<li>majorversion と minorversion はこの接続で使用されているプロトコルバージョン番号です。</li>
<li>pool_counter はこの接続が使用された回数です。</li>
<li>pool_backendpid は PostgreSQL のバックエンドプロセスのプロセスIDです。</li>
<li>pool_connected は真偽値で、0ならフロントエンドからの接続無し、1なら接続ありを表します。</li>
</ul>

<p>返却行数は常にnum_init_children*max_pool*「バックエンドの数」になります。</p>
<pre>
benchs2=# show pool_pools;

 pool_pid | start_time | pool_id | backend_id | database | username  | create_time | majorversion | minorversion | pool_counter | pool_backendpid | pool_connected
----------+------------+---------+------------+----------+-----------+-------------+--------------+--------------+--------------+-----------------+----------------
 4318     | 1281433036 | 0       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4318     | 1281433036 | 1       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4318     | 1281433036 | 2       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4318     | 1281433036 | 3       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4319     | 1281433036 | 0       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4319     | 1281433036 | 1       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4319     | 1281433036 | 2       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4319     | 1281433036 | 3       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4320     | 1281433036 | 0       | 0          | benchs2  | guillaume | 1281433038  | 3            | 0            | 1            | 4327            | 1
 4320     | 1281433036 | 1       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 1
 4320     | 1281433036 | 2       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4320     | 1281433036 | 3       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4321     | 1281433036 | 0       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4321     | 1281433036 | 1       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4321     | 1281433036 | 2       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4321     | 1281433036 | 3       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4322     | 1281433036 | 0       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4322     | 1281433036 | 1       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4322     | 1281433036 | 2       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
 4322     | 1281433036 | 3       | 0          |          |           | 0           | 0            | 0            | 0            | 0               | 0
(20 lines)
</pre>

<h2>pool_version</h2>
<p>"SHOW pool_version" はpgpool-IIのバージョン情報を表示します。
例を示します。</p>
<pre>
benchs2=# show pool_version;
      pool_version
------------------------
 3.0-dev (umiyameboshi)
(1 line)
</pre>



<h1><a name="online-recovery"></a>オンラインリカバリ</h1>


<h2> オンラインリカバリ概要</h2>
<p>この章では、レプリケーションモードで利用する場合のオンラインリカバリ機能について説明します。
マスタ／スレーブモード(Streaming Replication)でのオンラインリカバリの利用方法については、
<a href="#stream">Streaming Replicationへの対応</a>をご覧下さい。
レプリケーションモードで pgpool が動作している場合、ダウンしたノードのデータを再同期させた上で、
ノードを復帰させることができます。この機能を「オンラインリカバリ」と呼びます。</p>

<p>オンラインリカバリを実施するためには、ノードが切り離されているとpgpool が検知している必要があります。
ノードを動的に追加したい場合には pgpool.conf の backend_hostnameなどのパラメータを追加しておき、
設定ファイルを再読み込みさせると、ノードが切り離された状態で pgpool にノード情報が登録されます。</p>

<p>また、リカバリするノードの PostgreSQL がすでに動作中であれば、
あらかじめ PostgreSQL をシャットダウンさせておいてください。</p>

<p>pgpool ではオンラインリカバリを 2 段階に分けて実施します。
pgpool のクライアントからは完全なデータの同期を取るために若干の接続待ちが発生します。
リカバリ手順で以下の通りです。</p>
  <ol>
    <li> CHECKPOINT 実行
    <li> ファーストステージの実施
    <li> 接続がすべて切断されるまで待機
    <li> CHECKPOINT 実行
    <li> セカンドステージの実施
    <li> postmaster の起動(pgpool_remote_start の実行)
    <li> ノードの復帰
  </ol>


<p>データ同期の第一段階を「ファーストステージ」と呼びます。
ファーストステージ中に1 回目のデータ同期を行います。
ファーストステージ中はデータの更新や参照を並行して行うことができます。</p>

<p>ファーストステージで処理する内容はユーザが定義することができます。
スクリプトでは 3 つの引数を受け取ることができます。</p>
  <ol>
    <li> マスタのデータベースクラスタパス
    <li> リカバリノードのホスト名
    <li> リカバリノードのデータベースクラスタパス
  </ol>

<p>次に 2 回目のデータ同期を行います。これを「セカンドステージ」と呼びます。
pgpool ではセカンドステージに入る前に接続中のクライアントがすべて接続が終了されるまで待ちます。
その間に接続リクエストが来た場合には、その接続をすべてブロックします。</p>

<p>セカンドステージで処理する内容はユーザが定義することができます。
スクリプトでは 3 つの引数を受け取ることができます。</p>
  <ol>
    <li> マスタのデータベースクラスタパス
    <li> リカバリノードのホスト名
    <li> リカバリノードのデータベースクラスタパス
  </ol>

<p>すべての接続が終了されると、ファーストステージ以降に更新されたデータを同期するための
セカンドステージが開始されます。そこで最終的なデータの同期を行います。
この間はクライアントからは pgpool への接続が待たされる状態になります。</p>

<p><font color="red">なお、オンラインリカバリの制限事項として、複数のホストに pgpool を
配置してレプリケーションさせている場合には、オンラインリカバリは正しく動作しません。
どれかの pgpool にリカバリリクエストを出した時に、他の pgpool から更新が伝搬すると、
データを同期させることができなくなります。</font></p>


<h2> pgpool の設定</h2>
<p>オンラインリカバリを設定するためには、pgpool.conf の以下の値を設定してください。</p>

<ul>
<li>backend_data_directory
<li>recovery_user
<li>recovery_password
<li>recovery_1st_stage_command
<li>recovery_2nd_stage_command
</ul>


<h2> C 言語関数のインストール</h2>
<p>次に、リカバリを実施するための PostgreSQL の C 言語関数を各ノードの
template1 データベースにインストールします。ソースコードは</p>
<pre>pgpool-II-x.x.x/sql/pgpool-recovery/</pre>
<p>にあります。ディレクトリを移動し、make install してください。</p>

<pre>
  % cd pgpool-II-x.x.x/sql/pgpool-recovery/
  % make install
</pre>

<p>
C 言語関数のモジュールをインストールしたら、続いて C 言語関数を呼びだ
すための SQL をインストールします。
</p>

<pre>
  % cd pgpool-II-x.x.x/sql/pgpool-recovery/
  % psql -f pgpool-recovery.sql template1
</pre>


<h2> リカバリスクリプトの配置</h2>
<p>データを同期させるためのスクリプトと、リモートから postmaster を再起動させるためのスクリプトを
各ノードの $PGDATA 以下に配置します。
あらかじめpgpool-II-x.x.x/sample 以下にサンプルスクリプトも用意してありますので参考にしてください。
ここではサンプルスクリプトを使って、PITR によるリカバリ方法と、rsync によるリカバリ方法を説明します。</p>


<h3>PITR によるリカバリ</h3>
<p>ここでは PostgreSQL 8.2 以降で PITR 機能を使ってリカバリをする設定例を説明します。
PITR によるリカバリをする場合にはあらかじめ PostgreSQL の設定でログをアーカイブさせるようにしておいてください。</p>

<p>まずファーストステージでベースバックアップを取得し、リカバリ先へコピーするスクリプト
(ここではファイル名を copy-base-backup とします)を用意します。
例えば以下のようなスクリプトで取得することができます。</p>

<pre>
  #! /bin/sh

  DATA=$1
  RECOVERY_TARGET=$2
  RECOVERY_DATA=$3

  psql -c "select pg_start_backup('pgpool-recovery')" postgres
  echo "restore_command = 'scp $HOSTNAME:/data/archive_log/%f %p'" &gt; /data/recovery.conf
  tar -C /data -zcf pgsql.tar.gz pgsql
  psql -c 'select pg_stop_backup()' postgres
  scp pgsql.tar.gz $RECOVERY_TARGET:$RECOVERY_DATA
</pre>

<p>ベースバックアップ取得時に recovery.conf を生成しておきます。</p>
<pre>restore_command = 'scp master:/data/archive_log/%f %p'</pre>

<p>セカンドステージでは最新の状態まで PITR によるリカバリを実施できるようにするために、
pgpool_recovery_pitr スクリプトを$PGDATA にコピーします。
このスクリプトではトランザクションログを強制的に切り替えるようにします。
通常、トランザクションログを切り替えるには、pg_switch_xlog 関数を利用しますが、
この関数は、アーカイブログファイルが生成される前に終了してしまう可能性があります。
そこで、より安全にオンラインリカバリを行うためにpgpool_switch_xlog 関数が用意されています。
pgpool_switch_xlog 関数の基本動作は pg_switch_xlog 関数と同じですが、
トランザクションログの切り替えによるアーカイブログファイルの生成を待ってから終了します。
この関数は、前述の「C言語関数のインストール」を実施するとインストールされ、
引数にはアーカイブログの出力先ディレクトリを指定します。</p>

<pre>
#! /bin/sh
# Online recovery 2nd stage script
#
datadir=$1        # master dabatase cluster
DEST=$2            # hostname of the DB node to be recovered
DESTDIR=$3        # database cluster of the DB node to be recovered
port=5432        # PostgreSQL port number
archdir=/data/archive_log    # archive log directory

# Force to flush current value of sequences to xlog
psql -p $port -t -c 'SELECT datname FROM pg_database WHERE NOT datistemplate AND datallowconn' template1|
while read i
do
  if [ "$i" != "" ];then
    psql -p $port -c "SELECT setval(oid, nextval(oid)) FROM pg_class WHERE relkind = 'S'" $i
  fi
done

psql -p $port -c "SELECT pgpool_switch_xlog('$archdir')" template1
</pre>

<p>スクリプト中のwhileループは、全データベース中のシーケンス値をトランザクションログに吐き出します。
これによって、シーケンスも正しくリカバリされるようになります。</p>

<p>スクリプトの配置が完了したら pgpool.conf に設定します。</p>

<pre>
recovery_1st_stage_command = 'copy-base-backup'
recovery_2nd_stage_command = 'pgpool_recovery_pitr'
</pre>

<p>これで PITR によるオンラインリカバリの準備が完了です。</p>

<h4>pgpool_remote_start</h4>
<p>データ再同期後に postmaster を起動させるスクリプトです。
pgpool からは以下の形式でスクリプトを実行します。</p>

<pre>
  % pgpool_remote_start remote_host remote_datadir
  remote_host:    リカバリノードのホスト名
  remote_datadir: リカバリノードのデータベースクラスタパス
</pre>

<p>サンプルスクリプトでは ssh 経由で postmaster を起動しています。
こちらもあらかじめパスフレーズ無しで ssh 経由でログインできるように設定しておく必要があります。</p>

<p>PITR によるリカバリであれば、pgpool_remote_start 内でベースバックアップを展開し、
recovery.conf の内容にしたがってリカバリした後にpostmaster が接続可能状態になります。</p>

<pre>
#! /bin/sh
DEST=$1
DESTDIR=$2
PGCTL=/usr/local/pgsql/bin/pg_ctl

# Expand a base backup
ssh -T $DEST 'cd /data/; tar zxf pgsql.tar.gz' 2&gt;/dev/null 1&gt;/dev/null &lt; /dev/null
# Startup PostgreSQL server
ssh -T $DEST $PGCTL -w -D $DESTDIR start 2&gt;/dev/null 1&gt;/dev/null &lt; /dev/null &amp;
</pre>


<h3>rsync によるリカバリ </h3>
<p>7.4 以前の場合は PITR 機能がありません。また、8.0 と 8.1 の場合は
トランザクションログを強制的に切り替える関数が用意されていません。
そこで PITR を使わずにrsync を使ったリカバリ方法を説明します。
sample ディレクトリに pgpool_recovery というファイルがあります。
マスタから復帰させるノードへのデータの物理コピーを行うスクリプトです。
pgpool からは以下の形式でスクリプトを実行します。</p>

<pre>
  % pgpool_recovery datadir remote_host remote_datadir
  datadir:        マスタのデータベースクラスタパス
  remote_host:    リカバリノードのホスト名
  remote_datadir: リカバリノードのデータベースクラスタパス
</pre>

<p>サンプルスクリプトでは rsync を使って物理コピーをしています。もし
rsync を使う場合は、パスフレーズ無しで ssh 経由でログインできるように
あらかじめ設定しておく必要があります。</p>

<p>rsyncに関する注記:</p>
<ul>
 <li>-c (or --checksum) オプションを付けないと、ファイルが確実に転送されない場合があります。</li>
 <li>-z (or --compress)オプションは低速なネットワークでは効果がありますが、
      100M以上の高速なネットワークではかえってCPU負荷を増やし、結果的に遅くなることがあります。
      高速ネットワークでは、このオプションを使用しないことをお勧めします。</li>
 <li>rsync の新しいバージョン(3.0.5)では、50%も性能が良くなったという報告が
     pgpool-generalメーリングリストでありました。</li>
</ul>

<p>pgpool_recovery を使う場合は pgpool.conf に以下の行を追加してください。</p>

<pre>
recovery_1st_stage_command = 'pgpool_recovery'
recovery_2nd_stage_command = 'pgpool_recovery'
</pre>


<h2>リカバリの実行</h2>
<p>以上でオンラインリカバリの準備が整いました。
オンラインリカバリを実行するには pcp_recovery_node コマンドを使うか、
pgpool 管理ツールから実行してください。</p>

<p>注意点として、pcp_recovery_node を実行する際に、タイムアウトを長くしてください。
pgpoolAdmin から実行する場合は pgmgt.conf.php 内の_PGPOOL2_PCP_TIMEOUT を大きくしてください。
</p>

<h2>オンラインリカバリを利用したPostgreSQLのマイナーバージョンアップ</h2>
<h3>レプリケーションモードの場合</h3>
<p>レプリケーションモードでpgpool-IIが動作している場合は、
オンラインで各ノードのPostgreSQLをバージョンアップできます。
ただし、ノードの切り離し時と追加時に、pgpool-IIに接続している
すべてのセッションが切断されるので注意してください。
また、オンラインリカバリが利用できるバージョンアップはマイナーバージョンアップのみで、
ダンプ/リストアが不要なリリースに限ります。</p>

<p>はじめに、上記の「オンラインリカバリの概要」を参考に
各ノードでオンラインリカバリが利用できるように準備します。</p>

<p>PostgreSQLのバージョンアップは、マスタ以外のノードから行い、最後にマスタノードをバージョンアップします。
そこで、まずバージョンアップを行うマスタ以外の１つのノードのPostgreSQLを停止します。
pgpool-IIがPostgreSQLの停止を検知すると、以下のようなログを出力して縮退運転に移行します。
その際、pgpool-IIに接続しているすべてのセッションは一旦切断されます。</p>
<pre>
2010-07-27 16:32:29 LOG:   pid 10215: set 1 th backend down status
2010-07-27 16:32:29 LOG:   pid 10215: starting degeneration. shutdown host localhost(5433)
2010-07-27 16:32:29 LOG:   pid 10215: failover_handler: set new master node: 0
2010-07-27 16:32:29 LOG:   pid 10215: failover done. shutdown host localhost(5433)
</pre>

<p>停止したノードのPostgreSQLをバージョンアップします。
バージョンアップは、新しいバージョンのPostgreSQLを古いバージョンのインストール先に上書きしても構いませんが、
問題が起きた時に元のバージョンに戻せるようにインストール先を変えておくことをお勧めします。</p>

<p>新しいバージョンのPostgreSQLを古いバージョンと別の場所にインストールした場合、
リカバリスクリプトを編集することなくそのまま使用するには、
シンボリックリンクなどを使用してインストール先のパスを以前と合わせる必要があります。
上書きインストールした場合は以下のC言語関数をインストールするまでの操作は不要です。
すぐにオンラインリカバリが実行できます。</p>

<p>古いバージョンのPostgreSQLのインストール先ディレクトリ名を変更します。
以下は、PostgreSQLが/usr/local/pgsqlにインストールされていたと仮定した一例です。</p>
<pre>$ mv /usr/local/pgsql /usr/local/pgsql-old</pre>

<p>新しいバージョンのPostgreSQLのインストール先にシンボリックリンクを作成します。
これにより、今までどおりのパスで新しいバージョンのPostgreSQLが使用できるようになります。
以下は、新しいバージョンのPostgreSQLが/usr/local/pgsql-newにインストールされていると仮定した一例です。</p>
<pre>$ ln -s /usr/local/pgsql-new /usr/local/pgsql</pre>

<p>データベースクラスタディレクトリがPostgreSQLのインストール先ディレクトリの下位にある場合は、
同じパスでデータベースクラスタにアクセスできるようにシンボリックリンクを作成するかコピーします。
以下は、シンボリックリンクを作成する例です。</p>
<pre>$ ln -s /usr/local/pgsql-old/data /usr/local/pgsql/data</pre>

<p>新しいバージョンのPostgreSQLに、オンラインリカバリ用の関数を
「C言語関数のインストール」を参考にインストールします。
オンラインリカバリは、データベースクラスタをコピーしますので、最後のpsqlを使用した関数の作成は不要です。
make installを実行してください。</p>

<p>最後にオンラインリカバリを実行して、１つのノードのバージョンアップが完了します。
オンラインリカバリは、pcp_recovery_nodeコマンドを実行するかpgpoolAdminで行います。</p>

<p>以上の手順をマスタ以外のノードで繰り返し、最後にマスタノードで行えば、
全体のPostgreSQLのマイナーバージョンアップは完了です。</p>

<h3>Streaming Replicationを利用している場合</h3>
<p>マスタースレーブモードでStreaming Replicationを利用している場合は、
オンラインでスタンバイのPostgreSQLをマイナーバージョンアップできます。</p>

<p>スタンバイのPostgreSQLをマイナーバージョンアップする手順は、上記のレプリケーションモードの手順と同じです。
ただし、recovery_1st_stage_commandとrecovery_2nd_stage_commandの設定などは、
「Streaming Replicationでのオンラインリカバリ」を参考にしてください。</p>

<p>プライマリのPostgreSQLのマイナーバージョンアップは、オンラインではできません。
pgpool-IIの停止が必要になります。
プライマリのPostgreSQLもバージョンアップの方法自体は、スタンバイと同様です。
プライマリのPostgreSQLのバージョンアップは以下の手順で行います。</p>

<ol>
<li>pgpool-IIを停止
<li>プライマリのPostgreSQLを停止
<li>プライマリのPostgreSQLをバージョンアップ
<li>プライマリのPostgreSQLを起動
<li>pgpool-IIを起動
</ol>



<h1><a name="backup"></a>バックアップ</h1>
<p>バックエンドとシステムDBのPostgreSQLのバックアップは、単体のPostgreSQLと同様に、
物理バックアップ、論理バックアップ(pg_dump, pg_dumpall)、PITRが使用できます。
ただし、論理バックアップとPITRの操作は、pgpool-IIを経由せずにPostgreSQLに対して直接行ってください。
これは、load_balance_modeやreplicate_selectなどの設定によるバックアップの失敗を避けるためです。</p>


<h2>レプリケーションモード、マスタースレーブモード</h2>
<p>レプリケーションモードとマスタースレーブモードでpgpool-IIが動作している場合は、
クラスタを構成しているいずれかのノードでバックアップを行います。</p>

<p>マスタースレーブモードで非同期のレプリケーションを行っている場合で、かつ、
最新のバックアップを取得したい場合は、マスタノードでバックアップしてください。</p>

<p>バックアップ時の注意点として、PostgreSQLに対してpg_dumpコマンドなどを実行すると、
ACCESS SHAREモードのロックがかかります。
そのため、ACCESS SHAREモードと競合するACCESS EXCLUSIVEロックが必要になるコマンド
（ALTER TABLE、DROP TABLE、TRUNCATE、REINDEX、CLUSTERおよびVACUUM FULLなど）は、ロック待ちが発生します。
これは、非同期のレプリケーションで、スレーブノードに対してバックアップを行っている場合も、
マスタが影響を受けることがありますので注意してください。</p>


<h2>パラレルモード</h2>
<p>パラレルモードでpgpool-IIが動作している場合、クラスタ全体のデータが一貫性のある状態で
バックアップを取得するには、アプリケーション、またはpgpool-IIの一時的な停止が必要になります。</p>

<p>論理バックアップを利用する場合は、アプリケーション、またはpgpool-IIを停止し、
すべてのノードでpg_dump, pg_dumpallコマンドを実行します。
そして、すべてのノードでダンプが終了したら、アプリケーション、またはpgpool-IIを起動してください。</p>

<p>PITRを利用する場合は、まず各ノードのシステムの時刻がほぼ一致していることを確認してください。
そして、事前に各ノードでアーカイブログの設定を行い、ベースバックアップを取得します。
各ノードを個別にリストアできる状態になったら、アプリケーション、またはpgpool-IIを一時的に停止します。
停止後、その時刻と次に起動した時刻を記録します。
この一時的な停止によって、クラスタ全体のデータが一貫性のある状態を保った期間ができます。
ベースバックアップとアーカイブログを使用して各ノードをリストアする場合は、
一時停止期間の真ん中あたりの時刻をrecovery.confのrecovery_target_timeに指定したうえで、
リカバリを行ってください。</p>


<h2>システムDBのバックアップ</h2>
<p>パラレルクエリモード、またはクエリキャッシュを使用している場合は、システムDBもバックアップする必要があります。
pgpool.confのsystem_db_dbnameに設定したデータベースをバックアップしてください。</p>



<h1><a name="deploy"></a>pgpool-IIの配置について</a></h1>
<p>pgpool-IIは、独立したサーバに配置することもできますし、アプリケーションサーバと同居させることもできますし、
その他の配置も考えられます。
ここではそれぞれの配置方法を紹介し、それぞれの特徴、メリット、デメリットを検討します。</p>

<dl>
<dt>専用のサーバに配置</dt>
<dd>
    <p>pgpool-IIを物理的に独立した専用のサーバに配置する方法です。
    分かりやすい方法ですし、他のサーバソフトウェアの影響を受けないので
    pgpool-IIをもっとも安全に運営できますが、サーバ装置を1台余計に増やす必要があるのが欠点です。
    また、そのサーバが単一障害点になります(pgpool-IIが単一障害点になることを回避するには、
    後述のpgpool-HAを併用します)。</p>
</dd>

<dt>Webサーバやアプリケーションサーバと同居</dt>
<dd>
    <p>Apache、JBoss、TomcatなどのWebサーバやアプリケーションサーバが稼働しているサーバに
    pgpool-IIを同居させる方法です。
    この方法では、Webサーバやアプリケーションサーバとpgpool-IIの通信がローカルマシン内になるので、
    ソケット通信がマシン間で通信するよりも高速になるメリットがあります。
    また、複数のWebサーバ／アプリケーションサーバがあれば、自然と単一障害点を回避できるようになります。
    (この場合、複数のpgpool-IIの設定は同じにしてください)。
    なお、複数のpgpool-IIが動作しているケースでは以下の点に注意してください。</p>

    <ul>
    <li>pgpool-IIとDBサーバの間のネットワークが不安定だと、pgpool-IIから見てDBノード#1がダウン、
        他のpgpool-IIから見て正常、というような状態になってしまうことがあります。
        ネットワークを二重化するなどして、ネットワーク障害が起きないようにしてください。</li>
    <li>レプリケーションモードで、オンラインリカバリ実行中は、一つのpgpool-IIだけ残して
        他のpgpool-IIを落してください。
        さもないと、リカバリ後の結果に整合性がなくなる可能性があります。
        マスター／スレーブモード+Streaming Replicationモードでは、同時に複数のpgpool-IIで
        オンラインリカバリを実行しない限り、問題ありません。</li>
    </ul>
</dd>

<dt>DBサーバと同居</dt>
<dd>
    <p>PostgreSQLの稼働しているDBサバと同居させる方法です。
    この方法では、pgpool-IIが単一障害点になることがなく、余計なサーバを追加する必要もない点が優れていますが、
    アプリケーションがどのDBサーバに接続するのかを自ら判断する必要があるのが欠点です。
    この問題を解決するには、pgpool-HAと組み合わせて仮想IPを利用します。</p>
</dd>
</dl>


<h2>pgpool-HAについて</h2>
<p>pgpool-HAは、heartbeatなどを利用してpgpool-IIを二重化し、pgpool-II自体の可用性を上げるソフトウェアです。
pgpool-IIと同様、pgpoolプロジェクトのサブプロジェクトであり、pgpoolの開発サイトでOSSとして公開されています。</p>




<h1><a name="troubleshooting"></a>トラブルシューティング</h1>
<p>この章では、pgpool-IIを運用中に直面しやすい障害と、その対策方法をケース別に説明します。</p>

<dl>
<dt>health check failed
<dd>
    <p>ヘルスチェックでpgpool-IIがDBノードの障害を検出しました。</p>
<pre>
2010-07-23 16:42:57 ERROR: pid 20031: health check failed. 1 th host foo at port 5432 is down
2010-07-23 16:42:57 LOG:   pid 20031: set 1 th backend down status
2010-07-23 16:42:57 LOG:   pid 20031: starting degeneration. shutdown host foot(5432)
2010-07-23 16:42:58 LOG:   pid 20031: failover_handler: set new master node: 0
2010-07-23 16:42:58 LOG:   pid 20031: failover done. shutdown host foo(5432)
</pre>
    <p>このログは、DBノード1(ホスト名 foo)がダウンして切り離され、
    新しくDBノード0がマスタとして扱われ出したことを示しています。
    DBノード1をチェックし、異常原因を取り除いた後に、可能であればオンラインリカバリ機能を使って
    DBノード1を復帰させてください。</p>
</dd>

<dt>failed to read kind from frontend</dt>
<dd>
<pre>
2010-07-26 18:43:24 LOG:   pid 24161: ProcessFrontendResponse: failed to read kind from frontend. frontend abnormally exited
</pre>
    <p>pgpool-IIから見てクライアントが突然セッションを切断した際にこのようなログが残ります。
    原因としては、アプリケーションのバグ、アプリケーションが強制終了されたことや、
    ネットワークの一時的な障害が考えられます。
    このログが出ても、DBが壊れるとか一貫性がなくなるような問題は起きませんが、
    継続してこのログが出力されるようであれば、アプリケーションやネットワークの障害を
    調査することをおすすめします。</p>
</dd>

<dt>kind mismatchエラー</dt>
<dd>
    <p>レプリケーションモードで運用している場合に出ることがあるエラーです。</p>
<pre>
2010-07-22 14:18:32 ERROR: pid 9966: kind mismatch among backends. Possible last query was: "FETCH ALL FROM c;" kind details are: 0[T] 1[E: cursor "c" does not exist]
</pre>
    <p>pgpool-IIは、SQLコマンドを各DBノードに送信したら、各DBノードから同じレスポンスが返ってくることを期待します。
    このエラーは、異なるレスポンスが返ってきたことを示します。
    Possible last query was:のあとに、このエラーを返す原因となった問い合わせのSQL文が表示されます。
    そのあとで、各DBノードからのレスポンスの種類と、レスポンスがエラーの場合は、
    PostgreSQLのエラーメッセージが表示されます。
    ここでは、"0[T]"により、0番目のDBノードが"T"(行情報の開始)という応答を返したこと、
    一方"1[E"で、DBノード1がエラーを返したとこと、そのエラーメッセージは
    「cursor "c" does not exist」であったことがわかります。</p>

    <p>注意: このエラーは、マスタースレーブモードでも出ることがあります。
    たとえば、SETコマンドは、各セッションの状態を同じにするために、
    基本的にすべてのDBノードに送信されるからです。</p>

    <p>データベースを調べて原因を特定し、もしDBの同期が崩れているようであれば、
    オンラインリカバリを使って正しいデータと同期させてください。</p>
</dd>

<dt>pgpool detected difference of the number of inserted, updated or deleted tuples</dt>
<dd>
    <p>レプリケーションモードにおいて、pgpool-IIが、DBノード間でINSERT/UPDATE/DELETEが返す
    結果行の違いを検出しました。</p>
<pre>
2010-07-22 11:49:28 ERROR: pid 30710: pgpool detected difference of the number of inserted, updated or deleted tuples. Possible last query was: "update t1 set i = 1;"
2010-07-22 11:49:28 LOG:   pid 30710: ReadyForQuery: Degenerate backends: 1
2010-07-22 11:49:28 LOG:   pid 30710: ReadyForQuery: Affected tuples are: 0 1
</pre>
    <p>この例では、update t1 set i = 1によって更新された行数が、DBノードで異なっています。
    また、次の行では、DBノード1を切り離したこと、更にDBノード0での結果行数が0だったのに対して、
    DBノード1では、1行だったことを表しています。</p>
    <p>正しくないデータを持っていると思われるDBノードを停止し、オンラインリカバリを使って
    正しいデータと同期させてください。</p>
</dd>
</dl>



<h1>制限事項<a name="restriction"></a></h1>

<h2>PostgreSQLの機能</h2>
<ul>
<li>pg_terminate_backend()でバックエンドを終了させるとフェイルオーバしてしまいます。
    これは、PostgreSQLがpostmasterをシャットダウンしたときと同じメッセージをpgpoolに送るためです。
    今のところ対応方法はないので、この関数を使わないようにしてください。
</li>
</ul>

<h2><a name="md5"></a>認証・アクセス制御方式</h2>
<ul>
<li>レプリケーションモードまたマスタ/スレーブモード時にはtrust, reject, clear
    text password, pam, 認証方式だけが利用できます。
    crypt認証は利用できません。
    md5認証に関しては、PostgreSQLに該当ユーザをmd5認証付でPostgreSQLに登録し、
    次にpgpoolに付属するpg_md5コマンドを使って、pool_passwdという認証ファイルを作成することにより
    利用できるようになります。
    pool_passwdは認証ファイルのデフォルトのファイル名です。
    ファイル名はpool_passwdパラメータで変更することができます。

    <ol>
    <li>DBユーザのアカウントでログインし、"pg_md5 --md5auth パスワード" を実行します。</li>
    <li>md5により暗号化されたパスワードがpool_passwdに登録されます。
        pool_passwdがまだ存在しなければ、pgpool.confと同じディレクトリ内に作成されます。</li>
    <li>pool_passwdのフォーマットは、"ユーザ名:パスワード"となっています。</li>
    <li>pool_hba.confにmd5認証のエントリを作成します。
        pool_hba.confについては、<a href="#hba">クライアント認証(HBA)のためのpool_hba.conf設定方法</a>
        を参照してください。</li>
    <li>注意事項: pool_passwdに登録するパスワードは、PostgreSQLに登録したパスワードと
        完全に同じでなければなりません。</li>
    <li>pool_passwdとPostgreSQLのmd5パスワードを変更したら、pgpool reload を実行してください。</li>
    </ol>
</li>

<li>それ以外のモードでは、trust, reject, clear text password, pam, crypt, md5認証方式だけが利用できます。</li>
</ul>
</p>


<h2>一時テーブルの扱い</h2>
<p>制限対象:マスタースレーブモード</p>

<p>一時テーブルの作成、更新は常にマスタ(primary)で行なわれます。
一時テーブルの検索も、pgpool-II 3.0以降では、マスタで行なわれるので、
一時テーブルを使っているかどうかを意識する必要はありません。
ただし、文字列として一時テーブル名をSELECTの中で使っている場合は一時テーブルかどうかの確認のしようがないので、
負荷分散されてしまい、その一時テーブルが見つからないか、もしくは
同じ名前の別のテーブルを検索してしまうことになります。
そのような問い合わせは避けるか、/*NO LOAD BALNCE*/のコメントを挿入してください。</p>
<pre>SELECT 't1'::regclass::oid;</pre>

<p>ちなみに、psqlの\dコマンドのように、システムカタログを問い合わせる中で
文字列としてのテーブル名を使っている場合は、pgpool-II 3.0以降ではマスタで検索が行なわれるので、問題になりません。
なぜなら、システムカタログへの検索は常にマスタで行なわれるからです。</p>


<h2>レプリケーションモードで注意が必要な関数など</h2>
<p>pgpool-IIでは同じ問い合わせを送っても異なる結 果を返すようなデータ、たとえば
乱数やトランザクションID、OIDのようなものに関してはレプリケーションはしますが、
2台のホストでまったく同じ値がコピーされる保証はありません。</p>

<p>シリアル型に関しては、insert_lockを有効にしておけばテーブルロックを利用して同期が取られます。
シーケンスを扱う関数をSELECT setval()、SELECT nextval()で呼び出している場合は
自動的にレプリケーションされるので同期が取れます。</p>

<p>pgpool-II 2.3以降では、テーブルのデフォルト値での利用も含め、
CURRENT_TIMESTAMP, CURRENT_DATE, now()は、自動的にマスタ側から取得した時刻値に置き換えることによって
レプリケーションできるようになっています。ただし、以下の点に注意してください。</p>

<ul>
<li>DEFAULTにタイムスタンプを返す式が含まれているかどうかの判定は正確ではありません。例えば
<pre>
CREATE TABLE rel1(
  d1 date DEFAULT CURRENT_DATE + 1
)
</pre>
    のようなものも現在のタイムスタンプとして書き換えを行います。
    なお、列の定義が、
<pre>
foo bigint default (date_part('epoch'::text,('now'::text)::timestamp(3) with time zone) * (1000)::double precision)
</pre>
    のように、データ型が日付、時刻以外になっている場合は書き換えは行ないません。
</li>

<li>INSERT ... SELECTでは、列のDEFAULTに対する書き換えを行いません。例えば、
<pre>
CREATE TABLE rel1(
  c1 int,
  c2 timestamp default now()
)
</pre>
    の時、
<pre>INSERT INTO rel1(c1) VALUES(1)</pre>
    は
<pre>INSERT INTO rel1(c1, c2) VALUES(1, '2009-01-01 23:59:59.123456+09')</pre>
    のように書き換えられますが
<pre>INSERT INTO rel1(c1) SELECT 1</pre>
    は書き換えられません。
</li>
</ul>

<p>PostgreSQL 8.2かそれより前のPostgreSQLをお使いの場合、
CREATE TEMP TABLEで作成されたテーブルはフロントエンドがセッションを終了しても削除されません。
これは、コネクションプールの効果でバックエンドから見るとセッションが継続しているように見えるからです。
セッションの終了時に明示的にDROP TABLEするか、トランザクションブロックの中で
CREATE TEMP TABLE ... ON COMMIT DROPをお使い下さい。</p>

<p>PostgreSQL 8.3以降では、reset_query_listにDISCARD ALLを指定すれば自動的に削除されるので問題ありません。</p>


<h2>クエリについて</h2>
<p>pgpool-II では扱うことができないクエリについて説明します。</p>

<h3>マルチバイト文字について</h3>
<p>制限対象:全モード</p>
<p>現在の実装では、マルチバイト文字の変換処理を行いません。クライアントエンコーディング、
バックエンドノードのサーバエンコーディング、システムDB のサーバエンコーディングを一致させるようにしてください。</p>

<h3>マルチステートメント</h3>
<p>制限対象:全モード</p>
<p>マルチステートメント(';' で区切って複数の文をまとめた SQL)を pgpool が
正しく処理することができません。必ず文を分けて送信してください。</p>
<p>なお、psql を使って pgpool に接続した場合は、psql 内部でマルチステート
メントを分解し、1 つずつ送信するので、実際には問題になりません。</p>

<h3>拡張問い合わせプロトコル</h3>
<p>制限対象:パラレルモード</p>
<p>JDBC ドライバなどのような拡張問い合わせプロトコルには対応していません。
必ず簡易問い合わせプロトコルを使用してください。</p>

<h3>PREPARE, EXECUTE</h3>
<p>
制限対象:パラレルモード
</p>
<p>
<code>PREPARE</code> 文で生成された準備文には対応していません。
</p>


<h3>SELECT</h3>
<p>
制限対象:パラレルモード
</p>
<p>
postgresql.conf の add_missing_from 設定値を off (デフォルト値)に設定してください。
add_missing_from 設定値が on の時に使えるクエリは正しくpgpoolで処理されない可能性
があります。
</p>
<h3>INSERT</h3>
<p>
制限対象:パラレルモード
</p>
<p>
データ分割をしているテーブルに対して <code>INSERT</code> を行う際には、分割ルールとなる値を
<code>DEFAULT</code> にはできません。
例えばテーブル t のカラム x が分割ルールの対象カラムだった場合には、
</p>
<pre>
  INSERT INTO t(x) VALUES (DEFAULT);
</pre>
<p>
とはできません。また、以下の様に分割ルールとなる値が関数呼び出しの場合も
対応していません。
</p>
<pre>
  INSERT INTO t(x) VALUES (func());
</pre>
<p>
このカラムには必ず明示的に値を与える必要があります。
</p>
<p>
また、<code>SELECT INTO</code>、 <code>INSERT INTO ... SELECT</code>、および以下のような
<code>VALUES</code> を用いた複数行の挿入には対応していません。
</p>
<pre>
INSERT INTO t(x) VALUES (1),(2),(3);
</pre>

<h3>UPDATE</h3>
<p>制限対象:パラレルモード</p>
<p>分割ルールとなるカラムを更新すると分割ルールに従ったデータの整合性が崩れる可能性があります。
pgpool-II では特にデータの再配置ということは行いません。</p>

<p>もし制約違反などにより一部のノードでエラーになった場合にロールバックすることはできません。</p>

<p>WHERE 句にデータ分割を行ったテーブルを参照するサブクエリや関数呼び出しがある場合には
正しく動かない可能性があります。</p>

<pre>例：UPDATE branches set bid = 100 where bid = (select max(bid) from beances);</pre>

<h3>SELECT ... FOR UPDATE</h3>
<p>制限対象:パラレルモード</p>

<p>WHERE 句にデータ分割を行ったテーブルを参照するサブクエリや関数呼び出しがある場合には
正しく動かない可能性があります。</p>
<pre>例：SELECT * FROM  branches where bid = (select max(bid) from beances) FOR UPDATE;</pre>

<h3>COPY</h3>
<p>制限対象:パラレルモード</p>
<p>COPY BINARY には対応していません。また、ファイルからのコピーにも対応していません。
COPY FROM STDIN と COPY TO STDOUT のみ対応しています。</p>

<h3>ALTER/CREATE TABLE について</h3>
<p>制限対象:パラレルモード</p>
<p>pgpool に情報を更新させるためには、pgpool を再起動する必要があります。</p>

<h3>トランザクション</h3>
<p>制限対象:パラレルモード</p>
<p>トランザクション中に発行される SELECT は dblink を経由する場合には別トランザクションになります。
以下に例を示します。</p>
<pre>
  BEGIN;
  INSERT INTO t(a) VALUES (1);
  SELECT * FROM t ORDER BY a; &lt;-- 上の INSERT した値は見えない
  END;
</pre>
<p>また制約違反などにより一部のノードでエラーになった場合にロールバックすることはできません。</p>

<h3>View/Rule</h3>
<p>制限対象:パラレルモード</p>
<p>View や Rule は各ノードに同じ内容が定義されます。</p>
<pre>CREATE VIEW sample AS SELECT * FROM a, b where a.i = b.i</pre>

<p>上記のような テーブル結合を含んだVIEWは、a と b は同じノード内でのみ結合処理を行い、
各ノードからの実行結果を統合します。
ノードをまたがった JOIN を行う View を作成することはできません。Rule についても同様になります。
ただし、データ分割したテーブルを同じノード内でのみ結合したい場合に、VIEWを作成することは可能です。
この場合にはVIEWをpgpool_catalog.dist_defテーブルにVIEWを登録しておきます。
また、pgpool_catalog.dist_defテーブルのcol_nameとdist_def_funcには、VIEWで定義したカラムとVIEWに対して
INSERTが発行された場合に何処のノードにクエリを問い合わせるのかを決定する関数を登録してください。</p>

<h3>関数/トリガについて</h3>
<p>制限対象:パラレルモード</p>
<p>関数は各ノードに同じ内容が定義されます。関数内で JOIN や他のノードのデータ操作を行うことはできません。</p>

<h3>Natural Join について</h3>
<p>制限対象:パラレルモード</p>
<p>Natural Join は利用できません。ON 結合条件または、USING(結合カラム) を明示的に指定する必要があります。</p>

<h3>USING 句について</h3>
<p>制限対象:パラレルモード</p>
<p>JOIN 構文の中で利用される USING 句はクエリの書き換え処理によって ON 句に変換されます。
そのため、ターゲットリストに "*" を利用する問い合わせを行う場合には、同じ列名が出力されます。</p>

<h3>デッドロックについて</h3>
<p>制限対象:パラレルモード</p>
<p>ノード間をまたがるデッドロックを検出することができません。</p>
<pre>
例：accountsテーブルは以下のルールで分割されている。
    aid &lt;= 100000 ノード 0
    aid &gt;= 100000 ノード 1

  A) BEGIN;
  B) BEGIN;
  A) SELECT * FROM accounts WHERE aid = 100001 FOR UPDATE;
  B) SELECT * FROM accounts WHERE aid = 100000 FOR UPDATE;
  A) SELECT * FROM accounts WHERE aid = 100000 FOR UPDATE;
  B) SELECT * FROM accounts WHERE aid = 100001 FOR UPDATE;
</pre>
<p>この場合、単一のノードではデッドロックを検知できないため、pgpool は待たされた状態になります。
この現象は SELECT FOR UPDATE 以外にも行ロックを獲得するクエリで発生する可能性があります。</p>
<p>また、あるノードでデッドロックが発生した場合は、各ノードのトランザクションの状態が異なる状況になります。
そのため、デッドロックを検知した時点で以下のログを出力して pgpool は該当のプロセスを終了させます。
<pre>
  pool_read_kind: kind does not match between master(84) slot[1] (69)
</pre>

<h3>スキーマについて</h3>
<p>制限対象:パラレルモード</p>
<p>public 以外のスキーマに属すようなオブジェクトの参照は必ず</p>
<pre>スキーマ.オブジェクト</pre>
<p>と指定するようにしてください。</p>
<pre>set search_path = xxx</pre>
<p>を指定し、スキーマ名を省略すると、pgpool がどの分散ルールを適用するか判断できません。</p>

<h3>テーブル名、カラム名について</h3>
<p>制限対象:パラレルモード</p>
<p>pool_で始まるテーブル、カラム名は使えません。クエリ書き換えの際に内部処理で使用します。</p>


<h2>システム DB</h2>

<h3>分割ルール</h3>
<p>pgpool-II では分割ルールの対象のカラムは 1 つのみとします。
x と y のOR 条件などといったものには対応していません。</p>


<h2>ビルドに必要な環境</h2>

<h3>libpq</h3>
<p>pgpool-II では libpq をリンクします。libpq のバージョンは 2.0 の場合、configure に失敗します。
必ず libpq 3.0 以降(PostgreSQL 7.4以降) をリンクするようにしてください。
また、SystemDB のバージョンも PostgreSQL 7.4 以降が必須になります。</p>


<h2>クエリキャッシュ</h2>
<p>現在のクエリキャッシュの実装では、キャッシュの無効化を手動で行う必要があります。</p>



<h1>リファレンス<a name="reference"></a></h1>
<h2>PCPコマンドリファレンス</h2>

<h3>PCPコマンド一覧</h3>
<p>pgpool-IIを操作するUNIXコマンドとして、以下のものがあります。</p>

<pre>
   * pcp_node_count    - ノード数を取得する
   * pcp_node_info    - ノード情報を取得する
   * pcp_proc_count    - プロセス一覧を取得する
   * pcp_proc_info    - プロセス情報を取得する
   * pcp_systemdb_info    - システムDB情報を取得する
   * pcp_detach_node    - ノードを切り離す
   * pcp_attach_node    - ノードを復帰させる
   * pcp_stop_pgpool    - pgpool-IIを停止させる
   * pcp_recovery_node  - マスタノードを使ってノードのデータを再同期、ノード起動させる
</pre>


<h2>共通引数</h2>
<p>全てのコマンドには共通する引数があります。これは接続するpgpool-IIの情報や認証情報などです。</p>
<pre>
   ex)
   $ pcp_node_count [-d] 10 localhost 9898 postgres hogehoge

    第一引数    - タイムアウト値
        秒数でタイムアウト値を指定します。この時間内にpgpool-IIから応
        答がない場合はコネクションを切断して終了します。なお、
        このオプションは 2.1 からは無視するようになっています。
    第二引数    - pgpool-IIが稼動しているホスト名
    第三引数    - PCPポート番号
    第四引数    - PCPユーザ名
    第五引数    - PCPパスワード

    オプション引数として、-dがあります。-dが指定されるとデバッグ情報を出力します。
</pre>

<p>PCPユーザ名とパスワードは ./configure 時に --prefix で指定した
'インストールディレクトリ/etc' にある pcp.conf 内に記述されているものを指定します。
pcp.conf ファイルの場所がデフォルト以外の場所にある場合、
pgpool の-F オプションでその位置を指定することができます。
パスワードはコマンドに渡す時点でmd5化されている必要はありません。
</p>


<h2>コマンド群</h2>
<p>全てのコマンドは、実行した結果が標準出力に表示されます。</p>


<h3>pcp_node_count</h3>
<pre>
   書式：
    pcp_node_count  _timeout_  _host_  _port_  _userid_  _passwd_
</pre>
<p>pgpool-IIの pgpool.conf で定義されたノードの総数を表示します。切り離されているノードの区別はしません。</p>


<h3><a name="pcp_node_info"></a>pcp_node_info</h3>
<pre>
   書式：
    pcp_node_info  _timeout_  _host_  _port_  _userid_  _passwd_  _nodeid_
</pre>
<p>pgpool-IIの pgpool.conf で定義されたノードの情報を表示します。出力結果は以下の例の通りです。</p>

<pre>
   ex)
   $ pcp_node_info 10 localhost 9898 postgres hogehoge 0
   host1 5432 1 1073741823.500000

   結果は以下の順の通りです。
   1. ノードのホスト名
   2. ノードのポート番号
   3. ステータス
   4. ロードバランスウェイト

   ステータスは[0..3]までの数字で表わされます。各数字の意味は：
   0 - 初期化時のみに表われる。PCPコマンドで表示されることはない。
   1 - ノード稼働中。接続無し
   2 - ノード稼働中。接続有り
   3 - ノードダウン
</pre>

<p>ロードバランスウェイトはNormalizeされたフォーマットで出力されます。</p>
<p>定義されていないノードIDを指定するとBackendErrorと表示され、終了コード12で終了します。</p>


<h3>pcp_proc_count</h3>
<pre>
   書式：
    pcp_proc_count  _timeout_  _host_  _port_  _userid_  _passwd_
</pre>
<p>pgpool-IIの子プロセスのプロセスIDを一覧表示します。複数ある場合は空白文字で区切られます。</p>


<h3>pcp_proc_info</h3>
<pre>
   書式：
    pcp_proc_info  _timeout_  _host_  _port_  _userid_  _passwd_  _processid_
</pre>
<p>pgpool-IIの子プロセス情報を表示します。出力結果は以下の例の通りです。</p>

<pre>
   ex)
   $ pcp_proc_info 10 localhost 9898 postgres hogehoge 3815
   postgres_db postgres 1150769932 1150767351 3 0 1 14067 1
   postgres_db postgres 1150769932 1150767351 3 0 1 14068 1

   結果は以下の順の通りです。
   1. 接続しているデータベース名
   2. 接続しているユーザ名
   3. プロセススタート時刻
   4. コネクション作成時刻
   5. プロトコルメジャーバージョン
   6. プロトコルマイナーバージョン
   7. コネクション使用回数
   8. PostgreSQLバックエンドプロセスID
   9. フロントエンドから接続がある場合は1、そうでなければ0

   コネクションがバックエンドに対して張られていない場合、データは表示されません。
   コネクション情報が複数ある場合、複数行に1行1コネクション情報で表示されます。
   時刻はEPOCHタイムからの秒数で表わされます。

   定義されていないプロセスIDを指定するとBackendErrorと表示され、終了コード12で
   終了します。
</pre>


<h3>pcp_systemdb_info</h3>
<pre>
   書式：
    pcp_systemdb_info  _timeout_  _host_  _port_  _userid_  _passwd_

   pgpool-IIのシステムDB情報を表示します。出力結果は以下の通りです。

   $ pcp_systemdb_info 10 localhost 9898 postgres hogehoge
   localhost 5432 yamaguti '' pgpool_catalog pgpool 3
   yamaguti public accounts aid 4 aid bid abalance filler integer integer integer character(84) dist_def_accounts
   yamaguti public branches bid 3 bid bbalance filler integer integer character(84) dist_def_branches
   yamaguti public tellers bid 4 tid bid tbalance filler integer integer integer character(84) dist_def_tellers

   まず一行目にシステムDBの情報が表示されます。結果は以下の順の通りです。

   1. ホスト名
   2. ポート番号
   3. ユーザ名
   4. パスワード。空の場合は''で表示されます。
   5. スキーマ名
   6. データベース名
   7. 分散定義関数の数

   二行目以降は分散定義が表示されます。複数の定義がある場合は、一つの定義につき
   一行表示されます。結果は以下の順の通りです。

   1. 分散対象のデータベース名
   2. 分散対象のスキーマ名
   3. 分散対象のテーブル名
   4. 分散キーカラム名
   5. 分散対象テーブル中のカラム数
   6. カラム名リスト(5.のカラム数分表示されます)
   7. カラム型リスト(5.のカラム数分表示されます)
   8. 分散定義関数名

   システムDBが定義されていない(pgpool-IIモードでない、かつクエリキャッシュがオ
   フの)場合に実行すると、BackendErrorと表示され、終了コード12で終了します。
</pre>


<h3>pcp_detach_node</h3>
<pre>
   書式：
    pcp_detach_node  [-g] _timeout_  _host_  _port_  _userid_  _passwd_  _nodeid_

   pgpool-IIのノードを切り離します。
   すでにpgpool-IIに接続しているセッションは強制的に切断されます。
-gを指定すると、すべてのクライアントが接続を終了するまでノードを復帰しません。
(ただし、client_idle_limit_in_recovery が -1 あるいは、recovery_timeout が設定されている場合を除く)
</pre>


<h3>pcp_attach_node</h3>
<pre>
   書式：
    pcp_attach_node  _timeout_  _host_  _port_  _userid_  _passwd_  _nodeid_

   pgpool-IIのノードを復帰させます。
</pre>

<h3>pcp_stop_pgpool</h3>
<pre>
   書式：
    pcp_stop_pgpool  _timeout_  _host_  _port_  _userid_  _passwd_  _mode_

   pgpool-IIを指定されたモードでシャットダウンします。指定できるモードは以下の通
   りです。

   s    - smart モード
   f    - fast モード
   i    - immediate モード

   pgpool-IIが起動していない場合はConnectionErrorと表示され、終了コード8で終了し
   ます。

   ※ 現在は fast モードと immediate シャットダウンの処理に区別はあり
      ません。命令を送った時点でクライアントがいる・いないに関わらず
      シャットダウン処理を即座に行います。
</pre>

<h3>pcp_recovery_node</h3>
<pre>
   書式：
    pcp_recovery_node  _timeout_  _host_  _port_  _userid_  _passwd_  _nodeid_

   pgpool-IIのノードをデータを再同期させた上で復帰させます。
</pre>


<h2>終了ステータス</h2>
<p>PCPコマンドは正常に処理を終了した場合、ステータス'0'で終了します。
エラーが起きた場合は以下のステータスにより終了します。</p>

<pre>
   UNKNOWNERR    1    不明なエラー
   EOFERR    2    EOFエラー
   NOMEMERR    3    メモリ不足
   READERR    4    サーバからのデータ読み込みエラー
   WRITEERR    5    サーバへのデータ書き込みエラー
   TIMEOUTERR    6    タイムアウト
   INVALERR    7    PCPコマンドへの不正なオプション
   CONNERR    8    サーバ接続エラー
   NOCONNERR    9    接続が存在しない
   SOCKERR    10    ソケットエラー
   HOSTERR    11    ホスト名解決エラー
   BACKENDERR    12    サーバでのPCP処理エラー。存在しないプロセスIDの情報を取
            得しようとした場合など
   AUTHERR    13    認証エラー
</pre>



<h1>内部情報<a name="internal"></a></h1>
<p>pgpool-IIバージョン 2.0 以降では、1.x バージョンと比べ大幅な改良が加えられています。
1.x バージョンの情報とは互換性がないので注意してください。</p>


<h2>パラレル実行エンジン</h2>
<p>pgpool-IIにはパラレル実行エンジンが組み込まれています。</p>
<p>このエンジンは、パラレルモードのときに、各ノードに同じクエリを問い合わせ、
ノードの応答順に結果をフロントエンドに送信するエンジンのことを指します。</p>


<h2>クエリ書き換え</h2>
<p>パラレルモードでpgpool-IIが行うクエリ書き換えについて説明します。</p>
<p>パラレルモードでは、クライアントが送信した検索系(SELECT処理)の問い合わせは、
大きく分けて以下の 2 つの処理を行います。</p>
<ol>
  <li>クエリの解析
  <li>クエリの書き換え
</ol>

<p>これら２つの処理について順に説明致します。</p>

<h3>クエリの解析</h3>
<h4>はじめに</h4>
<p>クライアントが送信した検索系の問い合わせは、SQLパーサを通してからシステムDBに登録されている
情報をもとにクエリ解析を行います。
クエリの解析には実行ステータスの遷移で評価しています。
ここで実行ステータスというのは、あるデータの集合が何処で取得または処理できるのか判断するものです。
例えば、pgpool_catalog.dist_defテーブルに登録されているテーブルのデータ集合全体は、
データが分割されているのですべてのノードから取得する必要があります。
逆に、pgpool_catalog.replicate_defテーブルに登録されているテーブルのデータ集合全体は、
すべてのノードから取得するのではなく、いずれかのノードから取得すれば十分です。
ここですべてのノードで処理する必要がある状態を P 状態、
一つのノードで処理する必要がある状態を L 状態として定義します。
もう一つ、特別な状態として S 状態があります。
これは、すべてのノードから取得した全データに対して処理を行ったときの状態のことを示します。
例えば、ソート処理です。pgpool_catalog.dist_defテーブルに登録されている
テーブルのデータに対するソート処理は、すべてのノードからデータを取得した後に実行する必要があります。</p>

<p>検索系クエリは、以下の処理順に解析され、実行ステータスが遷移していきます。
実行ステータスが遷移していく過程で S 状態となると、以降の処理は必ず S 状態となります。
そして最後のSELECTの最終実行ステータスの状態により、何処のDBで処理されるかが決定します。</p>

<ol>
  <li> UNION、EXTRACT、INTERCECTが利用されているかどうか</li>
  <li> FROM 句の実行ステータス</li>
  <li> TARGETLIST による実行ステータスの変化</li>
  <li> WHERE 句 にる実行ステータスの変化</li>
  <li> GROUP BY 句による実行ステータスの変化</li>
  <li> HAVING 句による実行ステータスの変化</li>
  <li> ORDER BY 句による実行ステータスの変化</li>
  <li> LIMIT OFFSET 述語に実行ステータスの変化</li>
  <li> SELECTの最終実行ステータスの取得</li>
</ol>

<p>SELECTの最終実行ステータスと処理される場所との関係は、以下の通りです。</p>

<p>
<table border>
<tr><td>実行ステータス</td><td>処理される場所</td></tr>
<tr><td align = center>L</td><td>いずれかのノードに問い合わせを行う</td></tr>
<tr><td align = center>P</td><td>すべてのノード同じ問い合わせを行い、パラレル実行エンジンを通してクライアントに返却</td></tr>
<tr><td align = center>S</td><td>システムDBで処理を行った後にクライアントに返却</td></tr>
</td></tr>
</table>
</p>

<p>またサブクエリに対しても上記のルールが適応されます。
以下の単純なクエリでは、p1-tableがシステムDBのpgpool_catalog.dist_defテーブルに登録されている場合、
つまりデータの分割が行われている場合には、サブクエリの最終実行ステータスが P となり、
その結果サブクエリの呼び出し元である SELECT の実行ステータスも P となります。</p>
<pre>SELECT * FROM (SELECT * FROM P1-table) as P2-table;</pre>

<p>次に具体的に実行ステータスがどのように遷移するのか説明します。
まず2. From句の実行ステータス から説明します。</p>

<h4>FROM 句の実行ステータス</h4>
<p>検索系クエリ(SELECT)は FROM 句によりデータの集合を定義します。
FROM句から構成せれるデータ集合は P 状態, L 状態、または S 状態を取ります。
FROM句に指定しているテーブルが一つの場合には、単純にテーブルの実行ステータスが
FROM句から構成されるデータ集合全体の実行ステータスとなります。
FROM句に複数のテーブル、又はサブクエリがある場合
には、結合方法によって以下のように実行ステータスが決定します。</p>

<p>
<table border>
<tr><td>結合方式</td><td align = center colspan = 3> LEFT OUTER JOIN </td><td align = center colspan = 3> RIGHT OUTER JOIN </td><td align = center colspan = 3>FULL OUTER JOIN</td><td align = center colspan = 3>　　　その他　　　</td></tr>
<tr><td align = center>左＼右</td><td> P </td><td> L </td><td> S </td><td> P </td><td> L </td><td> S </td><td> P </td><td> L </td><td> S </td><td> P </td><td> L </td><td> S </td></tr>
<tr><td align = center> P </td><td> S </td><td> P </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> P </td><td> S </td></tr>
<tr><td align = center> L </td><td> S </td><td> L </td><td> S </td><td> P </td><td> L </td><td> S </td><td> S </td><td> L </td><td> S </td><td> P </td><td> L </td><td> S </td></tr>
<tr><td align = center> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td><td> S </td></tr>
</td></tr>
</table>
</p>

<p>以下の例では、P1-tableが P 状態のテーブルでL1-table,L2-tableが L 状態のテーブルだとします。
すると上記の表により、P1-table (左)とL1-table (右) が結合し P 状態となり、さらに P 状態と L 状態のL2-tableが結合してFROM句の実行ステータスは P 状態となります。</p>
<pre>SELECT * FROM P1-table,L1-table,L2-table;</pre>
</p>

<h4>TARGETLIST と WHERE句の実行ステータス</h4>

<p>基本的なクエリでは、FROM 句と同じ実行ステータスを継承します。
しかし、TARGETLIST と WHERE句の実行ステータスは、以下の場合に変化します。</p>
<ol>
  <li> サブクエリがある場合
  <li> FROM句が P 状態の場合、かつ、TARGETLISTに集約関数、DISTINCTがある場合
  <li> FROM句で定義したテーブル(データ集合)に存在しないカラムが使われている場合
</ol>

<p>サブクエリの最終実行ステータスが P 状態、または、S 状態の場合には、
TARGETLIST、WHERE句の実行ステータスは、S 状態となります。
下記の例では、サブクエリで使われているテーブルが、P 状態の場合には、
サブクエリの最終実行ステータスはP 状態となります。
そのため L1-tableの実行ステータスに依存せずに、WHERE句の実行ステータスは S状態となり、
このクエリの実行場所はシステムDBとなります。</p>
<pre>SELECT * FROM L1-table where L1-table.column IN (SELECT * FROM P1-table);</pre>

<p>FROM 句が P 状態の場合、かつ、TARGETLISTに集約関数がある場合は、
データを取得後に集計する必要があるため、S状態に遷移します。
また、特定の条件の下では、集約関数による最適化が行われます。</p>

<p>FROM句で定義したテーブル、サブクエリには存在しないカラムがWHERE句に使われている場合があります。
これは以下のような相関サブクエリ内で発生します。</p>
<pre>
SELECT * FROM L1-table FROM L1-table.col1 IN (SELECT * FROM P1-table WHERE P1-table.col = L1-table.col1);
</pre>
<p>上記のサブクエリに使われている L1-table.col1は、L1-tableを外部参照しています。
この場合にサブクエリのWHERE句の実行ステータスは S 状態となります。</p>


<h4>GROUP BY 句、HAVING 句、ORDER BY 句、LIMIT OFFSET 述語の実行ステータス</h4>

<p>WHERE句の実行ステータスが P 状態の場合に、GROUP BY , HAVING 句、ORDER BY 句、
LIMIT OFFSET 述語があるとS状態に遷移します。
GROUP BY句が存在しないクエリはWHERE句の実行ステータスを継承します。
また、HAVING句が無い場合にはGROUP BY 句の実行ステータスを継承します。
ORDER BY 句、LIMIT OFFSET 述語も同様です。</p>

<p>UNION、EXTRACT、INTERSECTが使われている場合</p>

<p>UNION、EXTRAT、INTERSECTが使っているクエリは左側のSELECT文と右側のSELECT文の最終実行ステータスに依存します。
左側と右側のSELECT文の最終実行ステータスが共に L 状態の時には、L 状態となります。
また、左側と右側のSELECT文の最終実行ステータスが共に P 状態、かつUNION ALLの場合には P 状態となります。
その他の組み合わせの場合には、S状態となります。</p>

<h4>SELECTの最終実行ステータスの取得</h4>

<p>実行ステータスがすべて L 状態の場合にはL状態、すべて P 状態の場合には、P 状態となります。
それ以外は、S 状態となります。
L 状態の場合には、pgpool.confのloadbalance_modeがtrueの場合には負荷分散され、
それ以外の場合にはMASTERに問い合わせを行います。
また、P 状態の場合には、パラレル実行エンジンを使って並列処理が行われます。
S 状態の場合には、次のフェーズであるクエリ書き換えを行います。</p>

<h3>クエリ書き換え</h3>

<p>クエリの解析フェーズで取得した実行ステータスを使ってクエリの書き換えを行います。
例として P 状態の P1-table と L 状態の L1-table を使ったクエリで説明します。</p>
<pre>
SELECT P1-table.col, L1-table.col FROM P1-table,L1-table where P1-table.col = L1-table.col order by P1-table.col;
</pre>

<p>このクエリでは ORDER BY 句があるため S 状態となり、FROM句、WHERE句、TARGETLISTは P 状態となります。
このようなクエリでは以下のように書き換えられます。</p>
<pre>
    SELECT P1-table.col, L1-table.col FROM
    　　　dblink(select pool_parallel(SELECT P1-table.col, L1-table.col FROM P1-table,L1-table where P1-table.col = L1-table.col))
      order by P1-table.col;
</pre>

<p>ここでdblinkはpgpool-IIに問い合わせを送信します。
また、pool_parallelは引数のクエリをパラレル実行エンジンをにわたす関数です。
なお、上記はあくまでイメージであり実際に実行可能なクエリではありません。</p>

<p>上記の例のように、FROM句、WHERE句、TARGETLISTがすべて P 状態の場合には、
FROM句、WHERE句、TARGETLISTをまとめて並列処理を行います。</p>

<p>次の例を見てみます。</p>
<pre>
SELECT L1-table.col FROM L1-table WHERE L1-table.col % 2 = 0 AND L1-table.col IN (SELECT P1-table FROM P1-table) ;
</pre>

<p>この例では、FROM 句は L 状態、TARGETLISTも L 状態、WHERE句は P 状態のサブクエリを持っているため
S 状態となります。
これは以下のように書き換えが行われます。</p>
<pre>
    SELECT L1-table.col FROM dblink(SELECT loadbalance(SELECT L1-table.col FROM L1-table WHERE L1-table.col % 2 = 0 AND TRUE))
        WHERE
            L1-table.col %2 = 0 AND
          L1-table.col IN
          (
              SELECT P1-Table FROM
              dblink(select pool_parallel(SELECT P1-table FROM P1-table))
          ) ;
</pre>
<p>ここで、pool_loadbalanceはクエリをいずれかのノードに送信する関数です。</p>

<h4>集約によるクエリ書き換え</h4>

<p>集計を行うクエリ(集約関数、GROUP BY )は各ノードに計算させ、システムDBで再集計を行うことにより、
システムDBの負荷を減らしパフォーマンスも向上します。</p>
<p>まず、最初にpgpool-IIが実際に行うクエリの書き換えを見てみます。</p>
<p>FROM 句が P 状態で count(*) を使ったクエリは、以下のように書き換えが行われます。</p>

<pre>
    select count(*) from P1-table;

    -&gt; クエリ書き換え

    SELECT
        sum(pool_c$1) as count
    FROM
        dblink(select pool_parallel('select count(*) from  P1-table'))
                    AS pool_$1g (pool_c$1 bigint);
</pre>

<p>各ノードでcount(*) を計算した後に、システムDBで集計(sum)をすることにより、目的が達成できます。</p>

<p>上記のようなクエリ書き換えが行われる条件は以下の場合です。</p>
<ol>
  <li>FROM 句がP 状態
  <li>ターゲットリストに集約関数(count, sum, min, max,avgのみ対応),GROUP BYに指定したカラムが使われている
  <li>WHERE 句がP 状態
  <li>HAVING 句 に使われている集約関数(count, sum, min, max,avgのみ対応),FROM句で定義されているカラム,GROUP BYに指定したカラムのみ使われている。
</ol>
<pre>
  例)
     select P1-table.col,L1-table.col,count(*),avg(P1-table.col) from P1-table,L1-table wehre P1-table.col %2 = 0 group by P1-table.col,L1-table.coli having count(*) < 100
</pre>

<h3>パラレルモードの注意事項</h3>
<p>パラレルモードでは、クエリの解析の際にカラム名とタイプが必要になります。
そのため、サブクエリのTARGETLISTに式、関数を使っている場合には別名と型名をキャストでつける必要があります。
式、関数に型のキャストがない場合には、text型として処理されますので注意してください。
なお、集約関数の場合でかつ集約によるクエリ書き換えが行われる場合には、countはbigint型、sumはnumeric型となります。
min,maxの場合には、引数が日付型の場合には日付型として計算され、それ以外はnumericとして計算されます。
avgはsum/countとして処理されます。</p>

<h3>パラレルモードのパフォーマンスについて</h3>

<p>SELECTの最終実行ステータスとパフォーマンスのおおよその目安は以下のとおりです。</p>
<table border>
<tr><td>実行ステータス</td><td>パフォーマンス</td></tr>
<tr><td align = center>L</td><td>パラレルクエリを利用しないのでpgpool-IIのオーバーヘッドを除き、単体ノードとの性能劣化はない</td></tr>
<tr><td align = center>P</td><td>並列処理を行うので高速、特にシーケンシャルスキャンの場合には効果がでる。また、データを分割することでテーブルサイズ(/1台)が小さくなることによりキャッシュに乗りやすくなる </td></tr>
<tr><td align = center>S</td><td>集約によるクエリ書き換えが行われると高速</td></tr>
</td></tr>
</table>


<h1>チュートリアル</h1>
<p>pgpool-IIのチュートリアルは<a href="tutorial-ja.html">ここ</a>にあります。是非ご覧下さい。</p>


<h1>リリースノート<a name="release"></a></h1>

<!-- ================================================================================ -->
<!-- 3.0                                                                              -->
<!-- ================================================================================ -->

<!-- -------------------------------------------------------------------------------- -->
<h2><a name="release3.0.19"></a>3.0.19 (umiyameboshi) 2015/07/24</h2>
<!-- -------------------------------------------------------------------------------- -->

<h3>概要</h3>
<p>
このバージョンは 3.0.18 に対するバグ修正リリースです。
</p>

<h3>バグ修正</h3>
<ul>

<li>
    pgpool-recovery の "cannot find xlog functions" エラーを修正しました。(Muhammad Usama)
    <p>
    PostgreSQL 9.4 より、PostgreSQL の pg_xlogfile_name() 関数の引数型はtext からpg_lsn に変更されていますが、pgpool-recovery は依然として古いシグネチャで関数を配置しようとしていました。
    </p>
</li>

<li>
    拡張問い合わせクエリで、レプリケーションモード以外の場合には、insertlock をチェックするクエリを送信しないようになりました。(Tatsuo Ishii)
</li>

</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2><a name="release3.0.18"></a>3.0.18 (umiyameboshi) 2015/04/08</h2>
<!-- -------------------------------------------------------------------------------- -->

<h3>概要</h3>
<p>
このバージョンは 3.0.17 に対するバグ修正リリースです。
</p>

<h3>バグ修正</h3>
<ul>

<li>
    POOLCONFIG_MAXDESCLEN を 80 まで増やしました (Tatsuo Ishii)
    <p>
    これは show pool_status コマンドでパラメータの説明文の長さ制限に使われていますが、recovery_timetout ではこれが 64 文字であり、以前のマクロ定義では 1 文字分不足していました。
    </p>
</li>

<li>
    フロントエンド接続の証明書ファイルで SSL 証明書チェーンに対応しました。(Muhammad Usama)
</li>

<li>
    pcp_detach_node が graceful にノードを切り離す際の問題を修正しました。(Muhammad Usama)
    <p>
    graceful なノード切り離しでは、そのノードの切り離し処理が許されているかの判断を、pcp_detach_node は新しい接続のブロックと既存の接続の切断よりも前に行う必要があります。
    </p>
</li>

</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2><a name="release3.0.17"></a>3.0.17 (umiyameboshi) 2015/02/05</h2>
<!-- -------------------------------------------------------------------------------- -->

<h3>概要</h3>
<p>
このバージョンは 3.0.16 に対するバグ修正リリースです。
</p>

<h3>バグ修正</h3>
<ul>

<li>
    doc: スレーブノードの数は１である必要でないことを明記しました。(Tatsuo Ishii)
</li>

<li>
    未初期化の変数があったのを修正しました。(Tatsuo Ishii)
    <p>
    Coverity の報告 #1234603 によります。
    </p>
</li>

<li>
    doc: 前回のリリースで抜け落ちていたリリースノートを追記しました。(Tatsuo Ishii)
</li>

<li>
    trigger_failover_command() 関数のノード ID 範囲検査のバグを修正しました。(Tatsuo Ishii)
    <p>
    ノード ID は定数 NUM_BACKENDS 未満である必要があります。実際にはNUM_BACKENDS 以上の値はこの関数に渡されていなかったので、おそらく害はありませんでした。
    </p>
</li>

<li>
    設定ファイルのリロードにより debug モードを無効にできるよう修正しました。(Yugo Nagata)
    <blockquote>
    bug #114 の報告によります。<br />
    <a href="http://www.pgpool.net/mantisbt/view.php?id=114">
    http://www.pgpool.net/mantisbt/view.php?id=114
    </a>
    </blockquote>
</li>


</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2><a name="release3.0.16"></a>3.0.16 (umiyameboshi) 2014/09/05</h2>
<!-- -------------------------------------------------------------------------------- -->

<h3>概要</h3>
<p>
このバージョンは 3.0.15 に対するバグ修正リリースです。
</p>

<h3>バグ修正</h3>
<ul>

<li>
    pgpool.spec のタイポを修正しました。(Yugo Nagata)
</li>

<li>
    プライマリバックエンドが存在しない場合に、ワーカー子プロセスが終了と再起動を繰り返すバグを修正しました。(Tatsuo Ishii)
    <p>
    問題の同定と修正は Junegunn Choi さんの貢献によります。
    </p>
    <p>
    詳しくは、[pgpool-hackers: 471] を参照してください。
    </p>
</li>

<li>
    スマートシャットダウンの実行時には受信用ソケットを閉じるように修正しました。(Tatsuo Ishii)
    <p>
    スマートシャットダウンが実行された場合でも、pgpool の子プロセスは受信用のポートを開いており、最終的に失敗するにもかからわずクライアントは接続要求を送信可能です。これは時間の無駄であるだけではなく、pgpool のフロントにいるロードバランサによる pgpool の停止の検出を妨げます。
    </p>
    <p>
    この問題は [pgpool-hackers 474] にて Junegunn Choi によって解析され、パッチが提供されました。これを Tatsuo Ishii が改良し、inet ドメインだけではなく UNIX ドメインのソケットにも対応させました。
    </p>
</li>

<li>
    doc: PostgreSQL の statement_timeout によって、リカバリコマンドが終了させられる可能性を追記しました。(Tatsuo Ishii)
</li>

<li>
    dic: 現在は当てはまらない古い制限事項を削除しました。(Tatsuo Ishii)
</li>

<li>
    text_to_lsn() 関数の返却値型を修正しました。(Yugo Nagata)
    <p>
    コンパイル時の警告の原因となっていました。
    </p>
</li>

<li>
    デーモン化した際にファイル識別子が閉じられていなかったのを修正しました。(Tatsuo Ishii)
    <p>
    Coverity の報告 #1111471 によります。
    </p>
</li>

<li>
    メモリリークを修正しました。 (Tatsuo Ishii)
    <p>
    Coverity の報告 #1111442 によります。
    </p>
</li>

<li>
    長らく放置されていた pgool.init の stop/restart のバグを修正しました。(Yugo Nagata)
    <p>
    以前は pgpool の停止に pgpool.init は killproc を用いていましたが、これにはいくつか問題がありました。これを、"pgpool -m fast stop" を用いるように修正しました。
    </p>
    <p>
    Ryan DeShone により提供されたパッチを Yugo Nagata が修正しました。
    </p>
    <p>
    詳しくは、[pgpool-hackers: 239][pgpool-hackers: 512] を参照してください。
    </p>
</li>

<li>
    オンラインリカバリの実行時は PostgreSQL の statement_timeout を無効にするようになりました。(Tatsuo Ishii)
    <p>
    オンラインリカバリは異常に長い時間を要する可能性がある一方、ユーザは statment_timeout を有効にしている可能性があります。これによりオンラインリカバリがキャンセルされるのを防ぐため、リカバリの最中は statement_timeout を無効にするようになりました。
    </p>
    <p>
    詳しくは [pgpool-general: 2919] を参照してください。
    </p>
</li>

<li>
    不適切にセマフォを削除しないよう不必要な pool_shmem_exit() 呼び出しを取り除きました。(Tatsuo Ishii)
    <p>
    exit_handler はプロセスが親プロセスがどうかをチェックしていますが、子プロセスであった場合にも pool_shmem_exit() が呼ばれることがあり、これにより不適切にセマフォが削除されていました。この関数は親プロセス以外に呼ばれてはなりません。
    </p>
    <blockquote>
    bug #102 によります。<br />
    <a href="http://www.pgpool.net/mantisbt/view.php?id=102">
    http://www.pgpool.net/mantisbt/view.php?id=102
    </a>
    </blockquote>
</li>

<li>
    リセット用クエリにより発生するハングを修正しました。(Tatsuo Ishii)
    <p>
    DISCARD ALL などのリセットクエリが完了せず、pgpool の子プロセスがバックエンドからの反応を待ったまま固まってしまい、新しいクライアントからの接続が受けられなくなる問題が報告されました。
    </p>
    <p>
    原因はまだ特定されていませんが、クライアントの接続がクエリ処理の最中に突然切断された場合、バックエンドがクエリを処理できない状態となり、リセットクエリを受け付けられなくのかもしれません。
    </p>
    <p>
    これに対処するため、フロントエンドから接続が予期せず切断された場合は、クエリ処理ループを即座に終了し PostgreSQL への接続を切断し、新しい接続要求を待つように修正しました。
    </p>
    <p>
    また client_idle_limit が設定されており、リミットに達した場合にもpgpool はバックエンドへの接続を切断するよう修正されました。
    </p>
    <blockquote>
    bug #107 の報告によります。<br />
    <a href="http://www.pgpool.net/mantisbt/view.php?id=107">
    http://www.pgpool.net/mantisbt/view.php?id=107
    </a>
    </blockquote>
</li>

</ul>


<!-- -------------------------------------------------------------------------------- -->
<h2><a name="release3.0.15"></a>3.0.15 (umiyameboshi) 2014/03/24</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンは 3.0.14 に対するバグ修正リリースです。
</p>

<h3>バグ修正</h3>
<ul>

<li>
    doc: num_init_children の項に「listen キュー」の説明とその「バックログ」を増やす方法について追記しました。
    (Tatsuo Ishii)
</li>

<li>
    UNLOGGED テーブルを検出する処理のパフォーマンスが悪かったのを修正しました。
    (Tatsuo Ishii)
    <p>
    この問題は <a href="http://www.sraoss.jp/pipermail/pgpool-hackers/2014-January/000435.html">[pgpool-hackers: 435]</a>
    <a href="http://www.sraoss.jp/pipermail/pgpool-general/2013-December/002354.html">[pgpool-general:2325]</a> で指摘されました。
    </p>
</li>

<li>
    プライマリノードの検出ロジックを修正しました。(Tatsuo Ishii)
    <p>
    プライマリノードが検出されないことがありました。例えば、node 0 がプライマリ、node 1
    がスタンバイのときに、node 0 が落ちたとします。ヘルスチェックがそれを検出しますが、
    内部のステータスがまだ更新されていない場合 node 0 には問題がないよう見えるため node 0
    への接続が試みられます。実際にはこの接続は失敗するため、node 1
    が新プライマリであることを検出する前に処理が終了していました。
    </p>
    <p>
    この問題は <a href="http://www.sraoss.jp/pipermail/pgpool-general/2014-January/002442.html">[pgpool-general: 2409]</a> にて報告されました。
    </p>
</li>

<li>
    raw モードで自動コミットが off で JDBC を使用したときに、DML
    が失敗するバグを修正しました。(Tatsuo Ishii)
    <p>
    この問題は <a href="http://www.pgpool.net/mantisbt/view.php?id=92">bug #92</a> で報告されました。
    </p>
</li>

<li>
    ストリーミングレプリケーションモードで無関係なノードにはクエリを送信しないように修正しました。
    (Tatsuo Ishii)
    <p>
    pgpool-II は BEGIN, END, SET などのクエリを全ての DB ノードに送っています。
    しかし、ストリーミングレプリケーションではプライマリノードと高々１台のスタンバイノードにしか送る必要がありません。
    （もしプライマリノードがロードバランスノードとして選択されている場合には１台だけで充分です。）
    </p>
    <p>
    詳細は <a href="http://www.sraoss.jp/pipermail/pgpool-hackers/2014-February/000464.html">
    [pgpool-hackers: 464]</a> を参照してください。
    </p>
</li>

<li>
    バッファオーバランとメモリリークの可能性を修正しました。(Tatsuo Ishii)
    <p>
    Coverity 1111465, 1111482 の報告によります。
    </p>
</li>

<li>
    NULL ポインタの解放を修正しました。(Tatsuo Ishii)
    <p>
    Coverity 1111384 の報告によります。
    </p>
</li>

<li>
    メモリリークを修正しました。(Tatsuo Ishii)
    <p>
    Coverity 1111446 の報告によります。
    </p>
</li>

<li>
    パラレルモードで system_db_hostname
    が空欄の場合に発生するセグメンテーションフォルトを修正しました。
    (Yugo Nagata)
</li>

<li>
    -d オプションで起動した場合に pgpool.conf
    の処理中のデバッグメッセージを出力するように修正しました
    (Yugo Nagata)
    <p>
    以前は -d オプション使用時でも出力されていないデバッグメッセージがありました。
    </p>
</li>

<li>
    レプリケーションモードで JDBC 使用時に now()
    を含む準備文で発生する例外を修正しました。(Yugo Nagata)
    <p>
    JDBC で準備文を PrepareThreshold 回以上実行した場合には、文に名前が付けられ Parse
    の後に Describe メッセージが発行されます。このとき、pgpool は now()
    をパラメータに書き換えるため、元のクエリには無かった新しいパラメータが追加されます。
    この場合、フロントエンドに返されるParameterDscription メッセージ（Describe
    の返答）は、元のクエリが持つパラメータと同じ数の OID を含むべきです。そうしないと、JDBC
    はArrayIndexoutOfBoundsException 例外を発生させてしまいます。
    </p>
    <p>
    このバグは <a href="http://www.sraoss.jp/pipermail/pgpool-general-jp/2013-September/001191.html">
    [pgpool-general-jp: 1192]</a> で報告されました。
    </p>
</li>

<li>
    レプリケーションモードにて、デフォルト値が now()
    のカラムを持つテーブルに対する準備文でエラーが発生するバグを修正しました。
    (Yugo Nagata)
    <p>
    デフォルト値が now() を持つ名前付き準備文を parse する際に、pgpool-II
    は時刻値をパラメータで置き換えます。そのため、その後の bind
    メッセージも追加されたパラメータの形式コードを含んでいる必要があります。
    しかし、元のクエリのパラーメータ形式数が１だった場合、この処理がなされていませんでした。これが
    "incorrect binary data format in bind parameter 2" のようなエラーの原因となっていました。
    </p>
</li>

<li>
    doc: パラレルモードは PREPARE 文の実行に対応していないことを追記しました。(Yugo Nagata)
    <p>
    <a href="http://www.pgpool.net/mantisbt/view.php?id=93">bug #93</a> の指摘によります。
    </p>
</li>

</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2><a name="release3.0.14"></a>3.0.14 (umiyameboshi) 2013/12/06</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンは 3.0.13 に対するバグ修正リリースです。
</p>

<h3>バグ修正</h3>
<ul>

<li>レプリケーションモード稼働時、一部のタイムゾーンでタイムスタンプの書き換えが誤っていました。(Tatsuo Ishii)
<p>タイムスタンプの書き換え処理では、現在日時を取得するために "SELECT now()" を実行します。
しかし一部のタイムゾーンにおいては、"02:30" のような場合に現在日時のためのバッファの大きさが
十分ではありませんでした。"0900" のように 30 分刻みでのタイムゾーンでないときは、この問題は発生しません。
そのため、これまでこの不具合が報告されたことはありませんでした。</p>
<p>この不具合は <a href="http://www.sraoss.jp/pipermail/pgpool-general/2013-September/002142.html" target="_blank">[pgpool-general: 2113]</a> で報告され、Sean Hogan さんによって修正が提供されました。</p>
</li>

<li>Makefile: Makefiles 内の pg_config を $(PG_CONFIG) に置き換えました。
したがって、PostgreSQL のメジャーバージョンが異なる場合には、コンパイル中で上書きされるようになります。(Tatsuo Ishii)
<p>パッチは Christoph Berg さんから提供されました。（<a href="http://www.sraoss.jp/pipermail/pgpool-general/2013-September/002156.html" target="_blank">[pgpool-general: 2127]</a>）</p>
</li>

<li>configure: FreeBSD で問題があったため、-lcompat を削除しました。(Tatsuo Ishii)
<p><a href="http://www.pgpool.net/mantisbt/view.php?id=15">bug#15</a> で報告されました。</p>
</li>

<li>pgpool.conf で <a href="#LOG_STANDBY_DELAY">log_standby_delay</a> を設定してないときに
segfault していたのを修正しました。(Tatsuo Ishii)
<p>これは、pool_config.l での log_standby_delay の初期化が誤っていたためです。
<a href="http://www.pgpool.net/mantisbt/view.php?id=74" target="_blank">bug#74</a> として報告されました。</p>
</li>

<li>doc: パラレルモードの制限事項を追記しました。VALUES 句を使った複数行の INSERT はパラレルモードではサポートされていません。(Yugo Nagata)</li>

<li>スタンバイノードがダウンしようとしているときに find_primary_node_repeatedly() が
呼ばれないようにしました。(Tatsuo Ishii)
<p>これによってフェイルオーバの所要時間が短くなります。
<a href="http://www.pgpool.net/mantisbt/view.php?id=75" target="_blank">bug#75</a> として報告され、
パッチを Tatsuo Ishii が編集しました。</p>
</li>

<li>read_password_packet() のエラーメッセージを修正しました。(Tatsuo Ishii)</li>

<li>SSL 要求でのメモリリークを修正しました。(Tatsuo Ishii)
<p>SSL での要求があったとき、pgpool 子プロセスは start up packet の読み込みをリトライしていました。
しかし子プロセスは、以前の start up packet のメモリを解放していませんでした。</p>
<p>これは Coverity "1111443 Resource" で発見されました。</p>
</li>

<li>do_query() がタイムスタンプの書き換えに失敗したとき、メモリリークしていました。(Tatsuo Ishii)
<p>この修正のために、free_select_result() で NULL 引数を受け取れるようにしました。</p>
<p>これは Coverity "1111454, 1111455 Resource leak" で発見されました。</p>
</li>

<li>"<code>DEALLOCATE portal|statement</code>" 実行時の対象ノードの選定ロジックを修正しました。(Tatsuo Ishii)
<p>"<code>DEALLOCATE portal|statement</code>" 実行時、最後の prepared statement や portal が見つからない場合に、
対象ノード選定マップがセットされていませんでした。
おそらく、そうした場合はエラーなので、実際には問題ありません。</p>
<p>これは Coverity "1111491 Structurally dead code" で発見されました。</p>
</li>

<li>MAX_NUM_BACKENDS の範囲チェックにおける不具合を修正しました。 (Tatsuo Ishii)
<p>MAX_NUM_BACKENDS は DB ノードの最大数が限界値でした（現時点では 128）。
実際には 128 の DB ノードで試す人がいなかったために、発見されなかった不具合のようです。</p>
<p>これは Coverity "1111429, 1111430 and 1111431 Out-of-bounds write" で発見されました。</p>
</li>

<li>フロントエンド接続情報を、すでに無効なバックエンドについて set/unset しないようにしました。(Tatsuo Ishii)
<p>この不具合は <a href="http://www.pgpool.net/mantisbt/view.php?id=82" target="_blank">bug#82</a> で報告されました。</p>
</li>

<li>pgpool_catalog への public access を許可していませんでした。
<p>これは、pgpool_catalog がレプリケーションモードで作成されている場合に、
ユーザテーブルにデータを INSERT すると発生します。</p>
<p>この不具合は <a href="http://www.sraoss.jp/pipermail/pgpool-general-jp/2013-November/001228.html" target="_blank">[pgpool-general-jp: 1229]</a> で報告されました。</p>
</li>

<li>pool_do_auth() のエラーケースで変数を初期化していませんでした。 (Tatsuo Ishii)
<p>有効なバックエンドがいないとき、pgpool は認証フェーズのフロントエンドにごみの pid を返していました。
実際に、有効なバックエンドがいないために、フロントエンドは認証後に接続することができません。
もちろんこれは問題あるものではありません。</p>
<p>これは Coverity "1127331 Uninitialized scalar variable" で発見されました。</p>
</li>

<li>ノード ID を使ったエラーメッセージの発行時に、ノード ID の範囲チェックをするようにしました。
(Tatsuo Ishii)
<p>これは Coverity "1111433 "Out-of-bounds read" で発見されました。</p>
</li>

<li>parse_copy_data() でのバッファオーバーランとリソースリークを修正しました。 (Tatsuo Ishii)
<p>これは Coverity "1111427 Out-of-bounds write"、"1111453 Resource leak" で発見されました。</p>
</li>

<li>CopyDataRaws() で segfault する可能性があったのを修正しました。(Tatsuo Ishii)
<p>pool_get_id() がエラーを返した場合に VALID_BACKEND が配列外にアクセスしようとしていました。</p>
<p>これは Coverity "1111433 Out-of-bounds read" で発見されました。</p>
</li>

<li>make_persistent_db_connection のリソースリークを修正しました。(Tatsuo Ishii)
<p>この修正ののために、新しく free_persisten_db_connection_memory 関数を追加しました。</p>
<p>これは Coverity #1111468 で発見されました。</p>
</li>

<li>Coverity で見つかったさまざまな不具合を修正しました。(Tatsuo Ishii)</li>

</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2><a name="release3.0.13"></a>3.0.13 (umiyameboshi) 2013/09/06</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンは 3.0.12 に対するバグ修正リリースです。
</p>

<h3>バグ修正</h3>
<ul>

<li>
    doc/basebackup.sh スクリプトの ssh コマンドの間違いを修正しました。(Tatsuo Ishii)
</li>

<li>
    レプリケーションモードにおけるプリペアド文のパース処理を修正しました。(Tatsuo Ishii)
    <p>
    レプリケーションモードで SELECT 以外のクエリをパースする際には、
    ノード間の一貫性保持のため自動的にトランザクションが開始されますが、
    トランザクションを閉じる処理が行われていませんでした。
    そのため、実際に誤っているクエリだけではなく、その次にパース処理されたクエリもアボートされていました。
    </p>
    <p>
    このバグは [pgpool-general: 1877] で Sean Hogan さんにより報告されました。
    </p>
    <blockquote>
    [pgpool-general: 1877] current transaction is aborted, commands ignored<br />
    <a href="http://www.sraoss.jp/pipermail/pgpool-general/2013-July/001905.html">
    http://www.sraoss.jp/pipermail/pgpool-general/2013-July/001905.html
    </a>
    </blockquote>
</li>

<li>
    日本語ドキュメントの typo を修正しました。 (Yugo Nagata)
</li>

</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.12 (umiyameboshi) 2013/07/10</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンは 3.0.11 に対するバグ修正リリースです。
</p>
<h3>バグ修正</h3>
<ul>
<li>
man ページに -D オプションの記述を追加しました。（Tatsuo Ishii)
</li>

<li>
オンラインリカバリ時のフェイルバックの完了待機でタイムアウト処理をするようにしました。(Tatsuo Ishii)
<p>
これによりリカバリが永遠に終わらず pgpool-II が終了できなくなる状況を回避します。
この現象は特に follow_master_command の実行中に起こり得ました。
</p>
</li>

<li>
PostgreSQL がエラーを返したときに do_query() がハングしないよう修正しました。
(Tatsuo Ishii)
<p>
典型的な症状が「pg_stat_activety によると SELECT が実行されたままのように見える」というものです。
これを解決するため、pgpool-II は当該プロセスを終了させ、既存のコネクションを捨てるように修正しました。
</p>
</li>

<li>
拡張プロトコルの際に do_query で発生しうるハングアップを修正しました。
(Tatsuo Ishii)
<p>
これは insert_lock が有効で、pgpool_catalog.insert_lock が存在することに起こり得ます。
詳しくは [pgpool-general: 1684] を参照してください。
</p>
<blockquote>
  [pgpool-general: 1684] insert_lock hangs <br />
  <a href="http://www.sraoss.jp/pipermail/pgpool-general/2013-May/001711.html">
  http://www.sraoss.jp/pipermail/pgpool-general/2013-May/001711.html
  </a>
</blockquote>
</li>

<li>
COMMIT 時エラーに不要なバックエンド切り離しを行わないようにしました。
(Tatsuo Ishii)
<p>
マスタースレーブモードで、COMMIT 時にマスターノードでエラーが発生していたとしても、他のスレーブノードが正常な場合にはバックエンドを切り離す必要はありません。
これは、遅延トリガーのために "kind mismatch error" が発生しうるからです。
</p>
</li>

<li>
pgpool_regclass を pg_catalog スキーマに登録するよう修正しました。
(Tatsuo Ishii)
<p>
これは postgres_fdw のような、スキーマ検索パスが pg_catalog に限定されているクライアントに対応するために必要です。
</p>
</li>

<li>
pg_md5 コマンドで起こりうるクラッシュを修正しました。(Muhammad Usama)
</li>

<li>
スタートアップパケットに PostgreSQL ユーザ情報が含まれていなかった場合に発生する子プロセスのセグメンテーション違反を修正しました。(Yugo Nagata)
<p>
このバグは以下を実行することにより再現できます。
</p>
<pre>
    $ psql -p 9999 -U ''
</pre>
<p>
enable_pool_hba が有効の場合は子プロセスがセグメンテーション違反で異常終了し、無効の場合には以下のメッセージがログに出力されていました。
</p>
<pre>
    ERROR: pool_discard_cp: cannot get connection pool for user (null) database (null)
</pre>

<p>
また、両方の場合で psql はフロントエンドに何のメッセージ出力せずに終了していました。
修正後は、スタートアップパケットに PostgreSQL ユーザが指定されていない場合には以下のメッセージがログとフロントエンドの両方に出力されます。
これは PostgreSQLと同じ振る舞いです。
</p>
<pre>
    FATAL: no PostgreSQL user name specified in startup packet
</pre>
</li>

<li>
マニュアルの ssl_sa_cert, ssl_ca_cert_dir オプションの説明を SSL セクションに移動しました。(Yugo Nagata)
</li>

<li>
ssl_sa_cert, ssl_ca_cert_dir オプションの説明を日本語マニュアルに追加しました。(Yugo Nagata)
</li>

<li>
pcp_recovery_node コマンドで、バックエンドノード番号をチェックするように修正しました。(Yugo Nagata)
<p>
不正な値が使用された場合、リカバリで実行されるスクリプトの引数に空の値が渡されており、誤動作の原因となっていました。
特にベースバックアップを行うスクリプトで、rsync が関係のないファイルを削除してしまうことがありました。
</p>
</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.11 (umiyameboshi) 2013/04/26</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、3.0.10における様々なバグが修正されています。
</p>

<h3>バグ修正</h3>
<ul>

<li>
設定パラメータの一覧を表示する "SHOW pool_status" で pool_passwdが表示されていないのを修正しました。(Yugo Nagata)
</li>

<li>
拡張プロトコルの処理における timestamp の書き換えに関する長い間見過ごされていてたバグを修正しました。(Tatsuo Ishii)
<p>
  Parse() 関数は、parse メッセージの書き換えの際に palloc() を使ってメモリを確保していました。
  書き換えられたメッセージは pool_create_sent_message()
  関数などが管理するデータ領域に格納されますが、これが問題となっていました。
  この関数ではデータが session context memory 中に存在することを想定しているのに対し、
  palloc() では query context においてメモリの割り当てを行っており、この領域は
  query context 終了時に解放されます。しかし、他の関数もこのメモリ領域を解放しようとするため、
  セグメンテーション違反や二重解放を含む様々な問題の原因となっていました。
  この問題は、書き換えたメッセージを格納するメモリを session context を用いて確保するこで修正されました。
  これは pgpool-II 3.0 以来ずっと存在していたバグです。
</p>
<p>
  この問題は、Naoya Anzai さんによって解析され、パッチが提供されました。
</p>
<blockquote>
  [pgpoolgenera-jp: 1146]<br />
  拡張問い合わせプロトコルでセグメンテーションフォルト<br />
  <a href="http://www.pgpool.net/pipermail/pgpool-general-jp/2013-March/001145.html">
  http://www.pgpool.net/pipermail/pgpool-general-jp/2013-March/001145.html
  </a>
</blockquote>
</li>

<li>
md5認証で長いユーザ名を処理する際のバグを修正しました。(Tatsuo Ishii)
<p>
  ユーザ名が 32 バイトより長い場合、md5 認証が動作していませんでした。
  この問題は [pgpool-general: 1526] で Thomas Martin さんにより報告されました。
</p>
<blockquote>
  [pgpool-general: 1526]<br />
  [pgPool-II 3.2.3] MD5 authentication and username longer than 32 characters.<br />
  <a href="http://www.pgpool.net/pipermail/pgpool-general/2013-March/001551.html">
  http://www.pgpool.net/pipermail/pgpool-general/2013-March/001551.html
  </a>
</blockquote>
</li>

<li>レプリケーション遅延の計算はスタンバイサーバがプライマリサーバより遅れている場合にのみ行うよう修正しました。(Yugo Nagata)
<p>
  タイミングによってスタンバイよりプライマリの方がレプリケーションが遅延
  しているように見える場合があり、その場合には負値の遅延が計算されていました。
  この値が符号無し変数に代入されると、実際には遅延が生じていないにも関わらず、
  ログに遅延が負値で出力され、されに悪いことには、ロードバランス機能により
  SELECT クエリがプライマリに振り分けられ、その結果プライマリの負荷が高まる
  ことがありました。
</p>
<p>
  この問題は Saitoh Hidenori さんによって報告、解析されました。
</p>
<blockquote>
  [pgpool-genera-jp: 1145]<br />
  レプリケーション遅延確認の不具合について<br />
  <a href="http://www.pgpool.net/pipermail/pgpool-general-jp/2013-March/001144.html">
  http://www.pgpool.net/pipermail/pgpool-general-jp/2013-March/001144.html
  </a>
</blockquote>
</li>

<li>pgpool-recovery が PostgreSQL 9.3 に対応しました。 (Tatsuo Ishii)
<p>
  パッチは Asif Rehman さんにより提供され、これに Tatsuo Ishii が若干の修正を
  加えました。
</p>
<blockquote>
  [pgpool-hackers: 180] <br />
  compile error in ppool-recovery<br />
  <a href="http://www.pgpool.net/pipermail/pgpool-hackers/2013-April/000179.html">
  http://www.pgpool.net/pipermail/pgpool-hackers/2013-April/000179.html
  </a>
</blockquote>
</li>

<li>pool_has_pgpool_regclass が pgpool_regclass() の実行権限をチェックするよう修正しました。 (Tatsuo Ishii)
<p>
  pgpool_regclass が存在する場合でも、pgpool がこの関数を実行できない場合に、
  バックエンドへの接続がハングしていました。この問題は、pgpool_regclass
  から実行権限を剥奪し、ネイティブレプリケーションモードで INSERT を実行
  することで再現可能です。
</p>
<p>
  この問題は bugtrack #53 で報告されました。
</p>
<blockquote>
  #53 pgpool_regclas hangs all connections<br />
  Date:     2013-04-04 13:35 <br />
  Reporter: tmandke<br />
  <a href="http://www.pgpool.net/mantisbt/view.php?id=53">
  http://www.pgpool.net/mantisbt/view.php?id=53
  </a>
</blockquote>
</li>

<li>detect_postmaster_down_error() のエラーメッセージを修正しました。(Tatsuo Ishii)
<p>
  例えば、"LOG: detect_stop_postmaster_error: detect_error error" を
  "LOG: detect_postmaster_down_error: detect_error error" に修正するなどです。
</p>
</li>

</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.10 (umiyameboshi) 2013/02/08</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、3.0.9における様々なバグが修正されています。
</p>

<h3>バグ修正</h3>
<ul>

<li>md5 認証で競合が発生する不具合が修正されました。(Tatsuo Ishii)
<p>
  pool_passwd のファイル識別子は pgpool の親プロセスで開かれたものが子プロセス
  に引き継がれてます。複数の接続で同時に md5 認証を行う際には、pool_get_passwd が
  呼ばれ、ファイル識別子が走査されますが、ファイル識別子が共有されるために md5 認証
  が失敗することがありました。この問題は、個々の子プロセスで pool_passwd ファイルを
  開き直すことで解決されました。
</p>
<p>
  この問題は [pgpool-general:1141] にて、Jason Slagle さんによって報告・解析されました。
</p>
<blockquote>
  [pgpool-general: 1141] Possible race condition in pool_get_passwd<br />
  From: Jason Slagle<br />
  Date: Sun, 28 Oct 2012 01:12:52 -0400<br />
  <a href="http://www.sraoss.jp/pipermail/pgpool-general/2012-October/001160.html">
  http://www.sraoss.jp/pipermail/pgpool-general/2012-October/001160.html</a>
</blockquote>
</li>

<li>pool_send_severity_message() で未初期化のメモリを使用しないよう修正しました。
  (Tatsuo Ishii)
<p>
  このバグによりセグメンテーション違反が発生することがありました。
  バグトラック #33 に投稿された valgrind 実行結果（dudee さんによる）にて報告されました。
</p>
<blockquote>
  #33 pgpool-II 3.2.1 segfault<br />
  Reporter: dudee
  Date: 2012-10-30 19:16
  <a href="http://www.pgpool.net/mantisbt/view.php?id=33">
  http://www.pgpool.net/mantisbt/view.php?id=33</a>
</blockquote>
</li>

<li>pcp または worker 子プロセスの終了イベントを受信したときに、reaper() で wait3()
  ループを終了しないように修正しました。 (Tatsuo Ishii)
<p>
  修正前は、reaper() は子プロセスの終了イベントを誤って無視してしまい、ゾンビプロセスを作り、
  新しいプロセスを生成できないことがありました。
</p>
<p>
  この問題は[pgpool-general-jp: 1123]にて、後藤さんより報告され、修正の示唆を頂きました。
</p>
<blockquote>
  [pgpool-general-jp: 1123] Re: オンラインリカバリ後にゾンビプロセスになる<br />
  From: GOTO, Daisuke
  Date: Wed, 21 Nov 2012 19:56:17 +0900
  <a href="http://www.sraoss.jp/pipermail/pgpool-general-jp/2012-November/001122.html">
  http://www.sraoss.jp/pipermail/pgpool-general-jp/2012-November/001122.html</a>
</blockquote>
</li>

<li>pool_search_relcache() が REAL_MASTER_NODE_ID ではなく MASTER, MASTER_NODE_ID
  を使用するように修正しました。 (Tatsuo Ishii)
<p>
  ストリーミングレプリケーションモードで 0 番ノードがフェールバックした場合、pgpool は
  子プロセスを再起動しません。そのとき、REAL_MASTER_NODE_ID は 0 番ノードの接続
  情報を探しにいきますが、これはバックエンドへの新しい接続が確立するまで存在しません。
  そのため、接続情報の参照によって、セグメンテーションフォルトが発生していました。
  この状況でも、MASTER または MASTER_NODE_ID は以前にキャッシュされたマスター
  ノード ID を見にいくため、安全に使うことが出来ます。
</p>
</li>

<li>ストリーミングレプリケーションモードでレプリケーション遅延が大きくなったときに、
  "portal not found" エラーが発生するバグを修正しました。 (Tatsuo Ishii)
<p>
  これは delay_threshold が導入以来、ずっと存在していたバグです。
</p>
<p>
  bind, describe, execute の実行時に遅延が域値を越えた場合、送り先の DB ノードは
  変更されていました。しかし、parse がそれとは異なるノードに送られていた場合、送り先ノードには
  parse された ステートメントやポータルが存在しないために bind, describe, execute は
  失敗していました。 修正後は、大きな遅延が発生した場合でも、これらは parse が実行された
　ノード以外には送られないようになりました。
</p>
</li>

<li>pg_md5 で、ユーザからのパスワード入力の後には改行するように修正しました。 (Yugo Nagata)</li>

<li>コネクションプールが存在しない場合には、child_exit() が send_frontend_exits()
  を呼ばないよう修正しました。 (Tatsuo Ishii)
<p>
  send_frontend_exits() は pool_connection_pool で指されてるオブジェクトを参照しているため、
  修正前にはセグメンテーションフォルトが発生していました。バグトラック #44 の tuomas さんの報告によります。
</p>
<blockquote>
  #44 pgpool went haywire after slave shutdown triggering master failover<br />
  Reporter: tuomas
  Date: 2012-12-11 00:33
  <a href="http://www.pgpool.net/mantisbt/view.php?id=44">
  http://www.pgpool.net/mantisbt/view.php?id=44</a>
</blockquote>
</li>

<li>pool_read() が不正なパケットを読み込んだ場合に、read_startup_packet() がアラームクロック
  をリセットして StartupPacket を解放するよう修正しました。 (Nozomi Anzai)
<p>
  修正前は、pgpool ポートの監視を行うプログラムの接続により、認証のタイムアウトが発生していました。
  この問題は、バグトラック #35 で報告されました。
</p>
<blockquote>
  #35 Authentication is timeout<br />
  Reporter: tuomas
  Date: 2012-11-20 11:54
  <a href="http://www.pgpool.net/mantisbt/view.php?id=35">
  http://www.pgpool.net/mantisbt/view.php?id=35</a>
</blockquote>
</li>

<li>pool_open() が誤ったバッファポインタを初期化していたバグを修正しました。 (Tatsuo Ishii)
<p>
  このポインタは事前に memset() によって初期化されているため、実際にはこのバグによる害は
  ありませんでした。
</p>
</li>

<li>ヘルプメッセージに -f オプションの説明を追加しました。 (Tatsuo Ishii)</li>

<li>ドキュメント中の、「パラメータ変更に再起動が必要かどうか」の情報を追記・修正しました。(Yugo Nagata)</li>

<li>pool_passwd に関する記述を pgpool_conf.sample*、および,ドキュメントに追加しました。 (Yugo Nagata)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.9 (umiyameboshi) 2012/10/12</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、3.0.8における様々なバグが修正されています。
</p>

<h3>バグ修正</h3>
<ul>
<li>read_startup_packet() を修正しました。(Tatsuo Ishii)
    <p>
    パケット長が 0 以下のときは直ちに return するべきでしたが、そうなっていなく、
    メモリ確保時にエラーになっていました。
    </p>
    <p>これは pgpool-general:886 を参照してください。また、キャンセルアラームを追加しました。</p>
    <blockquote>
    [pgpool-general: 886] read_startup_packet: out of memory<br>
    From: Lonni J Friedman<br>
    Date: Wed, 8 Aug 2012 10:18:15 -0700<br>
    <a href="http://www.sraoss.jp/pipermail/pgpool-general/2012-August/000896.html">
    http://www.sraoss.jp/pipermail/pgpool-general/2012-August/000896.html</a>
    </blockquote>
</li>

<li>s_do_auth() に NOTICE メッセージを追加しました。(Tatsuo Ishii)
    <p>これがなかったために、ヘルスチェックが false アラームを受け取りフェイルオーバしていました。</p>
    <p>これはバグトラックで報告されました。</p>
    <blockquote>
    #25 s_do_auth doesn't handle NoticeResponse (N) message<br>
    Date:     2012-08-28 03:57<br>
    Reporter: singh.gurjeet<br>
    <a href="http://www.pgpool.net/mantisbt/view.php?id=25">http://www.pgpool.net/mantisbt/view.php?id=25</a>
    </blockquote>
</li>

<li>s_do_auth() から、不要かつ混乱をまねくデバッグメッセージを削除しました。(Tatsuo Ishii)</li>

<li>SSL モードでの無限ループを修正しました。 (Tatsuo Ishii)
    <p>
    フロントエンドの SSL レイヤで溜っているデータがあるとき、
    pool_process_query() がバックエンドに溜っているデータをチェックします。
    もしそれが無かったときは再度ループして、フロントエンド/バックエンドがバッファを受け取っていないか
    is_cache_empty() を以ってチェックします。
    しかし、フロントエンドの SSL レイヤでデータが溜っているのを一度検知すると、
    バックエンドに行ってまたチェックしようとします（無限ループ）。
    </p>
    <p>
    これを解決するには、フロントエンドの SSL レイヤに溜っているデータがあり
    かつ クエリが実行中でなければ、ProcessFrontendResponse() を呼んで
    フロントエンドへの新しいリクエストをするようにしました。
</p>
</li>

<li>is_system_catalog() で、可能ならば pgpool_regclass を使うようにしました。(Tatsuo Ishii)</li>

<li>pool_get_insert_table_name() のメモリリークを修正しました。(Tatsuo Ishii)
    <p>
    nodeToString() でセッションコンテクストのメモリコンテクストを使ったあと、
    セッション終了までは、メモリを解放していませんでした。
    </p>
    <p>詳しくはバグトラックをご覧ください。</p>
    <blockquote>
    #24 Severe memory leak in an OLTP environment<br>
    Date:     2012-08-28 03:43<br>
    Reporter: singh.gurjeet<br>
    <a href="http://www.pgpool.net/mantisbt/view.php?id=24">http://www.pgpool.net/mantisbt/view.php?id=24</a>
    </blockquote>
</li>

<li>do_query() のセグメンテーションフォルトを修正しました。(Tatsuo Ishii)
    <p>
    クエリキャッシュが有効で拡張問い合わせが使われているとき、do_query() はシステムカタログに接続し、
    pool_read2() を使います。
    しかし、parse メッセージパケットを Parse() で取得し、パケットの内容が pool_read2() のバッファにあります。
    このため、do_query() はパケットの内容を分割できず、セグメンテーションフォルトを引き起こしていました。
    </p>
    <p>
    これを解決するために、メモリを確保し、パケット内容をコピーし、Parse() を飛ばすようにしました。
    ただし、パケットの中にはクエリコンテクストが参照しているクエリ文字列も含まれています。
    そのため、このクエリ文字列をコピーしてポインタをクエリコンテクストに保持する必要があります。
    </p>
    <p>
    これは、Parse() だけの話でなく、他のプロトコルモジュールにもある問題と考えています。
    本修正はそれらにも適用しますが、そのためには、ProcessFrontendResponse() を変更します。
    </p>

    <p>この問題はバグトラック #21 で報告されました。</p>
    <blockquote>
    #21 pgpool-II 3.2.0 cannot execute sql through jdbc<br>
    Date:     2012-08-17 16:31<br>
    Reporter: elisechiang<br>
    <a href="http://www.pgpool.net/mantisbt/view.php?id=21">http://www.pgpool.net/mantisbt/view.php?id=21</a>
    </blockquote>
</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.8 (umiyameboshi) 2012/08/06</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、3.0.7における様々なバグが修正されています。
</p>

<h3>バグ修正</h3>
<ul>
<li>Solaris でのロードバランスを修正しました。(Tatsuo Ishii)
    <p>Solaris での random() 関数の仕様のために問題があったため、rand() に変更しました。</p>
    <p>この事象は [pgpool-general: 396] で報告されました。</p>

    <blockquote>
    <a href="http://www.pgpool.net/pipermail/pgpool-general/2012-April/000397.html">[pgpool-general: 396]</a>
    strange load balancing issue in Solaris<br>
    From: Aravinth<br>
    Date: Sat, 28 Apr 2012 07:26:58 +0530
    </blockquote>
</li>

<li>パラレルモードでないとき、<a href="#pcp_systemdb_info">pcp_systemdb_info</a> コマンドが
    segfault してたのを修正しました。(Nozomi Anzai)</li>

<li>"unnamed prepared statment does not exist" というエラーが出るのを修正しました。(Tatsuo Ishii)
    <p>
    このエラーは pgpool が内部的に発行しているクエリで発生し、
    クライアントが発行する unnamed ステートメントを破壊していました。
    </p>
    <p>
    拡張問い合わせクエリが実行されたときには、内部的に発行するクエリのステートメントとポータルに
    名前をつけるようにしました。
    </p>
</li>

<li>pid ファイルの読み書きを改善しました。(Tatsuo Ishii)</li>

<li><a href="http://www.pgpool.net/pipermail/pgpool-general/2012-June/000676.html">[pgpool-general: 672]</a>
    で報告された、process_query() のバグを修正しました。(Tatsuo Ishii)
    <p>
    プライマリでは処理するデータがなく スタンバイにはある状態のときに、
    プライマリの処理を待ってしまうことがありました。
    </p>
    <blockquote>
    Subject: <a href="http://www.pgpool.net/pipermail/pgpool-general/2012-June/000676.html">[pgpool-general: 672]</a>
    Transaction never finishes<br>
    From: Luiz Pasqual<br>
    Date: Thu, 28 Jun 2012 09:55:23 -0300
    </blockquote>
</li>

<li>wait_for_query_response() が、frontend がないときには何もしないように修正しました。(Tatsuo Ishii)
    <p>バックエンドをリセットする reset_query_list のクエリを実行に時間がかかったときに
    発生する可能性があり、またクラッシュすることがありました。</p>
</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.7 (umiyameboshi) 2012/04/23</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、3.0.6におけるバグが修正されています。
</p>

<h3>バグ修正</h3>
<ul>
<li>m4 ファイルを追加しました。これにより古い OS で起こるコンパイルの問題を回避できます。(Tatsuo Ishii)</li>
<li>シグナル割り込みによって、セマフォが解放されないままプロセスが終了することがあるバグを修正しました。(Tatsuo Ishii)</li>
<li>reset_query 時のメモリリークを修正しました。 (Tatsuo Ishii)</li>
<li>以下の場合に parser memory をリストアするよう SimpleQuery() 関数を修正しました。
    <ol>
    <li>組み込み show コマンド使用時</li>
    <li>パラレルクエリモード</li>
    <li>クエリキャッシュ使用時</li>
    </ol>
    さもないと、後で不正な palloc を発生する障害が起きるからです。(Tatsuo Ishii)
</li>
<li>pool_ssl_read() 関数が大きいサイズのデータを読み込めるよう修正しました。以下の報告によるものです。(Tatsuo Ishii)<br />
    <a href=http://www.pgpool.net/pipermail/pgpool-general/2012-March/000299.html">
    http://www.pgpool.net/pipermail/pgpool-general/2012-March/000299.html</a></li>

<li>PREPARE 文でエラーが起きた際に発生するハングアップを修正しました。Tominari Katsumata さんの報告に基づきます。(Toshihiro Kitagagwa)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.6 (umiyameboshi) 2012/01/31</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、3.0.5におけるバグが修正されています。
</p>

<h3>バグ修正</h3>
<ul>
<li>以下のスレッドで報告されている無限ループを修正しました。(Tatsuo Ishii)<br/>
    <a href="http://www.pgpool.net/pipermail/pgpool-general/2011-December/000099.html">
    http://www.pgpool.net/pipermail/pgpool-genral/2011-December/000099.html</a><br/>
    プライマリからから受け取ったバッファが空である一方で、スタンバイのどれかが
    受け取ったバッファが空でないとき、pgpool へのパケットが送られてしまう、
    という可能性が考慮されていませんでした。<br/>
    この事象は例えば、postgresql.conf を再読み込みしたときに発生することがありました。<br/>
    この修正では、スタンバイからしか受け取れなかったバッファは無視するようにしました。
</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.5 (umiyameboshi) 2011/10/31</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、3.0.4における様々なバグが修正されています。
</p>

<h3>バグ修正</h3>
<ul>
<li>空のクエリの処理に関するバグを修正しました。空のクエリはSELECTクエリと同じ扱いになります。
    この修正は、空のクエリのあとのロードバランスを可能にします(Kitagawa)</li>
<li>カラム定義が"DEFAULT nextval(('"x_seq"'::text)::regclass)"のようになっていても
    insert_lockが正しく動作するように修正しました(Kitagawa)</li>
<li>pgpool-IIマニュアルのbackend_weightに関する説明を修正しました。
    それは、pgpool.confの再読み込みで変更できます(Tatsuo)</li>
<li>rawモードでノードを復帰させたときにノードの状態が更新されないバグを修正しました(Guillaume Lelarge)</li>
<li>FOR SHARE/UPDATE句のあるサブクエリを含むSELECTがスレーブ(standby)に送られるバグを修正しました(Tatsuo)</li>
<li>PREPARE文でデフォルト値のタイムスタンプ書き換えに失敗するバグを修正しました。
    これは以前は動作していましたが、3.0で動作しなくなっていました(Kitagawa)</li>
<li>rawモード、enable_hbaが無効、バックエンドが2台以上の場合に
    pgpool子プロセスがクラッシュするのを修正しました(Kitagawa)</li>
<li>メモリリークをいくつか修正しました(Kitagawa)</li>
</ul>

<h3>改良</h3>
<ul>
<li>カラムのデフォルト値に任意の式を指定してもタイムスタンプ書き換えが動作するようにしました。
以前は、now()が含まれているものを検知すると、単純にそれをnow()で置き換えてました。
これは、デフォルト値の誤った書き換えを引き起こします。例えば、timezone('utc'::text, now())です。
しかし、これは簡易プロトコルのみへの適用であることに注意してください。
拡張プロトコル(例えばJava, PHP PDO)または、SQLの"PREPARE"にはまだ適用されていません(Tatsuo)</li>
<li>エラーメッセージ"do_md5: read_password_packet failed"をデバッグレベルにしました(Kitagawa)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.4 (umiyameboshi) 2011/06/01</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、3.0.3における様々なバグが修正されています。
</p>

<h3>互換性のない変更</h3>
<ul>
 <li>ストリーミングレプリケーションにおいて、delay_thresholdが0またはヘルスチェックが無効ならば、遅延チェックは実施されません。これはpgpool-IIマニュアル通りの動作ですが、これまではヘルスチェックが無効の場合も遅延チェックが実施されていました(Guillaume Lelarge)</li>
</ul>

<h3>バグ修正</h3>
<ul>
 <li>pgpool-regclass()をPostgreSQL 8.0以降でコンパイルできるように修正しました。7.4はまだエラーが出ます(Tatsuo) </li>
 <li>ストリーミングレプリケーション構成で/*NO LOAD BALANCE*/コメントを使用したときにハングアップする可能性を修正しました(Kitagawa)</li>
 <li>Flush(H)メッセージやCloseComplete(C)メッセージを受信したときのハングアップを修正しました(Kitagawa)</li>
 <li>pgpool-IIがバックエンドに接続後、RedyForQuery(Z)メッセージを受信するタイミングによって起こり得るハングアップを修正しました(Kitagawa)</li>
 <li>recovery_1st_stage_commandとrecovery_2nd_stage_commandパラメータの説明を追加しました(Tatsuo)</li>
 <li>pgpool-II内部で使用するシステムカタログキャッシュのサイズを32から128に増やしました。これは&quot;unnamed prepared statement does not exist&quot;エラーを軽減する効果があります(Tatsuo, Kitagawa)</li>
 <li>pcp_connect()関数で二重free()を行うバグを修正しました。パッチはJehan-Guillaume (ioguix) de Rorthaisさんから頂きました(Tatsuo)</li>
 <li>PQfinish()関数を誤って使用しているstart_recoery()のバグを修正しました(Tatsuo)</li>
 <li>クライアントのアイドル時間がclient_idle_limitに達したときに、フロントエンドに送信される正しくないエラーメッセージを修正しました(Tatsuo)</li>
 <li>pool_statusの「backend status」変数の名前を正しく修正しました。スペースを'_'に置き換えました(Guillaume Lelarge)</li>
 <li>md5認証方式を採用してデーモンとして実行したときのハングアップを修正しました。パッチは、Nicolas Thauvinさんから頂きました(Tatsuo)</li>
 <li>拡張問い合わせプロトコルでSQL文が出力されるように、log_per_node_statementを修正しました。これは以前は動作していましたが、3.0で動作しなくなっていました(Kitagawa)</li>
</ul>

<h3>改良</h3>
<ul>
 <li>サンプルの設定ファイルのblack_function_listにcurrval()とlastval()を追加しました。もしそれらがロードバランスされると、nextval()やsetval()の結果がスレーブに反映される前にcurrval()またはlastval()が呼ばれることがあります(Tatsuo)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.3 (umiyameboshi) 2011/02/23</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、3.0.1における様々なバグが修正されています(pgpool-II 3.0.2のリリースはパッケージングの問題でキャンセルされました)。
</p>

<h3>互換性のない変更</h3>
<p>
<ul>
 <li>ストリーミングレプリケーションモードを使用する場合に、PostgreSQLサーバにC関数「pgpool_walrecrunning()」をインストールすることが推奨されます(後述)。この場合、新しい変数「%P」がオンラインリカバリのスクリプトで利用できるようになります。この関数をインストールしない場合は、従来と同じ動作になります(Tatsuo)
 <li>rawモードでDBノードがひとつだけの場合、DBノードに問題が発生するとダウン状態になりますが、DBノードが復旧したらpgpoolの再起動なしにDBノードを使用できるようにしました。この変更は3.0に含まれていましたが、動作していませんでした(Tatsuo, Kitagawa)
</ul>
</p>

<h3>バグ修正</h3>
<ul>
 <li>パスワード認証における移植性を損なうコードを修正しました。これはFreeBSDユーザからのバグ報告に基づきます(Tatsuo)</li>
 <li>insert_lockがユーザテーブルの全行をロックするバグを修正しました(Tatsuo, Kitagawa)</li>
 <li>ユーザ名の長さが32バイトのときにpgpool子プロセスがクラッシュするパスワード認証のバグを修正しました(Tatsuo)</li>
 <li>rawモードまたはバックエンドノード数が1のときに、pgpool子プロセスがクラッシュするmd5認証のバグを修正しました。パッチはRob Shepherdさんから頂きました(Tatsuo)</li>
 <li>以前からあった配列と複合型に対するタイムスタンプ書き換えのバグを修正しました。パッチはAkio Ishidaさんから頂きました(Tatsuo)</li>
 <li>debug_levelパラメータが動作しないバグを修正しました。パッチはGilles Daroldさんから頂きました(Tatsuo)</li>
 <li>フェイルオーバー中に起こりうるpgpool子プロセスのクラッシュを修正しました(Kitagawa)</li>
 <li>ユーザがスキーマ名の付いた関数を呼んだときにwhite/black_function_listが正しく動作するように修正しました(Tatsuo)</li>
 <li>コネクションキャッシュによってDROP DATABASEが失敗するバグを修正しました(Kitagawa)</li>
 <li>rawモードでフェイルオーバが失敗するバグを修正しました(Kitagawa)</li>
 <li>1セッションで簡易問い合わせプロトコルと拡張問い合わせプロトコルの両方が使われたときに起こりうるpgpool子プロセスの終了を修正しました(Kitagawa)</li>
 <li>拡張問い合わせプロトコルを使用中にエラーが発生すると起こりうるハングアップを修正しました(Kitagawa)</li>
 <li>PG_TRY/CATCHを使用しないようにpgpool-regclass()を修正しました。PG_TRY/CATCHは、時々バックエンドが「PANIC:  ERRORDATA_STACK_SIZE exceeded.」というメッセージとともに終了するので安全でないように見えます(Tatsuo)</li>
 <li>JDBCドライバがマスタノードに何度もBEGINを発行するロードバランスのバグを修正しました(Kitagawa)</li>
 <li>failback_commandとfail_over_on_backend_errorが正しい値を表示するようにpool_statusを修正しました(Kitagawa)</li>
 <li>pool_statusからrecovery_passwordとsystem_db_passwordを削除しました(Kitagawa)</li>
 <li>ストリーミングレプリケーションモードでフェイルオーバを実行中に、バックエンドのログに「unexpected EOF on client connection」が出ないように修正しました(Tatsuo)</li>
 <li>バックエンドがすべてダウンした場合に発生するpgpoolのクラッシュを修正しました(Tatsuo)</li>
 <li>レプリケーション遅延チェックがバックエンドとの永続的な接続を行わないように修正しました。これは、レプリケーション遅延チェックの間でDBノードのダウンとアップが起きた場合に永続的な接続が不正になる可能性があるためです(Tatsuo)</li>
 <li>英語ドキュメントを書き直してレビューしました(Marc Cousin, Gleu)</li>
 <li>以下の条件を満たすとき SELECT クエリがマスタノードに送信されないバグを修正しました(Kitagawa)
 <ul>
  <li>マスタースレーブモードである</li>
  <li>拡張問い合わせプロトコルを使用している</li>
  <li>明示的にトランザクションを開始している</li>
  <li>更新クエリを実行した後である</li>
 </ul>
 <p>ストリーミングレプリケーションモード利用時のオンラインリカバリにおいて、以下のシナリオがうまく動作しない問題を修正しました。以下のシナリオでは、ノード0を最初のプライマリサーバ、ノード1を最初のスタンバイサーバとします。</p>
      <ol>
       <li>ノード0プライマリサーバがダウンし、ノード1スタンバイサーバが新しいプライマリサーバになる</li>
       <li>ノード0の旧プライマリサーバは、オンラインリカバリで新スタンバイサーバになる</li>
       <li>このときpgpool-IIは、ノード0の新スタンバイサーバを、プライマリサーバとみなしてしまう</li>
      </ol>
      <p>これは、生きているノード番号の一番若いサーバをプライマリサーバと見なしていたためです。
      pgpool-II 3.0.3では、pgpool_walrecrunning()を使って、実際にそのノードがプライマリサーバかどうか判定するため、このような問題は起きません。
この機能をうまく使うために、オンラインリカバリのスクリプトで%P(古いプライマリノード番号)が利用できるようになっています。
なお、pgpool_walrecrunning()がインストールされていない場合は、上の問題は解消されず、3.0.1と同様の動作になります。</p>
</li>
</ul>

<h3>改良</h3>
<ul>
 <li>ステータスファイルを読んでいるときに、特定のバックエンドがダウン状態ならばログを出力するようにしました(Tatsuo)</li>
 <li>pgpoolが実行したクエリでエラーが発生した場合に、エラーメッセージを出力するようにしました(Tatsuo)</li>
 <li>sqlディレクトリに主要なMakefileを追加しました(Tatsuo)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.2 (umiyameboshi) 2011/02/17</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンは問題があったために、リリースが取り消されました。
</p>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0.1 (umiyameboshi) 2010/10/19</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、3.0における様々なバグが修正されています。
</p>

<h3>バグ修正</h3>
<ul>
 <li>認証されるサーバが複数ある場合にクラッシュするmd5認証のバグを修正しました(Tatsuo)</li>
 <li>拡張問い合わせプロトコルにおいて、構文エラーのクエリを実行したときに子プロセスがクラッシュするバグを修正しました(Kitagawa)</li>
 <li>ポータル情報のハンドリングにおける子プロセスが終了するバグを修正しました(Kitagawa)</li>
 <li>拡張問い合わせプロトコルにおいて、ひとつのノードに送信されたクエリがエラーを起こしたときにハングアップするバグを修正しました(Kitagawa)</li>
 <li>英語ドキュメントの誤植を修正しました。Asaf Ohaionさんのパッチを取り込みました(Tatsuo)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>3.0 (umiyameboshi) 2010/09/10</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンは3.0系列の最初の版で、2.2系や2.3系からの「メジャーバージョンアップ」にあたります。
PostgreSQL 9.0の新機能であるStreaming Replication/Hot Standby構成に対応するなど、多くの機能が追加されると共に、内部構造が整理されて見通しが良くなって保守性が向上しています。
</p>
<p>
マスタースレーブモード全般で多くの改善がなされています。
</p>
<ul>
 <li>明示的なトランザクション内のSELECTが負荷分散できるようになりました</li>
 <li>不必要なDBノードにparse/bindメッセージが送られなくなりロック競合が減りました</li>
 <li>不必要な内部トランザクションの起動がなくなり、オーバヘッドが軽減しています</li>
 <li>一時テーブルを意識せずに安全に使えるようになりました</li>
 <li>書き込みを伴う関数呼び出しを行なうSELECTをマスター(primay)でのみ実行するように制御できるようになりました</li>
</ul>
<p>
レプリケーションモードにおいても、書き込みを伴う関数呼び出しを行なうSELECTを負荷分散するかどうかの制御できるようになるなどの改良が加えられています。
</p>

<h3>新機能</h3>
<ul>
 <li>PostgreSQL 9.0の新機能であるStreaming Replication/Hot Standby(SR+HS)構成に対応しました(Tatsuo, Kitagawa)。
<p>pgpool-IIは基本的にはmaster/slave modeとして動作しますが、その際に "master_slave_sub_mode" という新しい設定項目に"stream"を設定することにより、SR+HS構成に最適な動作をします。
たとえば、更新クエリはPrimaryサーバにのみ送信し、SELECTはPrimaryとStandbyサーバに負荷分散することが可能です。
そのほか、Standbyサーバをオンラインリカバリで復旧したり、PrimaryとStandbyのレプリケーション同期を監視し、遅れが大きいようならPrimaryにのみSELECTを送信させるようにすることも可能です。
詳細は<a href="#stream">Streaming Replicationへの対応"</a>をご覧下さい。</p></li>

 <li>オンラインリカバリがStreaming Replication対応で動作しているmaster/slaveモードに対応しました(Tatsuo)</li>

 <li>Streaming Replicationモード用の新しい設定項目 "delay_threshold" が追加され、レプリケーションの遅れが監視できるようになりました。
遅延が多い場合には、負荷分散しないようにすることができます(Tatsuo)</li>

 <li>show pool_statusで、Streaming Replicationにおけるレプリケーションの遅延が確認できるようになりました(Tatsuo)</li>

 <li>Streaming Replicationにおけるレプリケーションの遅延のログを制御する新しい設定項目"log_standby_delay"が追加されました(Tatsuo)</li>

 <li>insert_lockが有効で、テーブルにシリアル型が含まれている場合、テーブルロックではなく、該当シーケンスを行ロックするようにしました。
以前はテーブルロックをしていましたが、auto vacuumとロックが衝突したりして性能が低下する問題がありました(Tatsuo)</li>

 <li>新しい"SHOW"コマンドが追加されました。すなわち、pool_nodes, pool_processes, pool_pools, pool_versionです(Guillaume Lelarge)</li>

 <li>pcp_proc_infoコマンドの出力結果に、PostgreSQLバックエンドプロセスのプロセスIDとフロントエンドからの接続があるかどうかが追加されました(Tatsuo)</li>

 <li>関数呼び出しを伴うSELECTを制御する設定項目white_function_listとback_function_listが追加されました(Tatsuo)</li>

 <li>マスタースレーブモードにおいて、システムカタログを検索するSELECTは、整合性を保つために常にマスター(primary)で実行されるようになりました(Tatsuo)</li>

 <li>マスタースレーブモードにおいて、一時テーブルを検索するSELECTは、整合性を保つために常にマスター(primary)で実行されるようになりました(Tatsuo)</li>

 <li>マスタスレーブモードで、明示的なトランザクション内で実行されない更新クエリにおいて、自動的にトランザクションを開始することを止めました。これは不必要でした。これによって、パフォーマンスが向上しています(Tatsuo)</li>

 <li>マスタスレーブモードで、明示的なトランザクション内で実行されるSELECTコマンドが負荷分散できるようになりました(Tatsuo, Kitagawa)</li>

 <li>マスタスレーブモードで、必要なDBノードにのみコマンドが送られるようになりました。
これにより、たとえばパースコマンドが不必要なDBノードにおいてもロックを取ってしまうようなことがなくなりました(Tatsuo, Kitagawa)</li>

 <li>pgpoolの起動時に、ステータスファイルを無視するオプションが追加されました(Tatsuo)</li>

 <li>PostgreSQL 9.0のVACUUMの新しい書式をpgpool-IIのパーサがサポートしました(Tatsuo)</li>

 <li>フェイルオーバ/フェイルバックコマンドで、"%H"という特殊変数が利用できるようになりました。
これは、新しいマスターノードのホスト名を表します(Tatsuo)</li>

 <li>failover_if_affected_tuples_mismatch という設定項目が追加されました(Tatsuo)
<p>従来、レプリケーションモードでINSERT/UPDATE/DELETEの結果行数が異なると、トランザクションをアボートしてセッションを強制切断していました。
failover_if_affected_tuples_mismatch を trueに設定すると、この現象が起きたときに、不一致のあったDBノードを切り放して縮退運転に入るようになります。</p></li>

 <li>レプリケーションモードでDBノード間でINSERT/UPDATE/DELETEの結果行数の不一致が検出された際に、各DBノードにおける結果行数がログに記録されるようになりました(Tatsuo)</li>

 <li>レプリケーションモードとマスタスレーブモードで、md5認証がサポートされました(Tatsuo)</li>

 <li>オンラインリカバリで、強制的にフロントエンドへの接続を切断して直ちにセカンドステージに入ることができるようになりました。そのためには、client_idle_limit_in_recovery に -1 を設定します(Tatsuo)</li>

 <li>RAWモードにおいて、DBノードが1個だけしか存在しない状態でDBがエラーを起したためにDBノードを切り放したあとでDBノードが回復した場合に、pgpool-IIを再起動することになしにDBノードを利用できるようになりました(Tatsuo)</li>

 <li>pcpコマンドにおいて、ロングオプションがサポートされました(Guillaume Lelarge)</li>

 <li>debug_level という設定項目が追加され、pgpool.confの再読み込みによってデバッグメッセージの出力をオン／オフできるようになりました(Tatsuo)</li>

 <li>pgpool.confで、postgresql.confと同じ真偽値表現が利用できるようになりました。従来は、true/false, 1/0しか使えませんでした(Kitagawa)</li>

 <li>オンラインリカバリのセカンドステージをより安全に実行するために、C言語関数pgpool_switch_xlogを追加しました(Kitagawa)</li>

 <li>異なるスキーマに同じ名前のテーブルが存在する場合に起きる不具合を回避するために、C言語関数pgpool_regclassを追加しました(Tatsuo)</li>

</ul>

<h3>互換性のない変更</h3>
<ul>
<li>replicate_selectとload_balance_modeを共にtrueに設定した場合、トランザクションブロックの外側で実行されるSELECT文は、replicate_selectに従うようになりました。以前は、load_balance_modeに従うようになっていました。もしクライアントがこの動作を利用している場合は、replicate_selectをfalseにしてback_function_listを設定することで同じ動作を実現できます。</li>
</ul>

<h3>バグ修正</h3>
<ul>

 <li>型が時刻データ以外の列の場合、デフォルト値にnow()が含まれていても書き換えを行なわないようにしました。
今までは無条件に書き換えを行なっていたため、書き換えの結果、INSERT文などがエラーになっていました(Tatsuo)</li>

 <li>タイムスタンプの書き換え処理対象となるテーブルのスキーマが無視されないようにしました。
ただし、この機能を有効にするためには、付属のユーザ定義関数"pgpool_regclass"のインストールが必要です。
この関数がインストールされていない場合は、依然としてスキーマが無視されてしまいます(Tatsuo)</li>

 <li>pcpコマンドのタイムアウトの扱いにおけるバグが修正されました(Tatsuo)</li>

 <li>SSLが有効な状態で、大量のデータ通信が起るとハングする問題が修正されました(Tatsuo)</li>

 <li>DBノードが1個だけしか存在しない状態でDBがエラーを起したた際に、間違ったDBノードがフェイルオーバするバグを修正しました(Tatsuo)</li>

 <li>オンラインリカバリ時のpostmasterの起動チェックにおけるバグを修正しました。
今まではpostmasterへの最初の接続が失敗すると、接続を無限に繰り返すようになっていました(Tatsuo)</li>

</ul>

<!-- ================================================================================ -->
<!-- 2.3                                                                              -->
<!-- ================================================================================ -->
<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2><a name="release2.3.4"></a>2.3.4 (tomiteboshi) 2012/08/06</h2>
<!-- -------------------------------------------------------------------------------- -->
<p>このバージョンでは、2.3.3 以前の色々なバグが修正されています。</p>

<h3>バグ修正</h3>

<ul>
<li>
do_error_execute_command() が ErrorResponse を受け取るまでバックエンドからの
結果を見ないように修正しました。 (Toshihiro Kitagawa)
<p>
ReadyForQuery のようなエラーでない結果をとっておき、pool_unread() で呼び出す必要があるためです。
これは PHP PDO を使っているときに起こる可能性がありました。
</p>
</li>

<li>
SimpleForwardToFrontend() が、SELECT 実行中に bind エラーになったとき、
select_in_transaction フラグと execute_select フラグををリセットするように修正しました。
(Toshihiro Kitagawa)
</li>

<li>
バックエンドからたくさんの結果を読み込んでいる間に、SSL 接続がハングすることが
あるのを修正しました。Tatsuo Ishii)
<p>詳細は、[Pgpool-general] Fwd: PGPOOL II 2.3.3 hang in ssl mode のスレッドを参照してください。</p>
</li>

<li>
pcp_check_fd() のタイムアウト処理のバグを修正しました。 (Tatsuo Ishii)
  <p>これは以下で報告されました。 </p>
  <blockquote>
  Subject: [Pgpool-general] question about pcp_check_fd
  Date: Sun, 23 May 2010 18:21:41 -0500
  To: pgpool <pgpool-general@pgfoundry.org>
  </blockquote>
</li>

<li>
master/slave モードで稼働中、DEALLOCATE をレプリケーションしないようにしました。(Toshihiro Kitagawa)
<p>これは、以下で Jan Kantert から報告されました。</p>
<blockquote>
Subject: [Pgpool-hackers] Problems with PgPool 2.3.3 Prepare /
         Deallocation handling in Master/Slave mode
Date: Fri, 28 May 2010 20:59:47 +0200
</blockquote>
</li>

<li>タイムスタンプの書き換えで、スキーマを認識するようにしました。(Tatsuo Ishii)</li>

<li>
now() などデフォルト値にもつがデータ型が timestamp 型でないようなカラムへの
アクセスがあるステートメントを、書き換えないようにしました。(Tatsuo Ishii)

<p>そうしていなかったために、DML でエラーになっていました。</p>
<blockquote>
Subject: [Pgpool-general] function epoch seems to be causing error
To: pgpool-general@pgfoundry.org
Date: Mon, 16 Aug 2010 21:48:31 +0000 (UTC)
</blockquote>
</li>

<li>insert_lock がスキーマを認識するようになりました。(Tatsuo Ishii)</li>

<li>
配列型や複合型のカラムのタイムスタンプ書き換えにおける、古くからあるバグを
修正しました。(Tatsuo Ishii)
<p>例えば、以下の場合に失敗していました。</p>
<pre>
INSERT INTO r1(col[1], col2.foo) VALUES (1, 2); -- insert_column_item
UPDATE r1 SET col1[1] = 1, col2.foo = 1; -- set_target
PREPARE "p" (int4[]) AS  SELECT $1[1]; -- c_expr
SELECT (ARRAY[1,2,3])[1];
SELECT (ARRAY[ARRAY[1]])[1][1];
SELECT ('{1,2,3}'::int[])[1];
SELECT ('{1,2,3}'::int[3])[1];
SELECT r1.col[1], (r1.col1).bar, (r1.col1).* FROM r1; -- columnref
SELECT (r1.col1).baz[1], (r1.col1).baz[1][2] FROM r1;
</pre>

<p>パッチは Akio Ishida から提供されました。</p>
</li>

<li>pcp パスワードが 32 文字以上のときに、バッファオーバーランするのを修正しました。(Tatsuo Ishii)</li>

<li>
wait_for_query_response() が、frontend がないときには何もしないように修正しました。(Tatsuo Ishii)
<p>
バックエンドをリセットする reset_query_list のクエリを実行に 時間がかかったときに発生する可能性があり、
またクラッシュすることがありました。
</p>
</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.3.3 (tomiteboshi) 2010/04/23</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>このバージョンでは、2.3.2.2 以前の色々なバグが修正されています。</p>

<h3>互換性のない変更</h3>
<ul>
<li>このバージョンから、pgpool が以前より多くの共有メモリを使うようになったので注意してください。
これによる問題が pgpool の起動時に発生した場合は、pgpool のログを見てください。
"could not create shared memory segment: Cannot allocate memory" といったメッセージがあれば、システムの共有メモリを増やしてください。</li>
<li>パラレルモードが、レプリケーションモードかロードバランスモードが有効でないと使えないようになりました。
pgpool-II ではずっと、レプリケーションモードかロードバランスモードが有効でないときパラレルモードは正しく動作していませんでした。(Kitagawa)</li>
<li>insert_lock のデフォルト値を false に変更しました。これは、マスタ・スレーブモードでは true にしても無意味なためです。
Fujii Masao さんの指摘により修正しました。(Tatsuo)</li>
</ul>

<h3>新しく追加したドキュメント</h3>
<ul>
<li>README.online-recovery を追加しました。このドキュメントには、オンラインリカバリの内部的なことが書いてあります。</li>
</ul>

<h3>バグ修正</h3>
<ul>
<li>子プロセスが segfault を起こす pgpool-II 1.0 から長い間存在したバグを修正しました。
これは、親プロセスが shmem サイズの計算を間違えていたことに起因します。バグ解析(Kitagawa)、パッチ作成(Tatsuo)</li>

<li>ドキュメントにパラレルモード用の以下の制約を追記しました。(Kitagawa)
  <ul>
  <li>- NATURAL JOIN は使えません。</li>
  <li>- USING 句が、クエリ書き換え処理によって ON 句に変換されます。</li>
  </ul>
</li>

<li>パラレルモードのとき、USING 句を含む JOIN 構文の書き換えで発生する可能性があったクラッシュを修正しました。(Kitagawa)<br>
  この修正により、以下のような JOIN 構文が使えるようになります。<br>
  例：<pre>
SELECT * FROM a JOIN b USING (aid) JOIN c USING (cid);
SELECT * FROM a JOIN b USING (aid) JOIN c USING (cid) JOIN d USING</pre>
</li>

<li>パラレルクエリで、分散キー列の前に current_time を含む INSERT 文のパースができるように修正しました。</li>

<li>SimpleForwardToBackend() を修正しました。
これにより、拡張プロトコルを使ったクライアントが bind エラーのようなエラーを発生させたときに、
pgpool がバックエンドの応答を待ち続けなくなります。
このバグは、マスタ・スレーブモード、raw モード、コネクションプールモードで発生していました。
これを修正したことによって、コマンドがエラーになったあと、エラーを回復させるために SYNC メッセージを送るようになります。(Kitagawa)</li>

<li>select() を実行中の pgpool 子プロセスが、SIGINT/SIGQUIT シグナルを無視するように修正しました。
シグナルが送られても pgpool は select() を再実行しようとするので、結果的にシグナルが無視されます。(Tatsuo)</li>

<li>connect_inet_domain_socket_by_port/connect_unix_domain_socket_by_port が SIGTERM/SIGINT/SIGQUIT シグナルを
受け取っていないかチェックするように修正しました。 Daniel Codina さんからのバグ報告に基づきます。(Tatsuo)</li>

<li>"kind mismatch" というエラーメッセージを生成する際にクラッシュする可能性があったので、これを修正しました。
以前は問題なかったのですが、2.3.2でエンバグしました。(Tatsuo)</li>

<li>ヘルスチェックにおけるバグを修正しました。
コードが抜けたなどでネットワーク障害が発生したときに、connect() を呼んでいる間はヘルスチェックが行なわれていませんでした。
これは、connect() が ALARM シグナルによって割り込まれた際に、connect_unix_domain_socket()/connect_inet_domain_socket() が再試行していたためです。
この修正では、上記の関数に対して再試行をコントロールするような引数を追加しています。
これは、Daniel Codina さんのバグ報告と分析に基づく修正です。(Tatsuo)</li>

<li>2.3.2.2 で、SimpleForwardToBackend でのタイムスタンプの書き換えにおいてエンバグしてい
たので、これを修正しました。これは、バグトラック #1010771 にある Peter Pramberge さんらの報告に基づきます。(Tatsuo)</li>

<li>パラレルクエリにおける "*" の書き換えを修正しました。sho さんから提供いただいたパッチを取り込みました。(Kitagawa)</li>

<li>connect_inet_domain_socket_by_port() でエラーメッセージを出力する際に、
strerror() ではなく hstrerror() を使うように修正しました。 (Tatsuo)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.3.2.2 (tomiteboshi) 2010/02/22</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、2.3.xにおける様々なバグを修正しています。
とくにタイムスタンプの書き換え時のクラッシュを含む致命的なバグが修正されているので、
すべての2.3ユーザは早急にアップグレードすることをお勧めします。
</p>

<h3>バグ修正</h3>
<ul>
 <li>タイムスタンプデータを含む拡張プロトコル問い合わせで、"message: invalid string in message"のエラーを出してトランザクションが終了してしまうバグを修正しました(Tatsuo)</li>
 <li>タイムスタンプデータを含む拡張プロトコル問い合わせで、bind時にNULLを含むパラメータが存在するとpgpoolがクラッシュするバグを修正しました(Tatsuo)</li>
 <li>pgpool_status上ですべてのノードがダウンのときにはこれを無効とし、「all node down症候群」が起きないようにしました(Tatsuo)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.3.2.1 (tomiteboshi) 2010/02/11</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、2.3.xにおいて、エラーとなるようなSQLを実行するとpgpoolへのセッションが切断されるバグを修正しています(Akio Ishida)。
</p>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.3.2 (tomiteboshi) 2010/02/07</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、2.3.1の色々なバグが修正されています。
特に、タイムスタンプの書き換え機能のバグが修正されているので、2.3, 2.3.1ユーザはなるべく早く2.3.2にアップグレードすることをお勧めします。
</p>
<p>
また、2.3.2ではSSLサポート、ラージオブジェクトのレプリケーション機能が追加されています。
</p>

<h3>改良点</h3>
<ul>
 <li>フロントエンドとpgpool-II、pgpool-IIとPostgreSQLの間のSSL通信がサポートされました(Sean Finney)
 <li>ラージオブジェクトのレプリケーションがサポートされました(Tatsuo)</li>
 <li>ヘルスチェックとオンラインリカバリの際に可能であればpostgresデータベースを使うようにしました。
      postgresデータベースが存在しない場合はtemplate1が使われます(以前の動作と同じ)。
      これにより、DROP DATABASEなどのコマンドがオンラインリカバリ中でも使えるようになりました(Tatsuo)</li>
 <li>問い合わせのパース処理でエラーが起きたときに、SQL文をログに出力するようにしました。
      エンコーディングエラーなどが発生した際にはPostgreSQLのログにもSQL文が記録されないため、これは有効です(Tatsuo)</li>
 <li>kind mismatchエラーが発生し、その原因がDEALLOCATEコマンドだった場合にDEALLOCATEが削除しようとしたPREPARED文の元になったSQL文をログに出力するようにしました(Tatsuo)</li>
</ul>

<h3>バグ修正</h3>
<ul>
 <li>たまにタイムスタンプを書き換えた問い合わせがマスタ以外のDBノードに不正なパケットを送ってしまう問題を修正しました(Tatsuo)</li>
 <li>V2プロトコルでタイムスタンプの書き換え処理がエラーになるのを修正しました(Toshihiro Kitagawa)</li>
 <li>master/slaveモード、かつトランザクション内で発行されるBind、Describe、Closeメッセージはマスタだけに送るようにしました(Tatsuo)</li>
 <li>2.3でsmart shutdownによりすぐに停止しなくなったバグを修正しました(Toshihiro Kitagawa)</li>
 <li>フロントエンドからの不正なコマンドを受け付けないようにしました(Xavier Noguer)</li>
 <li>移植性を高めるために、fprintfの引数に%dzを使用するようにしました(Tatsuo)</li>
 <li>コンパイラワーニングを修正しました(Tatsuo)</li>
 <li>master/slaveモードの際に、DEALLOCATEをすべてのノードに送らないようにして、kind mismatchエラーを防ぐようにしました(Tatsuo)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.3.1 (tomiteboshi) 2009/12/18</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、2.3の色々なバグが修正されています。
特に、ある条件でDBに不正な数値が書き込まれるバグが修正されており、以下の示す条件に合致する使い方をしている2.3ユーザは至急バージョンアップすることをお勧めします。
</p>

<h3>バグ修正と改良点</h3>
<ul>
 <li>以下のすべての条件に合致する場合、DBに不正な値が書き込まれるバグを修正しました(Tatsuo)
      <ol>
       <li>レプリケーションモードで動作</li>
       <li>64bit OS</li>
       <li>INSERTまたはUPDATEにおいて、now(), CURRENT_TIMESTAMP, CURRENT_DATE, CURRENT_TIMEを直接含むか、テーブルのデフォルト値に含んでいる</li>
       <li>更にそのSQL内に32bit(10進で-2147483648から2147483647)の範囲を超える整数定数が含まれている</li>
      </ol>
      <p>以上を満たすSQLの例:</p>
      <pre>
      INSERT INTO t1(id, regdate) VALUES(98887776655, NOW());
      </pre>
      <p>
      この例では、98887776655が32bit値にカットされて書き込まれます。
      </p>
      /li>

  <li>18以上のDBノードを使用している場合に、show pool_statusでクラッシュするバグを修正しました。
このバグはshow pool_statusが実装されてからずっと存在していたものです。</li>

  <li>"kind mismatch"メッセージが出た際に、kindがERRORまたはNOTICEならば、そのメッセージを表示するようにしました。これにより、PostgreSQLのログを見なくてもkind mismatchエラーの原因を容易に調べることができるようになりました(Tatsuo)</li>
 </ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.3 (tomiteboshi) 2009/12/07</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、レプリケーション機能に改良が加えられ、時刻データ(CURRENT_TIMESTAMP, CURRENT_DATE, now()など)を正しく扱うことができるようになりました。
また、同時接続数が1(num_init_childrenが1)のときのレプリケーション性能向上しています。
また、pgpool-II再起動時に前回のDBノードのダウン状態を記録し、不用意に復旧ノードにデータを書き込んでデータの不整合が起きることを防ぐことができるようになりました。
そのほか、クエリログが改良されてDBノード単位の状況が把握しやすくなり、またフェイルオーバの挙動が細かく制御できるようになりました。
なお、pgpool-II 2.3には、pgpool-II 2.2.1から2.2.6までのすべてのバグ修正、改良が含まれています。
</p>

<h3>pgpool-II 2.2.からの非互換性</h3>
<ul>
<li>[logdir]の下にpgpool_statusというファイルが作られるので、pgpoolの実行ユーザが読み書きできる権限を与えておいてください。</li>
</ul>

<h3>改良点</h3>
<ul>
<li>レプリケーションにおいて、時刻データ(CURRENT_TIMESTAMP, CURRENT_DATE, now()など)を正しく扱うことができるようになりました。特にアプリケーションに変更を加えることなく、INSERT/UPDATE文、テーブルのデフォルト値にこれらの時刻関数を含むケースでも正しくレプリケーションできます(いくつか制限事項があります。詳細は<a href="#restriction">制限事項</a>を参照してください)。(Akio Ishida)</li>
<li>SQLパーサをPostgreSQL 8.4のものにバージョンアップしました(Akio Ishida)</li>
<li>同時接続数が1(num_init_childrenが1)のときのレプリケーション性能が20%から100%向上しました(Tatsuo)</li>
<li>新しいディレクティブlog_per_node_statementが追加されました(Tatsuo)</li>
log_statementと似ていますが、DBノード単位でログが出力されるので、レプリケーションや負荷分散の確認が容易です。
また、バックエンドのプロセスIDも表示されるので、バックエンドのログと併せての解析が容易になっています。
<li>新しいディレクティブfail_over_on_backend_errorが追加され、フェイルオーバの挙動がより細かく制御できるようになりました(Tatsuo)</li>
<li>pgpool-II停止時にダウンしたDBノードの情報をステータスファイルに記録し、pgpool-IIを起動したときにその情報をリストアできるようにしました(Tatsuo)</li>
ステータスファイルは [logdir]/pgpoo_status というファイルに書かれます。
<li>EXPLAINと、問い合わせがSELECTのときのEXPLAIN ANALYZEが負荷分散されるようになりました。
これによって、DBノードの間で大幅に問い合わせプランが異るために、kind mismatchエラーが起きるのを防ぐことができます(Tatsuo)</li>
<li>日本語ドキュメントの体裁を改良しました(Tatsuo)</li>
<li>レプリケーションモード、マスタースレーブモード用のデフォルトpgpoo.conf.sampleが別途追加されました(Tatsuo)</li>
<li>時刻データのテストが追加されました(Akio Ishida)</li>
</ul>

<!-- ================================================================================ -->
<!-- 2.2                                                                              -->
<!-- ================================================================================ -->
<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.2.8 (urukiboshi) 2012/08/06</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>このバージョンでは、2.2.7 のバグが修正されています。</p>

<h3>バグ修正</h3>
<ul>
<li>
do_error_execute_command() が ErrorResponse を受け取るまでバックエンドからの結果を
見ないように修正しました。 (Toshihiro Kitagawa)
<p>
ReadyForQuery のようなエラーでない結果をとっておき、pool_unread() で呼び出す
必要があるためです。
これは PHP PDO を使っているときに起こる可能性がありました。
</p>
</li>

<li>
SimpleForwardToFrontend() が、SELECT 実行中に bind エラーになったとき、
select_in_transaction フラグと execute_select フラグををリセットするように修正しました。
(Toshihiro Kitagawa)
</li>

<li>
pcp_check_fd() のタイムアウト処理のバグを修正しました。 (Tatsuo Ishii)
<p>これは以下で報告されました。</p>
<blockquote>
Subject: [Pgpool-general] question about pcp_check_fd<br>
Date: Sun, 23 May 2010 18:21:41 -0500<br>
To: pgpool <pgpool-general@pgfoundry.org>
</blockquote>
</li>

<li>pcp パスワードが 32 文字以上のときに、バッファオーバーランするのを修正しました。(Tatsuo Ishii)</li>

<li>
wait_for_query_response() が、frontend がないときには何もしないように修正しました。(Tatsuo Ishii)</li>
<p>
バックエンドをリセットする reset_query_list のクエリを実行に 時間がかかったときに
発生する可能性があり、またクラッシュすることがありました。
</p>
</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.2.7 (urukiboshi) 2010/04/15</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、kind mismatchエラーが起きた際のエラーメッセージが改善されています。
また、2.2.6以前の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
<li>マスター／スレーブモード、rawモード、またはコネクションプールモードにおいて、拡張プロトコルを使用している際に時々ハングアップするバグを修正しました。これは、2.3系からのバックパッチです(Kitagawa)</li>
<li>pgpool子プロセスがsegfaultを起こすpgpool-II 1.0から長い間存在したバグを修正しました。
これは、親プロセスがshmemサイズの計算を間違えていたことに起因します。バグ解析(Kitagawa)、パッチ作成(Tatsuo)</li>
<li>マスター／スレーブモードにおいて、明示的なトランザクションで操作した場合は、Parse、Bind、Describe、そしてCloseメッセージをマスターノードのみに送るようにしました(Tatsuo)</li>
<li>postmasterが終了する際に、ログを出力するようにしました(Tatsuo)</li>
<li>make_persistent_db_connection関数のメモリリークを修正しました(Xavier Noguer)</li>
<li>マスター／スレーブモードでは、DEALLOCATEの強制的なレプリケーションをしないようにしました。
pgpoolはParseをすべてのノードで実行しないため、これは無意味で問題(DEALLOCATE実行時のkind mismatch)を引き起こしていました(Tatsuo)</li>
<li>18より多いDBノードでshow pool_statusを実行したときにクラッシュするバグを修正しました(Tatsuo)
<li>kind mismatchメッセージを改善しました。kindがERROR、またはNOTICEの場合は、何が起きているかユーザーがわかりやすいようにERROR/NOTICEメッセージを出力します(Tatsuo)</li>
</ul>


<!-- -------------------------------------------------------------------------------- -->
<h2>2.2.6 (urukiboshi) 2009/12/01</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、ロードバランスの重みパラメータweightの扱いが改善され、
また一時テーブルがマスター／スレーブモードで利用できるようになりました。
もちろんいつものように2.2.5以前の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
<li>DECLARE, CLOSE, FETCH, MOVEがロードバランスの対象にならなくなりました。
もしデータが更新され、トランザクションがコミットされた後にCLOSEが発行されるとデータの一貫性がなくなるからです
(つまり、holdできるカーソルの場合のことを言っています)(Tatsuo)</li>
<li>マスター／スレーブモードにおいて、拡張プロトコルのParseをマスター上でのみ実行するようにしました。
以前はすべてのノードでParseが実行されていたのですが、これだと不必要なロックがスレーブでも取られてしまいます(Tatsuo)</li>
<li>uninstallの前にすべてのランレベルからinitスクリプトを削除するようにしました(Devrim)</li>
<li>認証に失敗したときに適切なエラーメッセージを出すようにしました(Glyn Astill)</li>
<li>ソケットへの書き込みに失敗したときにフロントエンド用なのかバックエンド用なのかわかるようにしました(Tatsuo)</li>
<li>フロントエンド用のソケットに書き込み失敗したときにいちいちエラーを出さないようにしました(Tatsuo)</li>
<li>マスター／スレーブモードで一時テーブルが使えるようになりました。
INSERT/UPDATE/DELETEは自動的にマスタのみに送られます。SELECTに関しては明示的にクエリの前に
/*NO LOAD BALANCE*/というコメントを付けなければなりません(Tatsuo)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.2.5 (urukiboshi) 2009/10/4</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、2.2.4以前の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
<li>コネクション数のカウントのミスにより、オンラインリカバリが終わらなくなるバグを修正しました(Tatsuo)</li>
<li>内部的にロックを発行する際にもフロントエンドが異常終了したことを検出してSQLコマンドをキャンセルするようにしました(Tatsuo)</li>
<li>接続の終了処理で無限ループに陥ることがあるバグを修正しました(Xavier Noguer, Tatsuo)</li>
<li>拡張プロトコルのパース処理でkind mismatch errorが起きた際に正しいSQL文を表示するようにしました(Tatsuo)</li>
<li>ドキュメントを改善しました(Tatsuo)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.2.4 (urukiboshi) 2009/8/24</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、2.2.3以前の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
 <li>pgpool-II 2.2.2で入ってしまったバグを修正しました。フロントエンドがアボートするタイミングによっては、以後内部状態がリセットされず、次のセッションでDMLやDDLがマスターノードのみ送られ、ノード間でデータの不一致が生じることがありました(Tatsuo)</li>
 <li>pgpool-II 2.2.3でバージョン2プロトコルのクライアントが動かなくなってしまっていたのを修正しました。
      また、時間のかかるクエリを待っている間にフロントエンドが異常終了したことを検知する間隔を1秒から30秒に変更しました。このチェックは、2.2.4ではプロトコルバージョンが3のときのみ有効です(Tatsuo)</li>
 <li>子プロセスを起動する前にシグナルのブロックやハンドラの設定を行なうようにしました。
これは、pgpool-IIを起動した直後にフェイルオーバなどの事象が発生して子プロセスから親プロセスにシグナルが送られると、pgpool-IIの親プロセスが死んでしまうことがあるからです(Tatsuo)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.2.3 (urukiboshi) 2009/8/11</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、2.2.2以前の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
 <li>バックエンドに新しいコネクションを張る際に、バックエンドの一つが障害を起しているケースで、後処理の中でpgpool-IIの子プロセスが落ちることがあるバグを修正しました(Tatsuo)</li>
 <li>パラレルクエリのバグを修正しました(Yoshiharu Mori)</li>
 <li>拡張プロトコルの場合にもエラーメッセージの中で最後に使用したクエリが表示できるようになりました(Akio Ishida)</li>
 <li>kind mismatch errorメッセージの作成で、メッセージ内容が壊れることがあるバグを修正しました(Tatsuo, Akio Ishida)</li>
 <li>バックエンドへの接続記述子の参照タイミングによってはpgpool-IIの子プロセスが落ちることがあるバグを修正しました(Tatsuo)。</li>
 <li>pool_errorやpool_logの引数が間違っていた個所を修正しました(Akio Ishida)。</li>
 <li>statement_timeoutのタイムアウトによるエラー処理を改良しました。実際にはタイムアウトまでにstatement_timeoutで設定した時間の倍かかっていたのを直しました。また、masterだけがstatement_timeoutを返した場合にも対応できるようにしました。以前はkind mismatchエラーになっていました(Tatsuo)。</li>
<p>(master以外がstatement_timeoutを返さないケースではkind mismatchエラーになります)。</p>

 <li>health checkをより強化し、postmasterがSIGSTOPで止ってしまっている場合も障害検知できるようにしました。</li>

 <li>バックエンドにSQLを投げ、その応答を待っている間にクライアントがpgpoolに対するコネクションを切断したことが検出できるようになりました。
たとえば、WebアプリケーションではDBに対してリクエストを投げて、応答がないとキャンセルするようなことが頻繁に起ります。
この場合、今まではpgpoolやPostgreSQLのプロセスが残ってしまい、同時接続数が枯渇したり、ロックを取ったままのトランザクションが残るなどしてシステム全体に影響を与えることがありました。
今回の修正により、こうした状況が検出できるようになっただけでなく、SQLの応答待ちの間にクライアントがコネクションを切断した際には、SQLコマンドのキャンセルをpgpoolが行なって、ロック待ちなどのバックエンドプロセスが残るのを防ぐことができるようになりました(Tatsuo)。</li>

<li>引数なしのCLUSTERコマンドはトランザクションの中では実行できないので、自動トランザクションをスタートしないようにしました(Tatsuo)。</li>

<li>複数のプリペアドステートメントを使っている際に、セッションの終りでその一部だけが解放されるバグを修正しました(Akio Ishida)</li>
。
<li>sql/pgpool-recovery/pgpool-recovery.cがPostgreSQL 8.4でコンパイルできるようにしました(Tatsuo)。</li>

<li>拡張プロトコルを使っている場合に、クライアントとpgpoolの間でお互いに待ち状態になってしまうことがあるバグを修正しました(Gavin Sherry)。</li>

<li>COPY FROMを実行中にクライアントが処理を中断した場合に、バックエンドプロセスが残ってしまうバグを修正しました(Tatsuo)。</li>

</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.2.2 (urukiboshi) 2009/5/5</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、2.2.1以前の色々なバグが修正されています。
とりわけ、pgpoolがクライアントとの間でデータのやり取りをしている最中に、pgpoolのクライアントが終了(X)パケットをpgpoolに送信せずに終了した場合に起る可能性があります。
このバグは過去のすべてのpgpoolに存在しています。
</p>
<h3>バグ修正</h3>
<ul>
  <li>フロントエンドにpgpoolがデータを送信する際のエラーを無視するようにしました。これによって、バックエンドとの間で必要な処理が中断されないようになり、バックエンドの間でデータの一貫性がなくなる問題が回避されるようになりました(Tatsuo)。</li>

  <li>マスタースレーブモードに関する2.2.1の修正の際に生じたバグを修正しました。プリペアドステートメントを使い回すとハングアップする可能性がありました(Toshihiro)。</li>

  <li>SQLコマンドのPREPAREとプロトコルレベルのEXECUTEが混在するとバックエンドがクラッシュするバグを修正しました。このバグが、2.2で持ち込まれたものです(Tatsuo)。</li>

  <li>コネクションのリセット用の問合わせを実行中にエラーが起きた場合に、PostgreSQLのログに"unexpected EOF on client connection"が記録される問題を修正しました(Tatsuo)。</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.2.1 (urukiboshi) 2009/4/25</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、2.2の色々なバグが修正されています。
</p>
<h3>バグ修正</h3>
<ul>
  <li>master/slaveモードで、DEALLOCATEが失敗することがある問題を修正しました。
       これは、最初のPREPAREがslaveで実行されないことによるものです(Toshihiro)</li>

  <li>pgpool.specなどを2.2対応にしました(Devrim)</li>

  <li>Version 2プロトコルではinsert_lockが無視されるようにしました(Tatsuo)</li>

  <li>パラメータ変更メッセージがバックエンドから届く度にログが出力されるのを止めました(Tatsuo)</li>

  <li>ドキュメントで追加し忘れたファイルを登録しました(Tatsuo)</li>
</ul>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.2 (urukiboshi) 2009/2/28</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>概要</h3>
<p>
このバージョンでは、SERIALデータの扱いとオンラインリカバリに改良が行なわれています。
また、トランザクション分離レベルがシリアライザブルの場合に、DBノード間でデータの一貫性がなくなる可能性がある問題、クエリのキャンセルができない問題が修正されました。
</p>

<h3>新機能</h3>
<ul>
<li>insert_lockが有効な場合、SERIAL型を持つテーブルだけがロックされるようになりました(Tatsuo)。</li>
<li>設定項目client_idle_limit_in_recoveryが追加されました。
     オンラインリカバリの第2ステージでクライアントがアイドルのまま居座ることによって、
     オンラインリカバリが進行しなくなることを防ぐことができます(Tatsuo)。</li>
<li>設定項目pid_file_nameが追加されました。これは、pgpool-IIのpidファイルを指定します。
     これにより、logdirは使用されなくなりました(Tatsuo)。</li>
<li>DECLARE, FETCH, CLOSEで負荷分散されるようになりました(Tatsuo)。</li>
<li>pcpコマンドにデバッグオプション(-d)が追加されました(Jun Kuriyama)。</li>
<li>"kind mismatch"エラーの際に、原因となったクエリを表示するようにしました(Tatsuo)。</li>
</ul>

<h3>互換性</h3>
<ul>
  <li>フェイルオーバ時に必ずpgpoolの子プロセスを再起動するようにしました。
       この結果、フェイルオーバ時には必ずpgpoolへのセッションが一端切れることになります。
       こうしないと、ネットワークケーブル抜けなどの際に、
       TCP/IPのレイヤで再送が行なわれ、長い時間そのままになってしまうことが
       あるからです(Tatsuo)。</li>
  <li>設定項目logdirは使われなくなりました。代りに、pid_file_nameを使ってください(Tatsuo)。</li>

  <li>insert_lockのデフォルト値がtrueになりました(Tatsuo)。</li>
</ul>

<h3>バグ修正</h3>
<ul>
  <li> pgpoolがデーモンモードで起動される際に、すべてのファイルディスクリプタを
       閉じるようにしました。こうしないと、pgpoolAdminから起動された際に
       apacheのソケットファイルを引き継いでしまい、80番ポートが
       専有されてしまいます(Akio Ishida)。</li>
  <li> トランザクションをシリアライズできないエラーが発生したときに、
       すべてのDBノードのトランザクションをアボートするようにしました。
       こうしないと、DBノードの間でデータの不整合が起きることがあります(Tatsuo)。
       <p>例を示します(Mはマスタ、Sはスレーブを示します)。</p>
       <pre>
       M:S1:BEGIN;
       M:S2:BEGIN;
       S:S1:BEGIN;
       S:S2:BEGIN;
       M:S1:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       M:S2:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       S:S1:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       S:S2:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       M:S1:UPDATE t1 SET i = i + 1;
       S:S1:UPDATE t1 SET i = i + 1;
       M:S2:UPDATE t1 SET i = i + 1; &lt;-- blocked
       S:S1:COMMIT;
       M:S1:COMMIT;
       M:S2:ERROR:  could not serialize access due to concurrent update
       S:S2:UPDATE t1 SET i = i + 1; &lt;-- success in UPDATE and data becomes inconsistent!
       </pre></li>

 <li> rawモードでMD5認証が使えるようにしました。ドキュメント上では使えるはずでした(Tatsuo)。</li>

 <li> "SET TRANSACTION ISOLATION LEVEL must be called before any query"の
       エラーが発生した場合に"kind mimatch"エラーになることを防ぐようにしました(Tatsuo)。</li>
       <p>以下のシナリオで問題が発生します。</p>
       <pre>
       M:S1:BEGIN;
       S:S1:BEGIN;
       M:S1:SELECT 1; &lt;-- only sent to MASTER
       M:S1:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       S:S1:SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
       M: &lt;-- error
       S: &lt;-- ok since no previous SELECT is sent. kind mismatch error occurs!
       </pre></li>

<li>FreeBSDにおいて、psでのprocess statusの表示で余計なスペースが含まれてしまうのを修正しました(Jun Kuriyama)</li>

<li>BEGIN;を2度続けるとkind mismatch errorが発生するのを修正しました(Tatsuo)</li>

<li>PostgreSQLがたくさんのDEBUGメッセージを出力する場合に、誤ってエラーと見なすバグを修正しました(Tatsuo)</li>

<li>クエリのキャンセルが動くようになりました(Tatsuo)</li>

<li>オンラインリカバリの後クライアントからの接続を受け付けるタイミングが早すぎるバグを修正しました。
このバグにより、ノードデータの貫性が保たれない可能性がありました(Tatsuo)</li>

<li>SELECT, INSERT, UPDATE, DELETE以外のコマンドでも必要ならばトランザクションブロックの内側で実行するようにしました。
これにより、エラー発生の際にロールバックしてノードの整合性を保つことができます(Tatsuo)</li>

<li>オンラインリカバリ後、pgpool-IIの子プロセスがクラッシュすることがあるバグを修正しました。
これは、オンラインリカバリの後、新しくアタッチされたノードに接続がないのに、そのノードに子プロセスが終了時に終了メッセージをバックエンドに送信しようとして起っていました(Tatsuo)</li>

<li>PostgreSQLがpostgresql.confを再読み込みした際にpgpoolがエラーを検出してしまうバグを修正しました。
これは、PostgreSQLが（たぶん）ドキュメントに書かれていないタイミングで「パラメータ変更」パケットを送信してくるために起り、修正はそのことに対応したものです(Tatsuo)</li>

</ul>

<!-- ================================================================================ -->
<!-- 2.1                                                                              -->
<!-- ================================================================================ -->
<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.1 (inamiboshi) 2008/7/25</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>新機能</h3>
<ul>
  <li> failover_command と failback_command に、新しいマスタノード ID
  を表す '%m' をサポートしました。(Yoshiyuki)</li>
  <li> failover_command と failback_command に、古いマスタノード ID を
  表す '%M' をサポートしました。(Yoshiyuki)</li>
  <li> リカバリのタイムアウト時間を指定する recovery_timeout パラメー
  タを追加しました。(Taiki)</li>
  <li> pg_md5 コマンドに -p オプションを追加しました。(Volkan Yazici,
  Taiki)</li>
  <li> pgpool -v を実行するとバージョン番号を表示し、終了するようにし
  ました。(Yoshiyuki)</li>
</ul>

<h3>互換性</h3>
<ul>
  <li> pgpool_recovery と pgpool_remote_start 関数はスーパーユーザのみ実行
  できるように権限チェックを強化しました。(Yoshiyuki)</li>
  <li> raw モードでスタンバイノードにはコネクションプールを作成しない
  ようにしました。(Yoshiyuki)</li>
  <li> replication_timeout パラメータを削除しました。(Yoshiyuki)</li>
  <li> PCP クライアントコマンドのタイムアウトを無効にしました。(Taiki)</li>
  <li> replicate_select = false の場合に、COPY TO STDOUT をレプリケー
  ションさせないようにしました。(Yoshiyuki)</li>
</ul>

<h3>修正</h3>
<h4> 全般 </h4>
<ul>
  <li> CloseComplete メッセージを受けとるとクラッシュする不具合を修正
  しました。(Yoshiyuki)</li>
  <li> メッセージ転送処理を効率よくしました。(Yoshiyuki)</li>
  <li> Solaris 10 でコンパイルできるようにしました。(Yoshiyuki)</li>
  <li> ヘルスチェックとリカバリのログ出力を改良しました。(Tatsuo)</li>
  <li> 様々なメモリリークを修正しました。(Yoshiyuki)</li>
  <li> "failed to read kind from frontend" というエラーメッセージを
  ERRORレベルから LOG レベルに下げました。(Yoshiyuki)</li>
  <li> raw モードでフェイルオーバに失敗する不具合を修正しました。
  (Taiki)</li>
  <li> 不正なノードを追加・切り離しを行うとゾンビプロセスが発生する不
  具合を修正しました。(Yoshiyuki)</li>
  <li> health_check_timeout が正しく動作しない不具合を修正しました。
  (Kenichi Sawada)</li>
  <li> FreeBSD で ps コマンドの出力が正しくない不具合を修正しました。
  (ISHIDA Akio)</li>
  <li> Unix domain ソケットが残っている場合のエラーメッセージを強化し
  ました。(Jun Kuriyama)</li>
  <li> 認証に失敗した場合のエラーメッセージを強化しました。(Tatsuo)</li>
</ul>

<h4>レプリケーション</h4>
<ul>
  <li> replicate_select を設定しても、常に false の挙動になる不具合を
  修正しました。(Tatsuo)</li>
  <li> 拡張問い合わせプロトコルを使っていると、トランザクションを誤ってロー
  ルバックしてしまう不具合を修正しました。(Yoshiyuki)</li>
  <li> 非同期クエリを使っていると pgpool が不安定になる不具合を修正し
  ました。(Yoshiyuki)</li>
  <li> 拡張問合せプロトコルを使うと /* REPLICATION */などのヒント句が消えて
  しまう不具合を修正しました。(Yoshiyuki)</li>
  <li> DEALLOCATE ALL を実行するとクラッシュする不具合を修正しました。
  (Yoshiyuki)</li>
  <li> immediate shutdown するとハングアップする不具合を修正しました。
  (Yoshiyuki)</li>
  <li> 高負荷時にオンラインリカバリを実施すると、リカバリプロセスがハ
  ングアップする可能性のある不具合を修正しました。(Yoshiyuki)</li>
  <li> 拡張問合せプロトコルを使って SELECT を実行した際に、トランザク
  ションブロック内でクエリがエラーになると、pgpool がハングアップする
  可能性のある不具合を修正しました。(Yoshiyuki)</li>
</ul>

<h4>マスタースレーブ</h4>
<ul>
  <li> トランザクションブロック内で、SET, PREPARE, DEALLOCATE を実行す
  ると、プロセスがダウンする不具合を修正しました。(Yoshiyuki)</li>
  <li> マスタースレーブモードでロードバランスが正しく動作していない不
  具合を修正しました。(Yoshiyuki)</li>
</ul>

<h4>パラレルクエリ</h4>
<ul>
  <li> INSERT に失敗する不具合を修正しました。(Yoshiharu)</li>
  <li> FROM 句に AS が含まれると構文エラーになる不具合を修正しました。(sho)</li>
  <li> クエリを複数回実行するとハングアップする不具合を修正しました。(Yoshiharu)</li>
  <li> JOIN に失敗する不具合を修正しました。(Yoshiharu)</li>
  <li> DISTINCT構文 の解析に失敗する不具合を修正しました。(Yoshiharu)</li>
</ul>

<!-- ================================================================================ -->
<!-- 2.0                                                                              -->
<!-- ================================================================================ -->
<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.0.1 (hikitsuboshi) 2007/11/21</h2>
<!-- -------------------------------------------------------------------------------- -->
<ul>
  <li> UPDATE もしくは DELETE を実行するとプロセスがダウンする不具合を
       修正しました。(Yoshiyuki) </li>
  <li> master_slave を true に設定している場合に、SQL 構文エラーを検知
       した時にマスタにのみそのクエリを送信するようにしました。(Yoshiyuki)</li>
</ul>

<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2>2.0 (hikitsuboshi) 2007/11/16</h2>
<!-- -------------------------------------------------------------------------------- -->
<h3>互換性</h3>
<ul>
  <li> ignore_leading_white_space のデフォルト値を true にしました。
  (Yoshiyuki)</li>
  <li> replicate_strict を廃止しました。常に replicate_strict が true
  の挙動になります。(Yoshiyuki)</li>
</ul>

<h3>全般</h3>
<ul>
  <li> pgpool.conf をリロードできるようにしました。リロード時に分散ルー
  ルも同時にリロードします。(Yoshiyuki)</li>
  <li> SQL パーサを PostgreSQL 8.3 に対応しました。(Yoshiyuki)</li>
  <li> ノードを切り離した際にユーザが設定したコマンドを実行できるよう
  に、pgpool.conf に failover_command というパラメータを追加しました。
  (Yoshiyuki)</li>
  <li> ノードを復帰した際にユーザが設定したコマンドを実行できるように、
  pgpool.conf に failback_command というパラメータを追加しました。
  (Yoshiyuki)</li>
  <li> pgpool.conf に client_idle_limit というパラメータを追加しました。
  このパラメータではクライアントからのクエリの最大待ち時間を設定するこ
  とができます。(Tatsuo)</li>
</ul>

<h3>レプリケーション</h3>
<ul>
  <li> トランザクションブロックに囲まれていないクエリをレプリケーショ
  ンさせる場合、内部的にトランザクションを開始させるようにしました。
  (Yoshiyuki)</li>
  <li> レプリケーションを高速化させるようにしました。(Yoshiyuki)</li>
  <li> ノードを再同期させて復帰させる、オンラインリカバリ機能を実装し
  ました。(Yoshiyuki)</li>
  <li> INSERT, UPDATE, DELETE した行数がすべて一致しなかった場合に、ト
  ランザクションをアボートさせるようにしました。(Yoshiyuki)
<pre>
   x=# update t set a = a + 1;
   ERROR:  pgpool detected difference of the number of update tuples
   HINT:  check data consistency between master and other db node
</pre></li>
  <li> 複数のバックエンドから異なる結果が返ってきた場合に、同じ結果が
  多数返ってきた結果を信頼する多数決方式を実装しました。(Yoshiyuki)</li>
  <li> V2 問合せプロトコルでロードバランスできるようにしました。(Yoshiyuki)</li>
</ul>

<h3>パラレルクエリ</h3>
<ul>
  <li> パラレルモードで部分レプリケーションをサポートしました。(Yoshiharu)</li>
</ul>

<!-- ================================================================================ -->
<!-- 1.3                                                                              -->
<!-- ================================================================================ -->
<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2>1.3 (sohiboshi) 2007/10/23</h2>
<!-- -------------------------------------------------------------------------------- -->
<ul>
  <li> 新しく authentication_timeout というパラメータを追加しました。(Yoshiyuki)</li>
    <ul>
     <li>このパラメータでは認証時間のタイムアウトを設定します。 </li>
     <li>デフォルト値は 60 (1 分)です。</li>
   </ul>
  <li> スタートアップパケットの長さが 10000 バイト越えている場合には、接続を切断するようにしました。(Yoshiyuki)</li>
  <li> DEALLOCATE を実行するとまれに不正なメモリアクセスが発生する不具
       合を修正しました。(Yoshiyuki)</li>
  <li> トランザクション内で SELECT を実行した後に SELECT を正しくロードバラ
       ンスできない不具合を修正しました。(Yoshiyuki)</li>
       <ul>
    <li> この不具合は 1.2 で混入した不具合です。</li>
       </ul>
  <li> 64bit 環境でクエリキャッシュ機能を有効にすると、クラッシュする可能性のある不具合を修正しました(Yoshiyuki)</li>
</ul>

<!-- ================================================================================ -->
<!-- 1.2                                                                              -->
<!-- ================================================================================ -->
<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2>1.2.1 (tomoboshi) 2007/09/28</h2>
<!-- -------------------------------------------------------------------------------- -->
<ul>
  <li> 拡張問合せプロトコルの Parse メッセージの処理でデッドロックが発
  生する可能性がある不具合を修正しました。(Yoshiyuki)</li>

  <li> Prepared statement を管理する領域がメモリリークしている不具合を
  修正しました。(Yoshiyuki)</li>

  <li> 一部の OS でコンパイルエラーになる不具合を修正しました。(Yoshiyuki)</li>

  <li>master/slave モード内で SET, PREPARE, DEALLOCATE 文をレプリケーションさせるようにしました。(Yoshiyuki)</li>
</ul>

<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2>1.2 (tomoboshi) 2007/08/01</h2>
<!-- -------------------------------------------------------------------------------- -->
<ul>
  <li> pgpool.conf に replicate_select という新規パラメータを追加しま
  した。デフォルト値は false です。(Yoshiyuki)</li>
  <ul>
    <li> true に設定した場合は、ロードバランスされない SELECT 文をレプ
    リケーションします(pgpool-II 1.0 の挙動)。false の場合はマスタにの
    み SELECT を送信します。</li>
  </ul>

  <li> シグナル処理を安全に行うようにしました。(Yoshiyuki)</li>
  <ul>
    <li>まれにゾンビプロセスが残ってしまったり、不安定になることがありました。</li>
  </ul>

  <li> トランザクション中に SELECT 文がエラーになると、ハングアップし
  てしまう不具合を修正しました。(Yoshiyuki)</li>
  <ul>
    <li> この不具合は 1.1 に入った不具合です。</li>
  </ul>

  <li> PREPARE/EXECUTE が master/slave モードで正しく動作しない不具合
  を修正しました。(Yoshiyuki)</li>

  <li> デッドロックを検知すると、kind mismatch error が発生する不具合
  を修正しました。(Yoshiyuki)</li>

  <li> 拡張問い合わせプロトコルを使ったドライバを使用した場合に、構文
        解析時に警告が発生する SQL 文を実行するとハングアップもしくは
        プロセスがクラッシュする不具合を修正しました。(Yoshiyuki)</li>

  <li> コネクションキャッシュが一杯になるとメモリリークが発生する不具
  合を修正しました。(Yoshiyuki)</li>

  <li> セッションが残った状態で PostgreSQL を fast shutdown もしくは
  immediate shutdown すると、残ったセッションがハングアップする不具合
  を修正しました。(Yoshiyuki)</li>

  <li> ロードバランス先を接続開始時に決定し、同じセッション内ではすべ
  て同じノードにクエリを送信するようにしました。(Yoshiyuki)</li>

  <li> connection_life_time を設定している場合にバッファオーバランが発
  生する可能性がある不具合を修正しました。(Yoshiyuki)</li>

</ul>

<!-- ================================================================================ -->
<!-- 1.1                                                                              -->
<!-- ================================================================================ -->
<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2>1.1.1 (amiboshi) 2007/06/15</h2>
<!-- -------------------------------------------------------------------------------- -->
<ul>
  <li> load_balance_mode を有効にしていると、"kind mismatch" エラーが
  発生してしまう不具合を修正しました。これは 1.1 で入った不具合です。
  (Yoshiyuki)</li>
  <li> プロトコルバージョン 2 を使ったドライバでレプリケーション使用す
  ると、pgpool がハングアップする不具合を修正しました(Yoshiyuki)</li>
  <li> 拡張問合せプロトコルを使用すると、まれにデッドロックが発生する
  不具合を修正しました(Yoshiyuki)</li>
</ul>

<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2>1.1 (amiboshi) 2007/05/25</h2>
<!-- -------------------------------------------------------------------------------- -->
<ul>
  <li> HBA 認証をサポートしました(Taiki)</li>
  <li> log_connections をサポートしました(Taiki)</li>
  <li> log_hostname をサポートしました(Taiki)</li>
  <li> ps コマンドで pgpool の状態がわかるようにしました(Taiki)</li>
  <li> MacOS X でコンパイルエラーになる不具合を修正しました(Yoshiyuki)</li>
  <li> 拡張問い合わせプロトコルを使ったクエリをロードバランスできるよ
  うにしました(Yoshiyuki)</li>
  <li> レプリケーション設定時、SELECT は master にのみ送信するようにし
  ました(Yoshiyuki)
    <ul>
      <li> もし SELECT をレプリケーションさせる場合は /*REPLICATION*/
      のように SELECT の前にコメントを付ける必要があります</li>
    </ul></li>
  <li> レプリケーション設定時、SELECT nextval() および SELECT setval()
  を自動的にレプリケーションさせるようにしました(Yoshiyuki)</li>
  <li> バックエンドへ接続中にシグナルに割り込まれると、フェイルオーバ
  してしまう不具合を修正しました(Yoshiyuki)</li>
  <li> PAM 認証のサンプルファイル pgpool.pam を
  $PREFIX/share/pgpool-II/ にインストールするようにしました(Taiki)</li>
  <li> 巨大な SQL を実行しようとした場合に pgpool が無限ループに入る不
  具合を修正しました(Yoshiyuki) </li>
</ul>

<!-- ================================================================================ -->
<!-- 1.0                                                                              -->
<!-- ================================================================================ -->
<hr>

<!-- -------------------------------------------------------------------------------- -->
<h2>1.0.2 (suboshi) 2007/02/13</h2>
<!-- -------------------------------------------------------------------------------- -->
<ul>
  <li> 巨大な SQL を実行しようとした場合に pgpool が無限ループに入る不
  具合を修正しました(Yoshiyuki) </li>
  <li> 拡張問合せプロトコルを使った場合にまれに pgpool が止まってしま
  う不具合を修正しました(Yoshiyuki) </li>
  <li> フェイルオーバ、フェイルバック時のログ出力を改善しました
  (Tatsuo)</li>
  <li> SHOW pool_status の結果にバックエンドステータス情報を追加しまし
  た(Tatsuo)</li>
  <li> レプリケーション時に UPDATE/DELETE の件数が実際の件数とは異なっ
  た結果を返す不具合を修正しました(Tatsuo)</li>
  <li> 古い gcc を使うと libpq のリンクに失敗する不具合を修正しました
  (Yoshiyuki)</li>
  <li> PHP:PDO や DBD-Pg を使った場合に、自動 DEALLOCATE が失敗してし
  まう不具合を修正しました(Yoshiyuki)</li>
  <li> SELECT FOR UPDATE, SELECT INTO をロードバランスさせないようにし
  ました。また、SELECT の前にコメントがある場合もロードバランスさせな
  いようにしました。これは pgpool-I との互換性のためです。(Yoshiyuki)</li>
  <li> configure 時の libpq のデフォルトパスを pg_config コマンドを使っ
  て取得するようにしました。なお、--with-pgsql 関連のオプションは次の
  バージョンでは廃止予定です(Yoshiyuki)</li>
  <li> コネクションプール再利用時に、ソケットが壊れている場合は再接続
  するようにしました(Yoshiyuki)</li>
  <li> PostgreSQL 7.4.x の libpq を使ってビルドしようとすると、
  configure スクリプトでエラーとなってしまう不具合を修正しました
  (Yoshiyuki)</li>
</ul>

<div class="copyright">
<hr>
<copyright>
Copyright &copy; 2003 &ndash; 2014 pgpool Global Development Group
</copyright>
</div>
</body>
</html>
