<!-- doc/src/sgml/config.sgml -->

<sect1 id="runtime-config-load-balancing">
<!--
  <title>Load Balancing</title>
-->
  <title>負荷分散</title>

  <para>
<!--
    <productname>Pgpool-II</productname> load balancing of SELECT queries
    works with Master Slave mode (<xref linkend="runtime-config-master-slave-mode">)
    and Replication mode (<xref linkend="runtime-config-replication-mode">). When enabled
    <productname>Pgpool-II</productname> sends the writing queries to the
    <acronym>primay node</acronym> in Master Slave mode, all of the backend nodes
    in Replication mode, and other queries get load balanced among all backend nodes.
    To which node
    the load balancing mechanism sends read queries is decided at the
    session start time and will not be changed until the session
    ends. The only exception is by writing special SQL comments. See
    below for more details.
-->
<productname>Pgpool-II</productname>のSELECTクエリの負荷分散はマスタースレーブモード（<xref linkend="runtime-config-master-slave-mode">）とレプリケーションモード（<xref linkend="runtime-config-replication-mode">）で動作します。
有効時、<productname>Pgpool-II</productname>は更新を伴うクエリを、マスタースレーブモードでは<acronym>プライマリノード</acronym>に、レプリケーションモードでは全てのバックエンドノードに対し送信します。
そして、その他のクエリは全てのバックエンドの間で負荷分散されます。
負荷分散メカニズムが参照クエリをどのノードに送信するかはセッション開始時に決められ、セッションの終了まで変更されません。
唯一の例外は特別なSQLコマンドが発行されたときです。
詳細については以下をご覧ください。
  </para>
  <note>
    <para>
<!--
      Queries which are sent to primary node or all backend nodes because they cannot be balanced are
      also accounted for in the load balancing algorithm.
-->
負荷分散ができないためにプライマリノードまたは全バックエンドノードに送られるクエリもまた、
負荷分散アルゴリズムの考慮に入れられます。
    </para>
  </note>
  <note>
    <para>
<!--
      If you don't want a query that qualifies for the load balancing to be
      load balanced by <productname>Pgpool-II</productname>, you can put
      <emphasis>/*NO LOAD BALANCE*/</emphasis> comment before the <acronym>SELECT
      </acronym> statement. This will disable the load balance of the particular query
      and <productname>Pgpool-II</productname> will send it to the master node (the primary node in Master Slave mode).
-->
もし負荷分散対象のクエリを<productname>Pgpool-II</productname>に負荷分散してほしくない場合には、<acronym>SELECT</acronym>文の前の<emphasis>/*NO LOAD BALANCE*/</emphasis>コメントを付与することができます。
これにより、そのクエリの負荷分散は無効となり、<productname>Pgpool-II</productname>はこれをマスターノード（マスタースレーブモードではプライマリノード）に送信します。
    </para>
  </note>

  <note>
    <para>
<!--
      You can check which DB node is assigned as the load balancing
      node by using <xref linkend="sql-show-pool-nodes">.
  -->
どのDBノードが負荷分散ノードになっているかは、<xref linkend="sql-show-pool-nodes">を利用して確認できます。
    </para>
  </note>

 <sect2 id="runtime-config-load-balancing-condition">
<!--
  <title>Condition for Load Balancing</title>
-->
  <title>負荷分散の条件について</title>

  <para>
<!--
  For a query to be load balanced, all the following requirements
  must be met:
-->
クエリが負荷分散されるためには、以下の全ての条件を満たす必要があります：
  <itemizedlist>
    <listitem>
      <para>
<!--
      <productname>PostgreSQL</> version 7.4 or later
-->
<productname>PostgreSQL</>のバージョンが7.4以降である
      </para>
    </listitem>
    <listitem>
      <para>
<!--
      either in replication mode or master slave mode
-->
レプリケーションモードまたはマスタースレーブモードである
      </para>
    </listitem>
    <listitem>
      <para>
<!--
      the query must not be in an explicitly declared transaction
      (i.e. not in a BEGIN ~ END block)
-->
問い合わせが明示的なトランクザションブロックの内側にない(つまり、BEGINを発行していない)
      </para>
      <itemizedlist>
        <listitem>
          <para>
<!--
          However, if following conditions are met, load balance is possible
          even if in an explicit transaction
-->
ただし、以下の条件が満たされればトランザクションブロックの内側であっても負荷分散の対象となります。
          <itemizedlist>
            <listitem>
              <para>
<!--
              transaction isolation level is not SERIALIZABLE
-->
トランザクション分離レベルがSERIALIZABLEでない
              </para>
            </listitem>
            <listitem>
              <para>
<!--
              transaction has not issued a write query yet (until a write
              query is issued, load balance is possible. Here "write query"
              means non SELECT DML or DDL. SELECTs having write functions as
              specified in black or white function list is not regarded as
              a write query. This may be changed in the future.)
-->
トランザクション内で更新を伴うクエリが実行されていない
(更新を伴うクエリが実行されるまでは負荷分散されます。
ここで「更新を伴うクエリ」とは、SELECT以外のDDLやDMLを指します。
black/white function listで指定される更新関数を含むSELECTは更新を伴うクエリとは見なされません。
この仕様は将来変更される可能性があります)
              </para>
            </listitem>
            <listitem>
              <para>
<!--
              If black and white function list is empty, SELECTs having
              functions is regarded as a read only query.
-->
もしblack/white function listが空の場合は、関数を持つSELECTは、更新を伴うクエリとは見なされません。
              </para>
            </listitem>
          </itemizedlist>
          </para>
        </listitem>
      </itemizedlist>
    </listitem>
    <listitem>
      <para>
<!--
      it's not SELECT INTO
-->
SELECT INTO 文ではない
      </para>
    </listitem>
    <listitem>
      <para>
<!--
      it's not SELECT FOR UPDATE nor FOR SHARE
-->
SELECT FOR UPDATE/SELECT FOR SHARE文ではない
      </para>
    </listitem>
    <listitem>
      <para>
<!--
      it starts with "SELECT" or one of COPY TO STDOUT, EXPLAIN,
      EXPLAIN ANALYZE SELECT... (Except for SELECTs using writing functions
      specified in <xref linkend="guc-black-function-list"> or
      <xref linkend="guc-white-function-list">)
      <xref linkend="guc-ignore-leading-white-space"> = <literal>true</>
      will ignore leading white space.
-->
SELECT または COPY TO STDOUT, EXPLAIN, EXPLAIN ANALYZE SELECT... から始まる。
(<xref linkend="guc-black-function-list">または<xref linkend="guc-white-function-list">で指定された書き込み関数を含むSELECTを除く)
<xref linkend="guc-ignore-leading-white-space"> = <literal>true</>の場合は最初の空白文字は無視されます。
     </para>
    </listitem>
    <listitem>
      <para>
<!--
      in master slave mode, in addition to above, following conditions must be met:
-->
マスタースレーブモードの場合、更に以下の条件が満たされなければなりません。
      </para>
        <itemizedlist>
          <listitem>
            <para>
<!--
            does not use temporary tables
-->
一時テーブルを使っていない
            </para>
          </listitem>
          <listitem>
            <para>
<!--
            does not use unlogged tables
-->
unloggedテーブルを使っていない
            </para>
          </listitem>
          <listitem>
            <para>
<!--
            does not use system catalogs
-->
システムカタログを使っていない
            </para>
          </listitem>
        </itemizedlist>
    </listitem>
  </itemizedlist>
  </para>

  <note>
    <para>
<!--
    You could suppress load balancing by inserting arbitrary
    comments just in front of the SELECT query:
-->
SELECTクエリの前に任意のコメントを挿入することにより負荷分散を抑制することができます。
    </para>
    <programlisting>
/*REPLICATION*/ SELECT ...
    </programlisting>
    <para>
<!--
    If you want to use comments without supressing load balancing, you can set
    <xref linkend="guc-allow-sql-comments"> to on.
    Please refer to <xref linkend="guc-replicate-select"> as well.
-->
SQLコメントの記述が負荷分散に影響を与えないようにするには、<xref linkend="guc-allow-sql-comments">をonにします。
<xref linkend="guc-replicate-select">も参照してください。
    </para>
  </note>

  <note>
    <para>
<!--
    The JDBC driver has an autocommit option. If the autocommit is false,
    the JDBC driver sends "BEGIN" and "COMMIT" by itself, and an explicit
    tranasacttion starts. In this case the same restriction above regarding
    load balancing will be applied.
-->
JDBC ドライバにはautocommitオプションがあります。
autocommit を無効にすると、ドライバが内部でBEGINおよびCOMMITコマンドを実行し、明示的なトランザクションが開始されます。
この場合、トランザクション内における上記の負荷分散の制限事項が適用されます。
    </para>
  </note>

 </sect2>

 <sect2 id="runtime-config-load-balancing-in-streaming-raplication">

<!--
   <title>Load Balancing in Streaming Replication</title>
-->
   <title>ストリーミングレプリケーションにおける負荷分散</title>

   <para>
<!--
   While using Streaming replication and Hot Standby, it is important to
   determine which query can be sent to the primary or the standby,
   and which one should not be sent to the standby.
   <productname>Pgpool-II</>'s Streaming Replication mode carefully
   takes care of this.
-->
ストリーミングレプリケーションとHot Standbyを利用している環境では、プライマリノードに送ってよい問い合わせ、スタンバイに送ってもよい問い合わせ、両方に送らなければならない問い合わせを厳密に管理する必要があります。
<productname>Pgpool-II</>のストリーミングレプリケーションモードは、こうした振り分けを自動的に行ないます。
   </para>

   <para>
<!--
   We distinguish which query should be sent to which node by looking
   at the query itself.
-->
 クエリそのものから、どのクエリがどのノードに送られるべきかを区別します。
     <itemizedlist>
       <listitem>
         <para>
<!--
         These queries should be sent to the primary node only
-->
プライマリノードにしか送られない問い合わせ
         <itemizedlist>
           <listitem>
             <para>
             INSERT, UPDATE, DELETE, COPY FROM, TRUNCATE, CREATE, DROP, ALTER, COMMENT
             </para>
           </listitem>
           <listitem>
             <para>
             SELECT ... FOR SHARE | UPDATE
             </para>
           </listitem>
           <listitem>
             <para>
<!--
             SELECT in transaction isolation level SERIALIZABLE
-->
トランザクションの分離レベルがSERIALIZABLEの場合のSELECT
             </para>
           </listitem>
           <listitem>
             <para>
<!--
             LOCK command more strict than ROW EXCLUSIVE MODE
-->
ROW EXCLUSIVE MODEよりも強いLOCK
             </para>
           </listitem>
           <listitem>
             <para>
                DECLARE, FETCH, CLOSE
             </para>
           </listitem>
           <listitem>
             <para>
             SHOW
             </para>
           </listitem>
           <listitem>
             <para>
<!--
             Some transactional commands:
-->
トランザクションコマンドの一部
             <itemizedlist>
               <listitem>
                 <para>
                 BEGIN READ WRITE, START TRANSACTION READ WRITE
                 </para>
               </listitem>
               <listitem>
                 <para>
                 SET TRANSACTION READ WRITE, SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE
                 </para>
               </listitem>
               <listitem>
                 <para>
                 SET transaction_read_only = off
                 </para>
               </listitem>
             </itemizedlist>
             </para>
           </listitem>
           <listitem>
             <para>
<!--
             Two phase commit commands: PREPARE TRANSACTION, COMMIT PREPARED, ROLLBACK PREPARED
-->
二相コミット関連のコマンド。PREPARE TRANSACTION, COMMIT PREPARED, ROLLBACK PREPARED
             </para>
           </listitem>
           <listitem>
             <para>
             LISTEN, UNLISTEN, NOTIFY
             </para>
           </listitem>
           <listitem>
             <para>
             VACUUM
             </para>
           </listitem>
           <listitem>
             <para>
<!--
             Som sequence functions (nextval and setval)
-->
シーケンス関連の関数(nextvalやsetvalなど)の呼び出し。
             </para>
           </listitem>
           <listitem>
             <para>
<!--
             Large objects creation commands
-->
ラージオブジェクトの生成
             </para>
           </listitem>
         </itemizedlist>
       </para>
     </listitem>
     <listitem>
       <para>
<!--
       These queries can be sent to both the primary node and the standby node.
       If load balancing is enabled, these types of queries can be sent to the standby node.
       However, if delay_threshold is set and the replication delay is higher than
       <xref linkend="guc-delay-threshold">, queries are sent to the primary node.
-->
プライマリノードとスタンバイノードのどちらにも送ることのできる問い合わせ。
負荷分散設定が有効ならば、スタンバイノードにも送信されます。
レプリケーションの遅延が<xref linkend="guc-delay-threshold">を上回っている場合は問い合わせはプライマリノードに送られます。

         <itemizedlist>
           <listitem>
             <para>
             SELECT (上記以外)
             </para>
           </listitem>
           <listitem>
             <para>
             COPY TO
             </para>
           </listitem>
         </itemizedlist>
        </para>
      </listitem>
      <listitem>
        <para>
<!--
        These queries are sent to both the primary node and the standby node
-->
プライマリノードとスタンバイノードのどちらにも送られる問い合わせ
          <itemizedlist>
           <listitem>
             <para>
             SET
             </para>
           </listitem>
           <listitem>
             <para>
             DISCARD
             </para>
           </listitem>
           <listitem>
             <para>
             DEALLOCATE ALL
             </para>
           </listitem>
          </itemizedlist>
        </para>
       </listitem>
     </itemizedlist>
   </para>

   <para>
<!--
   In an explicit transaction:
-->
明示的なトランザクションでは、以下のようになります。
     <itemizedlist>

       <listitem>
         <para>
<!--
         Transaction starting commands such as BEGIN are sent to the primary node
         and the standby node.
-->
BEGINなどのトランザクション開始コマンドは、プライマリノードとスタンバイノードの両方に送られます。
         </para>
       </listitem>
       <listitem>
         <para>
<!--
         Following SELECT and some other queries that can be sent to both
         primary or standby are executed in the transaction or on the standby node.
-->
続くSELECTなど、プライマリ/スタンバイのどちらにも送ることのできる問い合わせは、プライマリのトランザクション内でそのまま実行されるか、スタンバイノードで実行されます。
         </para>
       </listitem>
       <listitem>
         <para>
<!--
          Commands which cannot be executed on the standby such as INSERT are sent
          to the primary.
          After one of these commands, even SELECTs are sent to the primary node,
          This is because these SELECTs might want to see the result of an INSERT immediately.
          This behavior continues until the transaction closes or aborts.
-->
INSERTなど、スタンバイに送ることのできない問い合わせが現われた場合はプライマリに送られます。
そういったコマンドの後は、SELECTであってもプライマリノードに送られます。
これは、INSERTなどの問い合わせの結果を SELECTが直ちに参照できるようにするためです。
この状態は、トランザクションが閉じるか、アボートするまで続きます。
         </para>
       </listitem>
     </itemizedlist>
   </para>

   <para>
<!--
   In the extended protocol, it is possible to determine if the query can
   be sent to standby or not in load balance mode while parsing the query.
   The rules are the same as for the non extended protocol.
   For example, INSERTs are sent to the primary node.
   Following bind, describe and execute will be sent to the primary node as well.
-->
問い合わせが、拡張問い合わせモードで実行される場合は、問い合わせのparse段階で、問い合わせがスタンバイに送信可能かが決まります。
その際の判断ルールは通常のSQLと同じです。
たとえば問い合わせがINSERTならば、プライマリノードに送られます。
それに後に続くbind, describe, executeも同じくプライマリに送られます。
   </para>

   <note>
     <para>
<!--
      If the parse of a SELECT statement is sent to the standby node due to load
      balancing, and then a DML statement, such as an INSERT, is sent to <productname>Pgpool-II</>,
      then the parsed SELECT will have to be executed on the primary node.
      Therefore, we re-parse the SELECT on the primary node.
-->
負荷分散によりSELECT文のparseがスタンバイノードに送信され、その後INSERTなどのDML文が<productname>Pgpool-II</>に送られた場合、parse済のSELECTはプライマリノードで実行されなければなりません。
そのため、同じSELECTがプライマリノードで再度パースされることになります。
     </para>
   </note>

   <para>
<!--
    Lastly, queries that <productname>Pgpool-II</>'s parser thinks to be an
    error are sent to the primary node.
-->
最後に、pgpool-IIのパーサが構文エラーと判断した問い合わせはプライマリノードだけに送られます。
   </para>
 </sect2>

 <sect2 id="runtime-config-load-balancing-settings">

<!--
  <title>Load Balancing Settings</title>
-->
  <title>負荷分散の設定</title>

  <variablelist>

    <varlistentry id="guc-load-balance-mode" xreflabel="load_balance_mode">
      <term><varname>load_balance_mode</varname> (<type>boolean</type>)
        <indexterm>
<!--
          <primary><varname>load_balance_mode</varname> configuration parameter</primary>
-->
          <primary><varname>load_balance_mode</varname> 設定パラメータ</primary>
        </indexterm>
      </term>
      <listitem>
        <para>
<!--
          When set to on, <productname>Pgpool-II</productname> enables the
          load balancing on incoming <acronym>SELECT</acronym> queries.
          i.e. <acronym>SELECT</acronym> queries from the clients gets distributed to
          the configured <productname>PostgreSQL</> backends.
          Default is off.
-->
onに設定すると、<productname>Pgpool-II</productname>は入ってきた<acronym>SELECT</acronym>クエリに対する負荷分散を有効にします。
すなわち、クライアントからの<acronym>SELECT</acronym>クエリは設定された<productname>PostgreSQL</>バックエンドに振り分けます。
デフォルトはoffです。
        </para>
        <para>
<!--
          This parameter can only be set at server start.
-->
このパラメータはサーバ起動時にのみ設定可能です。
        </para>
      </listitem>
    </varlistentry>

   <varlistentry id="guc-ignore-leading-white-space" xreflabel="ignore_leading_white_space">
      <term><varname>ignore_leading_white_space</varname> (<type>boolean</type>)
        <indexterm>
<!--
          <primary><varname>ignore_leading_white_space</varname> configuration parameter</primary>
-->
          <primary><varname>ignore_leading_white_space</varname> 設定パラメータ</primary>
        </indexterm>
      </term>
      <listitem>
        <para>
<!--
          When set to on, <productname>Pgpool-II</productname> ignores the
          white spaces at the beginning of SQL queries in load balancing.
          It is useful if used with APIs like DBI/DBD:Pg which adds
          white spaces against the user's intention.
-->
onに設定すると、負荷分散の際にSQL文行頭の空白を無視します(全角スペースは無視されません)。
これは、DBI/DBD:Pgのように、ユーザの意図に反してに空白を追加するようなAPIを使っているときに有用です。
        </para>
        <para>
<!--
          This parameter can be changed by reloading the <productname>Pgpool-II</> configurations.
-->
このパラメータは<productname>Pgpool-II</>の設定を再読み込みすることで変更可能です。
        </para>
      </listitem>
    </varlistentry>

   <varlistentry id="guc-white-function-list" xreflabel="white_function_list">
      <term><varname>white_function_list</varname> (<type>string</type>)
        <indexterm>
<!--
          <primary><varname>white_function_list</varname> configuration parameter</primary>
-->
          <primary><varname>white_function_list</varname> 設定パラメータ</primary>
        </indexterm>
      </term>
      <listitem>
        <para>
<!--
          Specifies a comma separated list of function names that
          <emphasis>DO NOT</emphasis> update the database. SELECTs including
          functions <emphasis>not specified </emphasis> in this list are not load balanced.
          These are replicated among all the DB nodes in Replication mode,
          sent to the primary node only in Maste Slave mode.
-->
データベースに対して更新を<emphasis>行なわない</emphasis>関数名をコンマ区切りで指定します。
このリストに<emphasis>指定されていない</emphasis>関数呼び出しを含むSELECTは負荷分散されません。
これらのクエリはレプリケーションモードにおいてはすべてのDBノードで複製され、マスタースレーブモードにおいてはプライマリノードにのみ送信されます。
        </para>
        <para>
<!--
          You can use regular expression to match function names,
          to which <literal>^</> and <literal>$</> are automatically added.
-->
関数名のマッチングに正規表現を使うことができます。
正規表現には自動的に<literal>^</literal>と<literal>$</literal>が付与されます。
        </para>

        <example id="example-white-function-list-1">
<!--
          <title>Using regular expression</title>
-->
          <title>正規表現の使用</title>
          <para>
<!--
            If you have prefixed all your read only function
            with 'get_' or 'select_', You can
            set the <xref linkend="guc-white-function-list"> like below:
-->
もし読み出しのみを行う関数が"get_"あるいは"select_"で始まるようにしてあるのであれば、<xref linkend="guc-white-function-list">を以下のように設定可能です。
          <programlisting>
white_function_list = 'get_.*,select_.*'
          </programlisting>
          </para>
        </example>

        <para>
<!--
          This parameter can be changed by reloading the <productname>Pgpool-II</> configurations.
-->
このパラメータは<productname>Pgpool-II</>の設定を再読み込みすることで変更可能です。
        </para>
      </listitem>
    </varlistentry>

   <varlistentry id="guc-black-function-list" xreflabel="black_function_list">
      <term><varname>black_function_list</varname> (<type>string</type>)
        <indexterm>
<!--
          <primary><varname>black_function_list</varname> configuration parameter</primary>
-->
          <primary><varname>black_function_list</varname> 設定パラメータ</primary>
        </indexterm>
      </term>
      <listitem>
        <para>
<!--
          Specifies a comma separated list of function names that
          <emphasis>DO</emphasis> update the database.
          SELECTs including functions <emphasis>specified</emphasis> in this list are
          not load balanced.
          These are replicated among all the DB nodes in Replication mode,
          sent to the primary node only in Maste Slave mode.
-->
データベースに対して更新を<emphasis>行う</emphasis>関数名をコンマ区切りで指定します。
このリストに<emphasis>指定された</emphasis>関数呼び出しを含むSELECTは負荷分散されません。
これらのクエリはレプリケーションモードにおいてはすべてのDBノードで複製され、マスタースレーブモードにおいてはプライマリノードにのみ送信されます。
        </para>
        <para>
<!--
          You can use regular expression to match function names,
          to which <literal>^</> and <literal>$</> are automatically added.
-->
関数名のマッチングに正規表現を使うことができます。
正規表現には自動的に<literal>^</literal>と<literal>$</literal>が付与されます。
        </para>

        <example id="example-black-function-list-1">
<!--
          <title>Using regular expression</title>
-->
          <title>正規表現の使用</title>
          <para>
<!--
            If you have prefixed all your updating functions
            with 'set_', 'update_', 'delete_' or 'insert_', You can
            set the <xref linkend="guc-black-function-list"> like below:
-->
もし更新を行う関数が"set_"、"update_"、"delete_"、あるいは"insert_"で始まるようにしてあるのであれば、<xref linkend="guc-black-function-list">を以下のように設定可能です。
          <programlisting>
black_function_list = 'nextval,setval,set_.*,update_.*,delete_.*,insert_.*'
          </programlisting>
          </para>
        </example>

        <note>
          <para>
<!--
            <xref linkend="guc-black-function-list"> and <xref linkend="guc-white-function-list">
            are mutually exclusive and only one of the two lists can be set in the configuration.
-->
<xref linkend="guc-black-function-list">と<xref linkend="guc-white-function-list">は互いに排他的で、２つのリストの内、どちらか一方のみ設定することができます。
          </para>
        </note>

        <example id="example-black-function-list-2">
<!--
          <title>Configuring to send <literal>nextval()</literal> and <literal>setval()</literal> to the proper backend</title>
-->
          <title><literal>nextval()</literal>と<literal>setval()</literal>を適切なバックエンドに送る設定</title>
          <para>
<!--
            Prior to <productname>Pgpool-II</productname><emphasis>V3.0</emphasis>,
            <literal>nextval()</literal> and <literal>setval()</literal> were known as functions writing to the database.
            You can configure this by setting <xref linkend="guc-black-function-list">
            and <xref linkend="guc-white-function-list"> as follows
-->
<productname>Pgpool-II</productname> <emphasis>V3.0</emphasis>より前のバージョンでは、固定で<literal>nextval()</literal>と<literal>setval()</literal>がデータベースに書き込みを行なう関数であると認識されていました。
以下のように<xref linkend="guc-white-function-list">と<xref linkend="guc-black-function-list">を設定することで、それと同じように動作させることができます。
              <programlisting>
white_function_list = ''
black_function_list = 'nextval,setval,lastval,currval'
              </programlisting>
          </para>
          </example>

        <note>
          <para>
<!--
            <productname>PostgreSQL</> also contains <literal>lastval()</literal> and
            <literal>currval()</literal> in addition to
            <literal>nextval()</literal> and <literal>setval()</literal>.
            Though <literal>lastval()</literal> and <literal>currval()</literal>
            are not writing function type, but it is advised to treat
            <literal>lastval()</literal> and <literal>currval()</literal>
            as writing functions to avoid errors which occur when
            these functions are accidentally load balanced.
-->
<productname>PostgreSQL</>には<literal>nextval()</literal>と<literal>setval()</literal>に加え、<literal>lastval()</literal>と<literal>currval()</literal>があります。
<literal>lastval()</literal>と<literal>currval()</literal>は書き込みを行う関数ではありませんが、これらの関数が負荷分散されることで発生するエラーを防ぐため、<literal>lastval()</literal>と<literal>currval()</literal>を書き込みを行う関数として扱うのが望ましいです。
          </para>
        </note>
        <para>
<!--
          This parameter can be changed by reloading the <productname>Pgpool-II</> configurations.
-->
このパラメータは<productname>Pgpool-II</>の設定を再読み込みすることで変更可能です。
        </para>
      </listitem>
    </varlistentry>

   <varlistentry id="guc-black-query-pattern-list" xreflabel="black_query_pattern_list">
      <term><varname>black_query_pattern_list</varname> (<type>string</type>)
        <indexterm>
<!--
          <primary><varname>black_query_pattern_list</varname> configuration parameter</primary>
-->
          <primary><varname>black_query_pattern_list</varname> 設定パラメータ</primary>
        </indexterm>
      </term>
      <listitem>
        <para>
<!--
          Specifies a semicolon separated list of SQL patterns that
          should be sent to primary node.
          SQL that matched patterns specified in this list are
          not load balanced.
          Only Maste Slave mode is supported.
-->
特定の SQL をプライマリノードに送信するように <xref linkend="guc-black-query-pattern-list">を設定します。
SQL パターンをセミコロン区切りで指定します。
マスタースレーブモードのみで動作します。
        </para>
        <para>
<!--
          You can use regular expression to match function names,
          to which <literal>^</> and <literal>$</> are automatically added.
-->
SQL のマッチングに正規表現を使うことができます。
正規表現には自動的に<literal>^</literal>と<literal>$</literal>が付与されます。
"'"、";" あるいは "*" などの文字を SQL パターンの中で利用する場合、"\" でエスケープする必要があります。
        </para>

        <example id="example-black-query-pattern-list-1">
<!--
          <title>Using regular expression</title>
-->
          <title>正規表現の使用</title>
          <para>
<!--
            If the following SQL should be sent to the primary node only, You can
            set the <xref linkend="guc-black-query-pattern-list"> like below:
-->
もし以下の SQL をプライマリノードに送信したい場合、<xref linkend="guc-black-query-pattern-list">を以下のように設定可能です。

         <itemizedlist>
           <listitem>
             <para>
             SELECT * FROM table_name1;
             </para>
           </listitem>
           <listitem>
             <para>
             SELECT col1, col2 FROM table_name2 WHERE col1 LIKE '%a%';
             </para>
           </listitem>
           <listitem>
             <para>
<!--
             SQL including table_nama3
-->
             table_name3 という文字列を含む SQL
             </para>
           </listitem>
         </itemizedlist>
          </para>

          <para>
          <programlisting>
black_query_pattern_list = 'SELECT \* FROM table_name1\;;SELECT col1, col2 FROM table_name2 WHERE col1 LIKE \'%a%\'\;;.*table_name3.*'
          </programlisting>
          </para>
        </example>

        <note>
          <para>
<!--
            If SQL matches both <xref linkend="guc-black-function-list"> and
            <xref linkend="guc-white-function-list">, <xref linkend="guc-white-function-list">
            setting is ignored and the SQL should be sent only to the primary node.
-->
<xref linkend="guc-black-query-pattern-list">と<xref linkend="guc-white-function-list">の両方にマッチした場合、
<xref linkend="guc-white-function-list">の設定が無視され、プライマリノードのみに送信されます。
          </para>
        </note>
        <para>
<!--
        Depending on SQL pattern, performance may be 1-2% lower than turning off this feature.
-->
SQL のパターンにもよりますが、この機能を使用する場合、パフォーマンスが 1-2％ 低下する可能性があります。
        </para>
        <para>
<!--
          This parameter can be changed by reloading the <productname>Pgpool-II</> configurations.
-->
このパラメータは<productname>Pgpool-II</>の設定を再読み込みすることで変更可能です。
        </para>
      </listitem>
    </varlistentry>

   <varlistentry id="guc-database-redirect-preference-list" xreflabel="database_redirect_preference_list">
      <term><varname>database_redirect_preference_list</varname> (<type>string</type>)
        <indexterm>
<!--
          <primary><varname>database_redirect_preference_list</varname> configuration parameter</primary>
-->
          <primary><varname>database_redirect_preference_list</varname> 設定パラメータ</primary>
        </indexterm>
      </term>
      <listitem>
        <para>
<!--
         Specifies the list of <replaceable>"database-name:node id"</replaceable> pairs
         to send <acronym>SELECT</acronym> queries to a particular backend
         node for a particular database connection.
-->
特定のデータベース接続で<acronym>SELECT</acronym>クエリが指定したロードバランス比率で特定のバックエンドノードに送信されるように、"<replaceable>データベース名:ノードID(比率)</replaceable>"ペアのリストを指定します。ロードバランス比率は0-1の間の値を指定します。
比率の指定を省略した場合は、デフォルトの1.0となります。
        </para>
        <para>
<!--
         For example, by specifying "test:1", <productname>Pgpool-II</productname>
         will redirect all <acronym>SELECT</acronym> queries to the backend node of ID 1 for
         the connection to "test" database.
         You can specify multiple <replaceable>"database name:node id"</replaceable> pair by separating them
         using comma (,).
-->
たとえば"test:1(0.5)"とした場合、"test"データベースへの接続においては、<productname>Pgpool-II</productname>は50%の<acronym>SELECT</acronym>クエリをIDが1のバックエンドノードに送信します。
複数の"<replaceable>データベース名:ノードID</replaceable>"のペアを カンマ(,)で区切って指定することができます。
        </para>
        <para>
<!--
         Regular expressions are also accepted for database name.
         You can use special keywords as <replaceable>node id</replaceable>.
         If <emphasis>"primary"</emphasis> is specified, queries are sent to the primary node, and
         if <emphasis>"standby"</emphasis> is specified, one of the standby nodes are selected randomly
         based on weights.
-->
データベース名には正規表現を指定することができます。
<replaceable>ノードID</replaceable>には特別なキーワードを使うことができます。
"<emphasis>primary</emphasis>"が指定された場合にはクエリはプライマリノードに送られます。
また、"<emphasis>standby</emphasis>"が指定された場合はスタンバイノードのうちどれかをウェイト(<xref linkend="guc-backend-weight">)に応じてランダムに選択します。
        </para>

        <example id="example-database-redirect-list">
<!--
          <title>Using database_redirect_preference_list</title>
-->
          <title>database_redirect_preference_listの利用</title>
          <para>
<!--
            If you want to configure the following <acronym>SELECT</acronym> query routing rules:
-->
<acronym>SELECT</acronym>クエリのルーティングルールを以下のように設定したい場合：
          </para>

          <itemizedlist>
            <listitem>
              <para>
<!--
                Route all <acronym>SELECT</acronym> queries on <literal>postgres</literal>
                database to the primary backend node.
-->
全ての<literal>postgres</literal>データベースにおける<acronym>SELECT</acronym>クエリはプライマリバックエンドノードに送る。
              </para>
            </listitem>
            <listitem>
              <para>
<!--
                Route all <acronym>SELECT</acronym> queries on <literal>mydb0</literal> or on
                <literal>mydb1</literal> databases to backend node of ID 1.
-->
全ての<literal>mydb0</literal>または<literal>mydb1</literal>データベースにおける30%の<acronym>SELECT</acronym>クエリはIDが1のバックエンドノードに送る。
              </para>
            </listitem>
            <listitem>
              <para>
<!--
                Route all <acronym>SELECT</acronym> queries on <literal>mydb2</literal>
                database to standby backend nodes.
-->
全ての<literal>mydb2</literal>データベースにおける<acronym>SELECT</acronym>クエリはスタンバイバックエンドノードに送る。
              </para>
            </listitem>

          </itemizedlist>
          <para>
<!--
            then the <xref linkend="guc-database-redirect-preference-list"> will be configured as follows:
-->
<xref linkend="guc-database-redirect-preference-list">は以下のように設定します。
              <programlisting>
database_redirect_preference_list = 'postgres:primary,mydb[01]:1(0.3),mydb2:standby'
              </programlisting>
          </para>
        </example>

        <para>
<!--
          This parameter can be changed by reloading the <productname>Pgpool-II</> configurations.
-->
このパラメータは<productname>Pgpool-II</>の設定を再読み込みすることで変更可能です。
        </para>
      </listitem>
    </varlistentry>

   <varlistentry id="guc-app-name-redirect-preference-list" xreflabel="app_name_redirect_preference_list">
      <term><varname>app_name_redirect_preference_list</varname> (<type>string</type>)
        <indexterm>
<!--
          <primary><varname>app_name_redirect_preference_list</varname> configuration parameter</primary>
-->
          <primary><varname>app_name_redirect_preference_list</varname> 設定パラメータ</primary>
        </indexterm>
      </term>
      <listitem>

        <para>
<!--
          Specifies the list of <replaceable>"application-name:node id"</replaceable> pairs
          to send <acronym>SELECT</acronym> queries to a particular backend
          node for a particular client application connection.
-->
特定のクライアントアプリケーションの接続で<acronym>SELECT</acronym>クエリが指定したロードバランス比率で特定のバックエンドノードに送信されるように、"<replaceable>アプリケーション名:ノードID(比率)</replaceable>"ペアのリストを指定します。
        </para>

        <note>
          <para>
<!--
            The "Application name" is a name specified by a client when it connects to database,
            and is avalable in <productname>PostgreSQL</> <emphasis>V9.0</> or later.
-->
「アプリケーション名」とはクライアントがデータベースに接続する時に指定する名称で、<productname>PostgreSQL</> <emphasis>V9.0</>以降で利用可能です。
          </para>
         </note>

        <para>
<!--
          For example, application name of <command>psql</command> command is
          <literal>"psql"</literal>
-->
たとえば、<command>psql</command>コマンドのアプリケーション名は"<literal>psql</literal>"です。
        </para>

        <note>
          <para>
<!--
            <productname>Pgpool-II</productname> recognizes the application name
            only specified in the start-up packet sent from the client.
            Although a client can provide the application name
            later in the session, but that does not get considered by the
            <productname>Pgpool-II</productname> for query routing.
-->
<productname>Pgpool-II</productname>は、クライアントから送信されたスタートアップパケットに含まれるアプリケーション名だけを認識します。
クライアントは事後にセッションの中でアプリケーション名を指定できますが、それは<productname>Pgpool-II</productname>のクエリルーティングでは考慮されません。
          </para>
        </note>

        <para>
<!--
          The notion of <xref linkend="guc-app-name-redirect-preference-list">
          is same as the <xref linkend="guc-database-redirect-preference-list">
          thus you can also use the regular expressions for application names.
          Similarly special keyword <emphasis>"primary"</emphasis> indicates the primary node and
         <emphasis>"standby"</emphasis> indicates one of standby nodes.
-->
<xref linkend="guc-app-name-redirect-preference-list">の記法は<xref linkend="guc-database-redirect-preference-list">と同じですので、アプリケーション名には正規表現も使用できます。
同様に特別なキーワード"<emphasis>primary</emphasis>"はプライマリノードを、"<emphasis>standby</emphasis>"はスタンバイサーバのいずれかを意味します。
ロードバランス比率は0-1の間の値を指定します。ロードバランス比率の指定を省略した場合は、デフォルトの1.0となります。
        </para>

        <example id="example-app-name-redirect-list">
<!--
          <title>Using app-name_redirect_preference_list</title>
-->
          <title>app_name_redirect_preference_listの利用</title>
          <para>
<!--
            If you want to configure the following <acronym>SELECT</acronym> query routing rules:
-->
<acronym>SELECT</acronym>クエリのルーティングルールを以下のように設定したい場合：
          </para>

          <itemizedlist>
            <listitem>
              <para>
<!--
                Route all <acronym>SELECT</acronym> from <literal>psql</literal>
                client to the primary backend node.
-->
全ての<literal>psql</literal>クライアントからの<acronym>SELECT</acronym>クエリはプライマリバックエンドノードに送る。
              </para>
            </listitem>
            <listitem>
              <para>
<!--
                Route all <acronym>SELECT</acronym> queries from <literal>myapp1</literal>
                client to backend node of ID 1.
-->
全ての<literal>myapp1</literal>クライアントからの30%の<acronym>SELECT</acronym>クエリはIDが1のバックエンドノードに送る。
              </para>
            </listitem>
            <listitem>
              <para>
<!--
                Route all <acronym>SELECT</acronym> queries from <literal>myapp2</literal>
                client to standby backend nodes.
-->
全ての<literal>myapp2</literal>クライアントからの<acronym>SELECT</acronym>クエリはスタンバイバックエンドノードに送る。
              </para>
            </listitem>

          </itemizedlist>
          <para>
<!--
            then the <xref linkend="guc-app-name-redirect-preference-list"> will be configured as follows:
-->
<xref linkend="guc-app-name-redirect-preference-list">は以下のように設定します。
              <programlisting>
app_name_redirect_preference_list = 'psql:primary,myapp1:1(0.3),myapp2:standby'
              </programlisting>
          </para>
        </example>

        <note>
          <para>
<!--
            <xref linkend="guc-app-name-redirect-preference-list"> takes precedence
            over the <xref linkend="guc-database-redirect-preference-list">.
-->
<xref linkend="guc-app-name-redirect-preference-list">は、<xref linkend="guc-database-redirect-preference-list">よりも優先されます。
          </para>
          <para>
<!--
			For example, if you set
			<literal>database_redirect_preference_list = 'postgres:standby(1.0)'</literal> and
			<literal>app_name_redirect_preference_list = 'psql:primary(1.0)'</literal>,
			all SELECT from psql client on postgres database will be sent to primary backend node.
-->
たとえば、
<literal>database_redirect_preference_list = 'postgres:standby(1.0)'</literal>、
<literal>app_name_redirect_preference_list = 'myapp1:primary(1.0)'</literal>
と設定した場合、アプリケーション<literal>myapp1</literal>、<literal>postgres</literal>データベースでの<literal>SELECT</literal>はプライマリバックエンドノードに送られます。
          </para>
        </note>

        <note>
          <para>
<!--
			In the settings of <xref linkend="guc-app-name-redirect-preference-list"> and
			<xref linkend="guc-database-redirect-preference-list">, when multiple database
			names and application names are matched, the first setting will be used.
-->
<xref linkend="guc-app-name-redirect-preference-list">及び<xref linkend="guc-database-redirect-preference-list">の設定では、複数のデータベース名やアプリケーション名にマッチした場合、最初の設定が反映されます。
          </para>
          <para>
<!--
			For example, if you set
			database_redirect_preference_list = 'postgres:primary,postgres:standby',
			"postgres: primary" will be used.
-->
たとえば、
<literal>database_redirect_preference_list = 'postgres:primary,postgres:standby'</literal>
と設定した場合、<literal>postgres:primary</literal>の設定が反映されます。
          </para>
        </note>

        <caution>
          <para>
<!--
            <acronym>JDBC</acronym> driver postgreSQL-9.3 and earlier versions
            does not send the application name in the startup packet even if
            the application name is specified using the <acronym>JDBC</acronym>
            driver option <literal>"ApplicationName"</literal> and
            <literal>"assumeMinServerVersion=9.0"</literal>.
            If you want to use the <xref linkend="guc-app-name-redirect-preference-list">
            feature through <acronym>JDBC</acronym>, use postgreSQL-9.4 or later version of the driver.
-->
<acronym>JDBC</acronym>ドライバのpostgresql-9.3以前のバージョンでは、<acronym>JDBC</acronym>ドライバの"<literal>ApplicationName</literal>" と "<literal>assumeMinServerVersion=9.0</literal>"オプションを指定してもスタートアップパケットの中にアプリケーション名を含みません。
<acronym>JDBC</acronym>から<xref linkend="guc-app-name-redirect-preference-list">機能を使用したければ、postgresql-9.4 以降のドライバをお使いください
          </para>
        </caution>

        <para>
<!--
          This parameter can be changed by reloading the <productname>Pgpool-II</> configurations.
-->
このパラメータは<productname>Pgpool-II</>の設定を再読み込みすることで変更可能です。
        </para>
      </listitem>
    </varlistentry>

   <varlistentry id="guc-allow-sql-comments" xreflabel="allow_sql_comments">
      <term><varname>allow_sql_comments</varname> (<type>boolean</type>)
        <indexterm>
<!--
          <primary><varname>allow_sql_comments</varname> configuration parameter</primary>
-->
          <primary><varname>allow_sql_comments</varname> 設定パラメータ</primary>
        </indexterm>
      </term>
      <listitem>
        <para>
<!--
        When set to on, <productname>Pgpool-II</productname> ignore the
        <acronym>SQL</acronym> comments when identifying if the load balance
        or query cache is possible on the query.
        When this parameter is set to off, the <acronym>SQL</acronym> comments
        on the query could effectively prevent the query from being
        load balanced or cached (pre <productname>Pgpool-II</productname>
        <emphasis>V3.4</emphasis> behavior).
-->
onに設定すると、<productname>Pgpool-II</productname>は負荷分散やクエリキャッシュができるかどうかの判定の際に<acronym>SQL</acronym>コメントを無視します。
このパラメータがoffに設定されている場合、クエリの<acronym>SQL</acronym>コメントにより、クエリの負荷分散やキャッシュを防止することができます。
（<productname>Pgpool-II</productname> <emphasis>V3.4</emphasis>より前のバージョンの動作です）。
        </para>
        <para>
<!--
          This parameter can be changed by reloading the <productname>Pgpool-II</> configurations.
                    You can also use <xref linkend="SQL-PGPOOL-SET"> command to alter the value of
                    this parameter for a current session.
-->
このパラメータは<productname>Pgpool-II</>の設定を再読み込みすることで変更可能です。
現在のセッションでのパラメータ値は、<xref linkend="SQL-PGPOOL-SET">コマンドで変更することもできます。
        </para>
      </listitem>
    </varlistentry>

   <varlistentry id="guc-disable-load-balance-on-write" xreflabel="disable_load_balance_on_write">
      <term><varname>disable_load_balance_on_write</varname> (<type>string</type>)
        <indexterm>
<!--
          <primary><varname>disable_load_balance_on_write</varname> configuration parameter</primary>
-->
          <primary><varname>disable_load_balance_on_write</varname>設定パラメータ</primary>
        </indexterm>
      </term>
      <listitem>
        <para>
<!--
	  Specify load balance behavior after write queries appear.
	  This parameter is especially useful in streaming replication
	  mode. When write queries are sent to primary server, the
	  changes are applied to standby servers but there's a time
	  lag. So if a client read the same row right after the write
	  query, the client may not see the latest value of the
	  row. If that's the problem, clients should always read data
	  from the primary server. However this effectively disables
	  load balancing, which leads to lesser performance. This
	  parameter allows a fine tuning for the trade off between
	  not-clustering-aware applications compatibility and
	  performance.
-->
writeクエリが発行された時の負荷分散の振る舞いを指定します。
このパラメータは、特にストリーミングレプリケーションモードで有効です。
writeクエリがプライマリサーバに送られた時、この変更はスタンバイサーバにも適用されますが、そこには時間差があります。
ですからクライアントが行を更新して同じ行をスタンバイから読むと、その行の最新データを読めないかもしれません。
もしこれが問題になるようなら、クライアントは常にプライマリサーバからデータを読むべきです。
しかし、これは実質的に負荷分散を無効にして、性能低下をもたらします。
このパラメータは、クラスタリングについて考慮しないアプリケーションにおける互換性と、性能の間におけるトレードオフの細かな調整を可能にします。
	</para>
	<para>
<!--
	  If this parameter is set to <varname>off</varname>, read
	  queries are load balanced even if write queries appear. This
	  gives the best load balance performance but clients may see
	  older data. This is useful for an environment where
	  PostgreSQL parameter synchronous_commit = 'remote_apply', or
	  in the native replication mode, since there's no replication
	  delay in such environments.
-->
このパラメータが<varname>off</varname>なら、writeクエリが来ても負荷分散が行われます。
この設定では最大の性能を期待できますが、クライアントは古いデータを読むことになるかもしれません。
この設定は、PostgreSQLのパラメータsynchronous_commit = 'remote_apply'が設定されているか、ネィティブレプリケーションモードのときに有用です。
そのような環境ではレプリケーションの遅延が発生しないからです。
	</para>
	<para>
<!--
	  If this parameter is set to <varname>transaction</varname>
	  and write queries appear in an explicit transaction,
	  subsequent read queries are not load balanced until the
	  transaction ends.  Please note that read queries not in an
	  explicit transaction are not affected by the parameter. This
	  setting gives the best balance in most cases and you should
	  start from this. This is the default and same behavior in
	  <productname>Pgpool-II 3.7</productname> or before.
-->
このパラメータが<varname>transaction</varname>で、明示的なトランザクション中にwriteクエリが来ると、トランザクションが終了するまで負荷分散が行われません。
なお、明示的なトランザクション中ではないreadクエリは、このパラメータの影響を受けないことに注意してください。
この設定は、たいていの場合に最良のバランスを提供するので、この設定から試すことをお勧めします。
これはデフォルトで、<productname>Pgpool-II 3.7</productname>以前のバージョンと同じ振る舞いです。
	</para>
	<para>
<!--
	  If this parameter is set
	  to <varname>trans_transaction</varname> and write queries
	  appear in an explicit transaction, subsequent read queries
	  are not load balanced in the transaction and subsequent
	  explicit transaction until the session ends. So this
	  parameter is safer for older applications but give lesser
	  performance than <varname>transaction</varname>. Please note
	  that read queries not in an explicit transaction are not
	  affected by the parameter.
-->
このパラメータが<varname>trans_transaction</varname>で、明示的なトランザクション中にwriteクエリが来ると、トランザクションが終了するまで負荷分散が行われません。
また、セッションが終了するまで後続の明示的なトランザクション中でも負荷分散が行われません。
この設定は古いアプリケーションにとって安全ですが、<varname>transaction</varname>よりは性能が低下します。
なお、明示的なトランザクション内にないreadクエリは、このパラメータの影響を受けないことに注意してください。
	</para>

	<para>
<!--
	  If this parameter is set to <varname>always</varname> and
	  write queries appear, subsequent read queries are not load
	  balanced until the session ends regardless they are in
	  explicit transactions or not. This gives the highest
	  compatibility with not-clustering-aware applications and the
	  lowest performance.
-->
このパラメータが<varname>always</varname>で、writeクエリが来ると、明示的なトランザクション中であるかどうかを問わず、セッションが終了するまで負荷分散が行われません。
この設定により、クラスタリングについて考慮しないアプリケーションを使った場合最大の互換性が得られますが、性能は最低になります。
	</para>
      </listitem>
    </varlistentry>

  </variablelist>
 </sect2>
</sect1>
